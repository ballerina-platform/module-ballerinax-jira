// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

// Copyright (c) 2025, WSO2 LLC. (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.


import ballerina/data.jsondata;
import ballerina/http;
import ballerina/mime;

# Jira Cloud platform REST API documentation
public isolated client class Client {
    final http:Client clientEp;
    # Gets invoked to initialize the `connector`.
    #
    # + config - The configurations to be used when initializing the `connector` 
    # + serviceUrl - URL of the target service 
    # + return - An error if connector initialization failed 
    public isolated function init(ConnectionConfig config, string serviceUrl = "https://your-domain.atlassian.net/rest") returns error? {
        http:ClientConfiguration httpClientConfig = {auth: config.auth, httpVersion: config.httpVersion, http1Settings: config.http1Settings, http2Settings: config.http2Settings, timeout: config.timeout, forwarded: config.forwarded, followRedirects: config.followRedirects, poolConfig: config.poolConfig, cache: config.cache, compression: config.compression, circuitBreaker: config.circuitBreaker, retryConfig: config.retryConfig, cookieConfig: config.cookieConfig, responseLimits: config.responseLimits, secureSocket: config.secureSocket, proxy: config.proxy, socketConfig: config.socketConfig, validation: config.validation, laxDataBinding: config.laxDataBinding};
        self.clientEp = check new (serviceUrl, httpClientConfig);
    }

    # Get announcement banner configuration
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/announcementBanner(map<string|string[]> headers = {}) returns AnnouncementBannerConfiguration|error {
        string resourcePath = string `/api/3/announcementBanner`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update announcement banner configuration
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/announcementBanner(AnnouncementBannerConfigurationUpdate payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/announcementBanner`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Bulk get custom field configurations
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/app/'field/context/configuration/list(ConfigurationsListParameters payload, map<string|string[]> headers = {}, *GetCustomFieldsConfigurationsQueries queries) returns PageBeanBulkContextualConfiguration|error {
        string resourcePath = string `/api/3/app/field/context/configuration/list`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}, "fieldContextId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Update custom fields
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/app/'field/value(MultipleCustomFieldValuesUpdateDetails payload, map<string|string[]> headers = {}, *UpdateMultipleCustomFieldValuesQueries queries) returns json|error {
        string resourcePath = string `/api/3/app/field/value`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get custom field configurations
    #
    # + fieldIdOrKey - The ID or key of the custom field, for example `customfield_10000`
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/app/'field/[string fieldIdOrKey]/context/configuration(map<string|string[]> headers = {}, *GetCustomFieldConfigurationQueries queries) returns PageBeanContextualConfiguration|error {
        string resourcePath = string `/api/3/app/field/${getEncodedUri(fieldIdOrKey)}/context/configuration`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}, "fieldContextId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update custom field configurations
    #
    # + fieldIdOrKey - The ID or key of the custom field, for example `customfield_10000`
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/app/'field/[string fieldIdOrKey]/context/configuration(CustomFieldConfigurations payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/app/field/${getEncodedUri(fieldIdOrKey)}/context/configuration`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Update custom field value
    #
    # + fieldIdOrKey - The ID or key of the custom field. For example, `customfield_10010`
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/app/'field/[string fieldIdOrKey]/value(CustomFieldValueUpdateDetails payload, map<string|string[]> headers = {}, *UpdateCustomFieldValueQueries queries) returns json|error {
        string resourcePath = string `/api/3/app/field/${getEncodedUri(fieldIdOrKey)}/value`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get application property
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/application\-properties(map<string|string[]> headers = {}, *GetApplicationPropertyQueries queries) returns ApplicationProperty[]|error {
        string resourcePath = string `/api/3/application-properties`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get advanced settings
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/application\-properties/advanced\-settings(map<string|string[]> headers = {}) returns ApplicationProperty[]|error {
        string resourcePath = string `/api/3/application-properties/advanced-settings`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set application property
    #
    # + id - The key of the application property to update
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/application\-properties/[string id](SimpleApplicationPropertyBean payload, map<string|string[]> headers = {}) returns ApplicationProperty|error {
        string resourcePath = string `/api/3/application-properties/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get all application roles
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/applicationrole(map<string|string[]> headers = {}) returns ApplicationRole[]|error {
        string resourcePath = string `/api/3/applicationrole`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get application role
    #
    # + 'key - The key of the application role. Use the [Get all application roles](#api-rest-api-3-applicationrole-get) operation to get the key for each application role
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/applicationrole/[string 'key](map<string|string[]> headers = {}) returns ApplicationRole|error {
        string resourcePath = string `/api/3/applicationrole/${getEncodedUri('key)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get attachment content
    #
    # + id - The ID of the attachment
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful when `redirect` is set to `false` 
    resource isolated function get api/'3/attachment/content/[string id](map<string|string[]> headers = {}, *GetAttachmentContentQueries queries) returns anydata[]|error? {
        string resourcePath = string `/api/3/attachment/content/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get Jira attachment settings
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/attachment/meta(map<string|string[]> headers = {}) returns AttachmentSettings|error {
        string resourcePath = string `/api/3/attachment/meta`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get attachment thumbnail
    #
    # + id - The ID of the attachment
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful when `redirect` is set to `false` 
    resource isolated function get api/'3/attachment/thumbnail/[string id](map<string|string[]> headers = {}, *GetAttachmentThumbnailQueries queries) returns anydata[]|error? {
        string resourcePath = string `/api/3/attachment/thumbnail/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get attachment metadata
    #
    # + id - The ID of the attachment
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/attachment/[string id](map<string|string[]> headers = {}) returns AttachmentMetadata|error {
        string resourcePath = string `/api/3/attachment/${getEncodedUri(id)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete attachment
    #
    # + id - The ID of the attachment
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/attachment/[string id](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/attachment/${getEncodedUri(id)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get all metadata for an expanded attachment
    #
    # + id - The ID of the attachment
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful. If an empty list is returned in the response, the attachment is empty, corrupt, or not an archive 
    resource isolated function get api/'3/attachment/[string id]/expand/human(map<string|string[]> headers = {}) returns AttachmentArchiveMetadataReadable|error {
        string resourcePath = string `/api/3/attachment/${getEncodedUri(id)}/expand/human`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get contents metadata for an expanded attachment
    #
    # + id - The ID of the attachment
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful. If an empty list is returned in the response, the attachment is empty, corrupt, or not an archive 
    resource isolated function get api/'3/attachment/[string id]/expand/raw(map<string|string[]> headers = {}) returns AttachmentArchiveImpl|error {
        string resourcePath = string `/api/3/attachment/${getEncodedUri(id)}/expand/raw`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get audit records
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/auditing/'record(map<string|string[]> headers = {}, *GetAuditRecordsQueries queries) returns AuditRecords|error {
        string resourcePath = string `/api/3/auditing/record`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get system avatars by type
    #
    # + 'type - The avatar type
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/avatar/["issuetype"|"project"|"user"|"priority" 'type]/system(map<string|string[]> headers = {}) returns SystemAvatars|error {
        string resourcePath = string `/api/3/avatar/${getEncodedUri('type)}/system`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get bulk editable fields
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/bulk/issues/fields(map<string|string[]> headers = {}, *GetBulkEditableFieldsQueries queries) returns BulkEditGetFields|error {
        string resourcePath = string `/api/3/bulk/issues/fields`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Bulk edit issues
    #
    # + headers - Headers to be sent with the request 
    # + payload - The request body containing the issues to be edited and the new field values 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/bulk/issues/fields(IssueBulkEditPayload payload, map<string|string[]> headers = {}) returns SubmittedBulkOperation|error {
        string resourcePath = string `/api/3/bulk/issues/fields`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Bulk move issues
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/bulk/issues/move(IssueBulkMovePayload payload, map<string|string[]> headers = {}) returns SubmittedBulkOperation|error {
        string resourcePath = string `/api/3/bulk/issues/move`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get bulk issue operation progress
    #
    # + taskId - The ID of the task
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/bulk/queue/[string taskId](map<string|string[]> headers = {}) returns BulkOperationProgress|error {
        string resourcePath = string `/api/3/bulk/queue/${getEncodedUri(taskId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get all classification levels
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/classification\-levels(map<string|string[]> headers = {}, *GetAllUserDataClassificationLevelsQueries queries) returns DataClassificationLevelsBean|error {
        string resourcePath = string `/api/3/classification-levels`;
        map<Encoding> queryParamEncoding = {"status": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get comments by IDs
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The list of comment IDs 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/comment/list(IssueCommentListRequestBean payload, map<string|string[]> headers = {}, *GetCommentsByIdsQueries queries) returns PageBeanComment|error {
        string resourcePath = string `/api/3/comment/list`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get comment property keys
    #
    # + commentId - The ID of the comment
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/comment/[string commentId]/properties(map<string|string[]> headers = {}) returns PropertyKeys|error {
        string resourcePath = string `/api/3/comment/${getEncodedUri(commentId)}/properties`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get comment property
    #
    # + commentId - The ID of the comment
    # + propertyKey - The key of the property
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/comment/[string commentId]/properties/[string propertyKey](map<string|string[]> headers = {}) returns EntityProperty|error {
        string resourcePath = string `/api/3/comment/${getEncodedUri(commentId)}/properties/${getEncodedUri(propertyKey)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set comment property
    #
    # + commentId - The ID of the comment
    # + propertyKey - The key of the property. The maximum length is 255 characters
    # + headers - Headers to be sent with the request 
    # + payload - The value of the property. The value has to be a valid, non-empty [JSON](https://tools.ietf.org/html/rfc4627) value. The maximum length of the property value is 32768 bytes 
    # + return - Returned if the comment property is updated 
    resource isolated function put api/'3/comment/[string commentId]/properties/[string propertyKey](json payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/comment/${getEncodedUri(commentId)}/properties/${getEncodedUri(propertyKey)}`;
        http:Request request = new;
        request.setPayload(payload, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete comment property
    #
    # + commentId - The ID of the comment
    # + propertyKey - The key of the property
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/comment/[string commentId]/properties/[string propertyKey](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/comment/${getEncodedUri(commentId)}/properties/${getEncodedUri(propertyKey)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Find components for projects
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/component(map<string|string[]> headers = {}, *FindComponentsForProjectsQueries queries) returns PageBean2ComponentJsonBean|error {
        string resourcePath = string `/api/3/component`;
        map<Encoding> queryParamEncoding = {"projectIdsOrKeys": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create component
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/component(ProjectComponent payload, map<string|string[]> headers = {}) returns ProjectComponent|error {
        string resourcePath = string `/api/3/component`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get component
    #
    # + id - The ID of the component
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/component/[string id](map<string|string[]> headers = {}) returns ProjectComponent|error {
        string resourcePath = string `/api/3/component/${getEncodedUri(id)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update component
    #
    # + id - The ID of the component
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/component/[string id](ProjectComponent payload, map<string|string[]> headers = {}) returns ProjectComponent|error {
        string resourcePath = string `/api/3/component/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete component
    #
    # + id - The ID of the component
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/component/[string id](map<string|string[]> headers = {}, *DeleteComponentQueries queries) returns error? {
        string resourcePath = string `/api/3/component/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get component issues count
    #
    # + id - The ID of the component
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/component/[string id]/relatedIssueCounts(map<string|string[]> headers = {}) returns ComponentIssuesCount|error {
        string resourcePath = string `/api/3/component/${getEncodedUri(id)}/relatedIssueCounts`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get global settings
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/configuration(map<string|string[]> headers = {}) returns Configuration|error {
        string resourcePath = string `/api/3/configuration`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get selected time tracking provider
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful and time tracking is enabled 
    resource isolated function get api/'3/configuration/timetracking(map<string|string[]> headers = {}) returns TimeTrackingProvider|json|error {
        string resourcePath = string `/api/3/configuration/timetracking`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Select time tracking provider
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/configuration/timetracking(TimeTrackingProvider payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/configuration/timetracking`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get all time tracking providers
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/configuration/timetracking/list(map<string|string[]> headers = {}) returns TimeTrackingProvider[]|error {
        string resourcePath = string `/api/3/configuration/timetracking/list`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get time tracking settings
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/configuration/timetracking/options(map<string|string[]> headers = {}) returns TimeTrackingConfiguration|error {
        string resourcePath = string `/api/3/configuration/timetracking/options`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set time tracking settings
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/configuration/timetracking/options(TimeTrackingConfiguration payload, map<string|string[]> headers = {}) returns TimeTrackingConfiguration|error {
        string resourcePath = string `/api/3/configuration/timetracking/options`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get custom field option
    #
    # + id - The ID of the custom field option
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/customFieldOption/[string id](map<string|string[]> headers = {}) returns CustomFieldOption|error {
        string resourcePath = string `/api/3/customFieldOption/${getEncodedUri(id)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get all dashboards
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/dashboard(map<string|string[]> headers = {}, *GetAllDashboardsQueries queries) returns PageOfDashboards|error {
        string resourcePath = string `/api/3/dashboard`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create dashboard
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Dashboard details 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/dashboard(DashboardDetails payload, map<string|string[]> headers = {}, *CreateDashboardQueries queries) returns Dashboard|error {
        string resourcePath = string `/api/3/dashboard`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Bulk edit dashboards
    #
    # + headers - Headers to be sent with the request 
    # + payload - The details of dashboards being updated in bulk 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/dashboard/bulk/edit(BulkEditShareableEntityRequest payload, map<string|string[]> headers = {}) returns BulkEditShareableEntityResponse|error {
        string resourcePath = string `/api/3/dashboard/bulk/edit`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get available gadgets
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/dashboard/gadgets(map<string|string[]> headers = {}) returns AvailableDashboardGadgetsResponse|error {
        string resourcePath = string `/api/3/dashboard/gadgets`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Search for dashboards
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/dashboard/search(map<string|string[]> headers = {}, *GetDashboardsPaginatedQueries queries) returns PageBeanDashboard|error {
        string resourcePath = string `/api/3/dashboard/search`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get gadgets
    #
    # + dashboardId - The ID of the dashboard
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/dashboard/[int dashboardId]/gadget(map<string|string[]> headers = {}, *GetAllGadgetsQueries queries) returns DashboardGadgetResponse|error {
        string resourcePath = string `/api/3/dashboard/${getEncodedUri(dashboardId)}/gadget`;
        map<Encoding> queryParamEncoding = {"moduleKey": {style: FORM, explode: true}, "uri": {style: FORM, explode: true}, "gadgetId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add gadget to dashboard
    #
    # + dashboardId - The ID of the dashboard
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/dashboard/[int dashboardId]/gadget(DashboardGadgetSettings payload, map<string|string[]> headers = {}) returns DashboardGadget|error {
        string resourcePath = string `/api/3/dashboard/${getEncodedUri(dashboardId)}/gadget`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Update gadget on dashboard
    #
    # + dashboardId - The ID of the dashboard
    # + gadgetId - The ID of the gadget
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/dashboard/[int dashboardId]/gadget/[int gadgetId](DashboardGadgetUpdateRequest payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/dashboard/${getEncodedUri(dashboardId)}/gadget/${getEncodedUri(gadgetId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Remove gadget from dashboard
    #
    # + dashboardId - The ID of the dashboard
    # + gadgetId - The ID of the gadget
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/dashboard/[int dashboardId]/gadget/[int gadgetId](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/dashboard/${getEncodedUri(dashboardId)}/gadget/${getEncodedUri(gadgetId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get dashboard item property keys
    #
    # + dashboardId - The ID of the dashboard
    # + itemId - The ID of the dashboard item
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/dashboard/[string dashboardId]/items/[string itemId]/properties(map<string|string[]> headers = {}) returns PropertyKeys|error {
        string resourcePath = string `/api/3/dashboard/${getEncodedUri(dashboardId)}/items/${getEncodedUri(itemId)}/properties`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get dashboard item property
    #
    # + dashboardId - The ID of the dashboard
    # + itemId - The ID of the dashboard item
    # + propertyKey - The key of the dashboard item property
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/dashboard/[string dashboardId]/items/[string itemId]/properties/[string propertyKey](map<string|string[]> headers = {}) returns EntityProperty|error {
        string resourcePath = string `/api/3/dashboard/${getEncodedUri(dashboardId)}/items/${getEncodedUri(itemId)}/properties/${getEncodedUri(propertyKey)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set dashboard item property
    #
    # + dashboardId - The ID of the dashboard
    # + itemId - The ID of the dashboard item
    # + propertyKey - The key of the dashboard item property. The maximum length is 255 characters. For dashboard items with a spec URI and no complete module key, if the provided propertyKey is equal to "config", the request body's JSON must be an object with all keys and values as strings
    # + headers - Headers to be sent with the request 
    # + payload - The value of the property. The value has to be a valid, non-empty [JSON](https://tools.ietf.org/html/rfc4627) value. The maximum length of the property value is 32768 bytes 
    # + return - Returned if the dashboard item property is updated 
    resource isolated function put api/'3/dashboard/[string dashboardId]/items/[string itemId]/properties/[string propertyKey](json payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/dashboard/${getEncodedUri(dashboardId)}/items/${getEncodedUri(itemId)}/properties/${getEncodedUri(propertyKey)}`;
        http:Request request = new;
        request.setPayload(payload, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete dashboard item property
    #
    # + dashboardId - The ID of the dashboard
    # + itemId - The ID of the dashboard item
    # + propertyKey - The key of the dashboard item property
    # + headers - Headers to be sent with the request 
    # + return - Returned if the dashboard item property is deleted 
    resource isolated function delete api/'3/dashboard/[string dashboardId]/items/[string itemId]/properties/[string propertyKey](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/dashboard/${getEncodedUri(dashboardId)}/items/${getEncodedUri(itemId)}/properties/${getEncodedUri(propertyKey)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get dashboard
    #
    # + id - The ID of the dashboard
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/dashboard/[string id](map<string|string[]> headers = {}) returns Dashboard|error {
        string resourcePath = string `/api/3/dashboard/${getEncodedUri(id)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update dashboard
    #
    # + id - The ID of the dashboard to update
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Replacement dashboard details 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/dashboard/[string id](DashboardDetails payload, map<string|string[]> headers = {}, *UpdateDashboardQueries queries) returns Dashboard|error {
        string resourcePath = string `/api/3/dashboard/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete dashboard
    #
    # + id - The ID of the dashboard
    # + headers - Headers to be sent with the request 
    # + return - Returned if the dashboard is deleted 
    resource isolated function delete api/'3/dashboard/[string id](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/dashboard/${getEncodedUri(id)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Copy dashboard
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Dashboard details 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/dashboard/[string id]/copy(DashboardDetails payload, map<string|string[]> headers = {}, *CopyDashboardQueries queries) returns Dashboard|error {
        string resourcePath = string `/api/3/dashboard/${getEncodedUri(id)}/copy`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get data policy for the workspace
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/data\-policy(map<string|string[]> headers = {}) returns WorkspaceDataPolicy|error {
        string resourcePath = string `/api/3/data-policy`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get data policy for projects
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/data\-policy/project(map<string|string[]> headers = {}, *GetPoliciesQueries queries) returns ProjectDataPolicies|error {
        string resourcePath = string `/api/3/data-policy/project`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get events
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/events(map<string|string[]> headers = {}) returns IssueEvent[]|error {
        string resourcePath = string `/api/3/events`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Analyse Jira expression
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The Jira expressions to analyse 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/expression/analyse(JiraExpressionForAnalysis payload, map<string|string[]> headers = {}, *AnalyseExpressionQueries queries) returns JiraExpressionsAnalysis|error {
        string resourcePath = string `/api/3/expression/analyse`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Evaluate Jira expression
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The Jira expression and the evaluation context 
    # + return - Returned if the evaluation results in a value. The result is a JSON primitive value, list, or object 
    resource isolated function post api/'3/expression/eval(JiraExpressionEvalRequestBean payload, map<string|string[]> headers = {}, *EvaluateJiraExpressionQueries queries) returns JiraExpressionResult|error {
        string resourcePath = string `/api/3/expression/eval`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Evaluate Jira expression using enhanced search API
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The Jira expression and the evaluation context 
    # + return - Returned if the evaluation results in a value. The result is a JSON primitive value, list, or object 
    resource isolated function post api/'3/expression/evaluate(JiraExpressionEvaluateRequestBean payload, map<string|string[]> headers = {}, *EvaluateJSISJiraExpressionQueries queries) returns JExpEvaluateJiraExpressionResultBean|error {
        string resourcePath = string `/api/3/expression/evaluate`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get fields
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/'field(map<string|string[]> headers = {}) returns FieldDetails[]|error {
        string resourcePath = string `/api/3/field`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create custom field
    #
    # + headers - Headers to be sent with the request 
    # + payload - Definition of the custom field to be created 
    # + return - Returned if the custom field is created 
    resource isolated function post api/'3/'field(CustomFieldDefinitionJsonBean payload, map<string|string[]> headers = {}) returns FieldDetails|error {
        string resourcePath = string `/api/3/field`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get fields paginated
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/'field/search(map<string|string[]> headers = {}, *GetFieldsPaginatedQueries queries) returns PageBeanField|error {
        string resourcePath = string `/api/3/field/search`;
        map<Encoding> queryParamEncoding = {"type": {style: FORM, explode: true}, "id": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get fields in trash paginated
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/'field/search/trashed(map<string|string[]> headers = {}, *GetTrashedFieldsPaginatedQueries queries) returns PageBeanField|error {
        string resourcePath = string `/api/3/field/search/trashed`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update custom field
    #
    # + fieldId - The ID of the custom field
    # + headers - Headers to be sent with the request 
    # + payload - The custom field update details 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/'field/[string fieldId](UpdateCustomFieldDetails payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/field/${getEncodedUri(fieldId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get custom field contexts
    #
    # + fieldId - The ID of the custom field
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/'field/[string fieldId]/context(map<string|string[]> headers = {}, *GetContextsForFieldQueries queries) returns PageBeanCustomFieldContext|error {
        string resourcePath = string `/api/3/field/${getEncodedUri(fieldId)}/context`;
        map<Encoding> queryParamEncoding = {"contextId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create custom field context
    #
    # + fieldId - The ID of the custom field
    # + headers - Headers to be sent with the request 
    # + return - Returned if the custom field context is created 
    resource isolated function post api/'3/'field/[string fieldId]/context(CreateCustomFieldContext payload, map<string|string[]> headers = {}) returns CreateCustomFieldContext|error {
        string resourcePath = string `/api/3/field/${getEncodedUri(fieldId)}/context`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get custom field contexts default values
    #
    # + fieldId - The ID of the custom field, for example `customfield\_10000`
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/'field/[string fieldId]/context/defaultValue(map<string|string[]> headers = {}, *GetDefaultValuesQueries queries) returns PageBeanCustomFieldContextDefaultValue|error {
        string resourcePath = string `/api/3/field/${getEncodedUri(fieldId)}/context/defaultValue`;
        map<Encoding> queryParamEncoding = {"contextId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Set custom field contexts default values
    #
    # + fieldId - The ID of the custom field
    # + headers - Headers to be sent with the request 
    # + return - Returned if operation is successful 
    resource isolated function put api/'3/'field/[string fieldId]/context/defaultValue(CustomFieldContextDefaultValueUpdate payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/field/${getEncodedUri(fieldId)}/context/defaultValue`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get issue types for custom field context
    #
    # + fieldId - The ID of the custom field
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if operation is successful 
    resource isolated function get api/'3/'field/[string fieldId]/context/issuetypemapping(map<string|string[]> headers = {}, *GetIssueTypeMappingsForContextsQueries queries) returns PageBeanIssueTypeToContextMapping|error {
        string resourcePath = string `/api/3/field/${getEncodedUri(fieldId)}/context/issuetypemapping`;
        map<Encoding> queryParamEncoding = {"contextId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get custom field contexts for projects and issue types
    #
    # + fieldId - The ID of the custom field
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The list of project and issue type mappings 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/'field/[string fieldId]/context/mapping(ProjectIssueTypeMappings payload, map<string|string[]> headers = {}, *GetCustomFieldContextsForProjectsAndIssueTypesQueries queries) returns PageBeanContextForProjectAndIssueType|error {
        string resourcePath = string `/api/3/field/${getEncodedUri(fieldId)}/context/mapping`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get project mappings for custom field context
    #
    # + fieldId - The ID of the custom field, for example `customfield\_10000`
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/'field/[string fieldId]/context/projectmapping(map<string|string[]> headers = {}, *GetProjectContextMappingQueries queries) returns PageBeanCustomFieldContextProjectMapping|error {
        string resourcePath = string `/api/3/field/${getEncodedUri(fieldId)}/context/projectmapping`;
        map<Encoding> queryParamEncoding = {"contextId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update custom field context
    #
    # + fieldId - The ID of the custom field
    # + contextId - The ID of the context
    # + headers - Headers to be sent with the request 
    # + return - Returned if the context is updated 
    resource isolated function put api/'3/'field/[string fieldId]/context/[int contextId](CustomFieldContextUpdateDetails payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/field/${getEncodedUri(fieldId)}/context/${getEncodedUri(contextId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete custom field context
    #
    # + fieldId - The ID of the custom field
    # + contextId - The ID of the context
    # + headers - Headers to be sent with the request 
    # + return - Returned if the context is deleted 
    resource isolated function delete api/'3/'field/[string fieldId]/context/[int contextId](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/field/${getEncodedUri(fieldId)}/context/${getEncodedUri(contextId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Add issue types to context
    #
    # + fieldId - The ID of the custom field
    # + contextId - The ID of the context
    # + headers - Headers to be sent with the request 
    # + return - Returned if operation is successful 
    resource isolated function put api/'3/'field/[string fieldId]/context/[int contextId]/issuetype(IssueTypeIds payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/field/${getEncodedUri(fieldId)}/context/${getEncodedUri(contextId)}/issuetype`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Remove issue types from context
    #
    # + fieldId - The ID of the custom field
    # + contextId - The ID of the context
    # + headers - Headers to be sent with the request 
    # + return - Returned if operation is successful 
    resource isolated function post api/'3/'field/[string fieldId]/context/[int contextId]/issuetype/remove(IssueTypeIds payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/field/${getEncodedUri(fieldId)}/context/${getEncodedUri(contextId)}/issuetype/remove`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get custom field options (context)
    #
    # + fieldId - The ID of the custom field
    # + contextId - The ID of the context
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/'field/[string fieldId]/context/[int contextId]/option(map<string|string[]> headers = {}, *GetOptionsForContextQueries queries) returns PageBeanCustomFieldContextOption|error {
        string resourcePath = string `/api/3/field/${getEncodedUri(fieldId)}/context/${getEncodedUri(contextId)}/option`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update custom field options (context)
    #
    # + fieldId - The ID of the custom field
    # + contextId - The ID of the context
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/'field/[string fieldId]/context/[int contextId]/option(BulkCustomFieldOptionUpdateRequest payload, map<string|string[]> headers = {}) returns CustomFieldUpdatedContextOptionsList|error {
        string resourcePath = string `/api/3/field/${getEncodedUri(fieldId)}/context/${getEncodedUri(contextId)}/option`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Create custom field options (context)
    #
    # + fieldId - The ID of the custom field
    # + contextId - The ID of the context
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/'field/[string fieldId]/context/[int contextId]/option(BulkCustomFieldOptionCreateRequest payload, map<string|string[]> headers = {}) returns CustomFieldCreatedContextOptionsList|error {
        string resourcePath = string `/api/3/field/${getEncodedUri(fieldId)}/context/${getEncodedUri(contextId)}/option`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Reorder custom field options (context)
    #
    # + fieldId - The ID of the custom field
    # + contextId - The ID of the context
    # + headers - Headers to be sent with the request 
    # + return - Returned if options are reordered 
    resource isolated function put api/'3/'field/[string fieldId]/context/[int contextId]/option/move(OrderOfCustomFieldOptions payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/field/${getEncodedUri(fieldId)}/context/${getEncodedUri(contextId)}/option/move`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete custom field options (context)
    #
    # + fieldId - The ID of the custom field
    # + contextId - The ID of the context from which an option should be deleted
    # + optionId - The ID of the option to delete
    # + headers - Headers to be sent with the request 
    # + return - Returned if the option is deleted 
    resource isolated function delete api/'3/'field/[string fieldId]/context/[int contextId]/option/[int optionId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/field/${getEncodedUri(fieldId)}/context/${getEncodedUri(contextId)}/option/${getEncodedUri(optionId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Replace custom field options
    #
    # + fieldId - The ID of the custom field
    # + optionId - The ID of the option to be deselected
    # + contextId - The ID of the context
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the long-running task to deselect the option is started 
    resource isolated function delete api/'3/'field/[string fieldId]/context/[int contextId]/option/[int optionId]/issue(map<string|string[]> headers = {}, *ReplaceCustomFieldOptionQueries queries) returns http:Response|error {
        string resourcePath = string `/api/3/field/${getEncodedUri(fieldId)}/context/${getEncodedUri(contextId)}/option/${getEncodedUri(optionId)}/issue`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Assign custom field context to projects
    #
    # + fieldId - The ID of the custom field
    # + contextId - The ID of the context
    # + headers - Headers to be sent with the request 
    # + return - Returned if operation is successful 
    resource isolated function put api/'3/'field/[string fieldId]/context/[int contextId]/project(ProjectIds payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/field/${getEncodedUri(fieldId)}/context/${getEncodedUri(contextId)}/project`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Remove custom field context from projects
    #
    # + fieldId - The ID of the custom field
    # + contextId - The ID of the context
    # + headers - Headers to be sent with the request 
    # + return - Returned if the custom field context is removed from the projects 
    resource isolated function post api/'3/'field/[string fieldId]/context/[int contextId]/project/remove(ProjectIds payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/field/${getEncodedUri(fieldId)}/context/${getEncodedUri(contextId)}/project/remove`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get screens for a field
    #
    # + fieldId - The ID of the field to return screens for
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/'field/[string fieldId]/screens(map<string|string[]> headers = {}, *GetScreensForFieldQueries queries) returns PageBeanScreenWithTab|error {
        string resourcePath = string `/api/3/field/${getEncodedUri(fieldId)}/screens`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get all issue field options
    #
    # + fieldKey - The field key is specified in the following format: **$(app-key)\_\_$(field-key)**. For example, *example-add-on\_\_example-issue-field*. To determine the `fieldKey` value, do one of the following:
    # *  open the app's plugin descriptor, then **app-key** is the key at the top and **field-key** is the key in the `jiraIssueFields` module. **app-key** can also be found in the app listing in the Atlassian Universal Plugin Manager.
    # *  run [Get fields](#api-rest-api-3-field-get) and in the field details the value is returned in `key`. For example, `"key": "teams-add-on__team-issue-field"`
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/'field/[string fieldKey]/option(map<string|string[]> headers = {}, *GetAllIssueFieldOptionsQueries queries) returns PageBeanIssueFieldOption|error {
        string resourcePath = string `/api/3/field/${getEncodedUri(fieldKey)}/option`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create issue field option
    #
    # + fieldKey - The field key is specified in the following format: **$(app-key)\_\_$(field-key)**. For example, *example-add-on\_\_example-issue-field*. To determine the `fieldKey` value, do one of the following:
    # *  open the app's plugin descriptor, then **app-key** is the key at the top and **field-key** is the key in the `jiraIssueFields` module. **app-key** can also be found in the app listing in the Atlassian Universal Plugin Manager.
    # *  run [Get fields](#api-rest-api-3-field-get) and in the field details the value is returned in `key`. For example, `"key": "teams-add-on__team-issue-field"`
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/'field/[string fieldKey]/option(IssueFieldOptionCreateBean payload, map<string|string[]> headers = {}) returns IssueFieldOption|error {
        string resourcePath = string `/api/3/field/${getEncodedUri(fieldKey)}/option`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get selectable issue field options
    #
    # + fieldKey - The field key is specified in the following format: **$(app-key)\_\_$(field-key)**. For example, *example-add-on\_\_example-issue-field*. To determine the `fieldKey` value, do one of the following:
    # *  open the app's plugin descriptor, then **app-key** is the key at the top and **field-key** is the key in the `jiraIssueFields` module. **app-key** can also be found in the app listing in the Atlassian Universal Plugin Manager.
    # *  run [Get fields](#api-rest-api-3-field-get) and in the field details the value is returned in `key`. For example, `"key": "teams-add-on__team-issue-field"`
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/'field/[string fieldKey]/option/suggestions/edit(map<string|string[]> headers = {}, *GetSelectableIssueFieldOptionsQueries queries) returns PageBeanIssueFieldOption|error {
        string resourcePath = string `/api/3/field/${getEncodedUri(fieldKey)}/option/suggestions/edit`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get visible issue field options
    #
    # + fieldKey - The field key is specified in the following format: **$(app-key)\_\_$(field-key)**. For example, *example-add-on\_\_example-issue-field*. To determine the `fieldKey` value, do one of the following:
    # *  open the app's plugin descriptor, then **app-key** is the key at the top and **field-key** is the key in the `jiraIssueFields` module. **app-key** can also be found in the app listing in the Atlassian Universal Plugin Manager.
    # *  run [Get fields](#api-rest-api-3-field-get) and in the field details the value is returned in `key`. For example, `"key": "teams-add-on__team-issue-field"`
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/'field/[string fieldKey]/option/suggestions/search(map<string|string[]> headers = {}, *GetVisibleIssueFieldOptionsQueries queries) returns PageBeanIssueFieldOption|error {
        string resourcePath = string `/api/3/field/${getEncodedUri(fieldKey)}/option/suggestions/search`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get issue field option
    #
    # + fieldKey - The field key is specified in the following format: **$(app-key)\_\_$(field-key)**. For example, *example-add-on\_\_example-issue-field*. To determine the `fieldKey` value, do one of the following:
    # *  open the app's plugin descriptor, then **app-key** is the key at the top and **field-key** is the key in the `jiraIssueFields` module. **app-key** can also be found in the app listing in the Atlassian Universal Plugin Manager.
    # *  run [Get fields](#api-rest-api-3-field-get) and in the field details the value is returned in `key`. For example, `"key": "teams-add-on__team-issue-field"`
    # + optionId - The ID of the option to be returned
    # + headers - Headers to be sent with the request 
    # + return - Returned if the requested option is returned 
    resource isolated function get api/'3/'field/[string fieldKey]/option/[int optionId](map<string|string[]> headers = {}) returns IssueFieldOption|error {
        string resourcePath = string `/api/3/field/${getEncodedUri(fieldKey)}/option/${getEncodedUri(optionId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update issue field option
    #
    # + fieldKey - The field key is specified in the following format: **$(app-key)\_\_$(field-key)**. For example, *example-add-on\_\_example-issue-field*. To determine the `fieldKey` value, do one of the following:
    # *  open the app's plugin descriptor, then **app-key** is the key at the top and **field-key** is the key in the `jiraIssueFields` module. **app-key** can also be found in the app listing in the Atlassian Universal Plugin Manager.
    # *  run [Get fields](#api-rest-api-3-field-get) and in the field details the value is returned in `key`. For example, `"key": "teams-add-on__team-issue-field"`
    # + optionId - The ID of the option to be updated
    # + headers - Headers to be sent with the request 
    # + return - Returned if the option is updated or created 
    resource isolated function put api/'3/'field/[string fieldKey]/option/[int optionId](IssueFieldOption payload, map<string|string[]> headers = {}) returns IssueFieldOption|error {
        string resourcePath = string `/api/3/field/${getEncodedUri(fieldKey)}/option/${getEncodedUri(optionId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete issue field option
    #
    # + fieldKey - The field key is specified in the following format: **$(app-key)\_\_$(field-key)**. For example, *example-add-on\_\_example-issue-field*. To determine the `fieldKey` value, do one of the following:
    # *  open the app's plugin descriptor, then **app-key** is the key at the top and **field-key** is the key in the `jiraIssueFields` module. **app-key** can also be found in the app listing in the Atlassian Universal Plugin Manager.
    # *  run [Get fields](#api-rest-api-3-field-get) and in the field details the value is returned in `key`. For example, `"key": "teams-add-on__team-issue-field"`
    # + optionId - The ID of the option to be deleted
    # + headers - Headers to be sent with the request 
    # + return - Returned if the field option is deleted 
    resource isolated function delete api/'3/'field/[string fieldKey]/option/[int optionId](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/field/${getEncodedUri(fieldKey)}/option/${getEncodedUri(optionId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Replace issue field option
    #
    # + fieldKey - The field key is specified in the following format: **$(app-key)\_\_$(field-key)**. For example, *example-add-on\_\_example-issue-field*. To determine the `fieldKey` value, do one of the following:
    # *  open the app's plugin descriptor, then **app-key** is the key at the top and **field-key** is the key in the `jiraIssueFields` module. **app-key** can also be found in the app listing in the Atlassian Universal Plugin Manager.
    # *  run [Get fields](#api-rest-api-3-field-get) and in the field details the value is returned in `key`. For example, `"key": "teams-add-on__team-issue-field"`
    # + optionId - The ID of the option to be deselected
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the long-running task to deselect the option is started 
    resource isolated function delete api/'3/'field/[string fieldKey]/option/[int optionId]/issue(map<string|string[]> headers = {}, *ReplaceIssueFieldOptionQueries queries) returns http:Response|error {
        string resourcePath = string `/api/3/field/${getEncodedUri(fieldKey)}/option/${getEncodedUri(optionId)}/issue`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Delete custom field
    #
    # + id - The ID of a custom field
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/'field/[string id](map<string|string[]> headers = {}) returns http:Response|error {
        string resourcePath = string `/api/3/field/${getEncodedUri(id)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    resource isolated function post api/'3/'field/[string id](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/field/${getEncodedUri(id)}ore`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Move custom field to trash
    #
    # + id - The ID of a custom field
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/'field/[string id]/trash(map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/field/${getEncodedUri(id)}/trash`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get all field configurations
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/fieldconfiguration(map<string|string[]> headers = {}, *GetAllFieldConfigurationsQueries queries) returns PageBeanFieldConfigurationDetails|error {
        string resourcePath = string `/api/3/fieldconfiguration`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create field configuration
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/fieldconfiguration(FieldConfigurationDetails payload, map<string|string[]> headers = {}) returns FieldConfiguration|error {
        string resourcePath = string `/api/3/fieldconfiguration`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Update field configuration
    #
    # + id - The ID of the field configuration
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/fieldconfiguration/[int id](FieldConfigurationDetails payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/fieldconfiguration/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete field configuration
    #
    # + id - The ID of the field configuration
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/fieldconfiguration/[int id](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/fieldconfiguration/${getEncodedUri(id)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get field configuration items
    #
    # + id - The ID of the field configuration
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/fieldconfiguration/[int id]/fields(map<string|string[]> headers = {}, *GetFieldConfigurationItemsQueries queries) returns PageBeanFieldConfigurationItem|error {
        string resourcePath = string `/api/3/fieldconfiguration/${getEncodedUri(id)}/fields`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update field configuration items
    #
    # + id - The ID of the field configuration
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/fieldconfiguration/[int id]/fields(FieldConfigurationItemsDetails payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/fieldconfiguration/${getEncodedUri(id)}/fields`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get all field configuration schemes
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/fieldconfigurationscheme(map<string|string[]> headers = {}, *GetAllFieldConfigurationSchemesQueries queries) returns PageBeanFieldConfigurationScheme|error {
        string resourcePath = string `/api/3/fieldconfigurationscheme`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create field configuration scheme
    #
    # + headers - Headers to be sent with the request 
    # + payload - The details of the field configuration scheme 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/fieldconfigurationscheme(UpdateFieldConfigurationSchemeDetails payload, map<string|string[]> headers = {}) returns FieldConfigurationScheme|error {
        string resourcePath = string `/api/3/fieldconfigurationscheme`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get field configuration issue type items
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/fieldconfigurationscheme/mapping(map<string|string[]> headers = {}, *GetFieldConfigurationSchemeMappingsQueries queries) returns PageBeanFieldConfigurationIssueTypeItem|error {
        string resourcePath = string `/api/3/fieldconfigurationscheme/mapping`;
        map<Encoding> queryParamEncoding = {"fieldConfigurationSchemeId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get field configuration schemes for projects
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/fieldconfigurationscheme/project(map<string|string[]> headers = {}, *GetFieldConfigurationSchemeProjectMappingQueries queries) returns PageBeanFieldConfigurationSchemeProjects|error {
        string resourcePath = string `/api/3/fieldconfigurationscheme/project`;
        map<Encoding> queryParamEncoding = {"projectId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Assign field configuration scheme to project
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/fieldconfigurationscheme/project(FieldConfigurationSchemeProjectAssociation payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/fieldconfigurationscheme/project`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Update field configuration scheme
    #
    # + id - The ID of the field configuration scheme
    # + headers - Headers to be sent with the request 
    # + payload - The details of the field configuration scheme 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/fieldconfigurationscheme/[int id](UpdateFieldConfigurationSchemeDetails payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/fieldconfigurationscheme/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete field configuration scheme
    #
    # + id - The ID of the field configuration scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/fieldconfigurationscheme/[int id](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/fieldconfigurationscheme/${getEncodedUri(id)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Assign issue types to field configurations
    #
    # + id - The ID of the field configuration scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/fieldconfigurationscheme/[int id]/mapping(AssociateFieldConfigurationsWithIssueTypesRequest payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/fieldconfigurationscheme/${getEncodedUri(id)}/mapping`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Remove issue types from field configuration scheme
    #
    # + id - The ID of the field configuration scheme
    # + headers - Headers to be sent with the request 
    # + payload - The issue type IDs to remove 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/fieldconfigurationscheme/[int id]/mapping/delete(IssueTypeIdsToRemove payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/fieldconfigurationscheme/${getEncodedUri(id)}/mapping/delete`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Create filter
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The filter to create 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/filter(Filter payload, map<string|string[]> headers = {}, *CreateFilterQueries queries) returns Filter|error {
        string resourcePath = string `/api/3/filter`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get default share scope
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/filter/defaultShareScope(map<string|string[]> headers = {}) returns DefaultShareScope|error {
        string resourcePath = string `/api/3/filter/defaultShareScope`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set default share scope
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/filter/defaultShareScope(DefaultShareScope payload, map<string|string[]> headers = {}) returns DefaultShareScope|error {
        string resourcePath = string `/api/3/filter/defaultShareScope`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get favorite filters
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/filter/favourite(map<string|string[]> headers = {}, *GetFavouriteFiltersQueries queries) returns Filter[]|error {
        string resourcePath = string `/api/3/filter/favourite`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get my filters
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/filter/my(map<string|string[]> headers = {}, *GetMyFiltersQueries queries) returns Filter[]|error {
        string resourcePath = string `/api/3/filter/my`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Search for filters
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/filter/search(map<string|string[]> headers = {}, *GetFiltersPaginatedQueries queries) returns PageBeanFilterDetails|error {
        string resourcePath = string `/api/3/filter/search`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get filter
    #
    # + id - The ID of the filter to return
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/filter/[int id](map<string|string[]> headers = {}, *GetFilterQueries queries) returns Filter|error {
        string resourcePath = string `/api/3/filter/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update filter
    #
    # + id - The ID of the filter to update
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The filter to update 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/filter/[int id](Filter payload, map<string|string[]> headers = {}, *UpdateFilterQueries queries) returns Filter|error {
        string resourcePath = string `/api/3/filter/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete filter
    #
    # + id - The ID of the filter to delete
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/filter/[int id](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/filter/${getEncodedUri(id)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get columns
    #
    # + id - The ID of the filter
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/filter/[int id]/columns(map<string|string[]> headers = {}) returns ColumnItem[]|error {
        string resourcePath = string `/api/3/filter/${getEncodedUri(id)}/columns`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set columns
    #
    # + id - The ID of the filter
    # + headers - Headers to be sent with the request 
    # + request - The IDs of the fields to set as columns. In the form data, specify each field as `columns=id`, where `id` is the *id* of a field (as seen in the response for [Get fields](#api-rest-api-<ver>-field-get)). For example, `columns=summary` 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/filter/[int id]/columns(http:Request request, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/filter/${getEncodedUri(id)}/columns`;
        // TODO: Update the request as needed;
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Reset columns
    #
    # + id - The ID of the filter
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/filter/[int id]/columns(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/filter/${getEncodedUri(id)}/columns`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Add filter as favorite
    #
    # + id - The ID of the filter
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/filter/[int id]/favourite(map<string|string[]> headers = {}, *SetFavouriteForFilterQueries queries) returns Filter|error {
        string resourcePath = string `/api/3/filter/${getEncodedUri(id)}/favourite`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Remove filter as favorite
    #
    # + id - The ID of the filter
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/filter/[int id]/favourite(map<string|string[]> headers = {}, *DeleteFavouriteForFilterQueries queries) returns Filter|error {
        string resourcePath = string `/api/3/filter/${getEncodedUri(id)}/favourite`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Change filter owner
    #
    # + id - The ID of the filter to update
    # + headers - Headers to be sent with the request 
    # + payload - The account ID of the new owner of the filter 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/filter/[int id]/owner(ChangeFilterOwner payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/filter/${getEncodedUri(id)}/owner`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get share permissions
    #
    # + id - The ID of the filter
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/filter/[int id]/permission(map<string|string[]> headers = {}) returns SharePermission[]|error {
        string resourcePath = string `/api/3/filter/${getEncodedUri(id)}/permission`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Add share permission
    #
    # + id - The ID of the filter
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/filter/[int id]/permission(SharePermissionInputBean payload, map<string|string[]> headers = {}) returns SharePermission[]|error {
        string resourcePath = string `/api/3/filter/${getEncodedUri(id)}/permission`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get share permission
    #
    # + id - The ID of the filter
    # + permissionId - The ID of the share permission
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/filter/[int id]/permission/[int permissionId](map<string|string[]> headers = {}) returns SharePermission|error {
        string resourcePath = string `/api/3/filter/${getEncodedUri(id)}/permission/${getEncodedUri(permissionId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete share permission
    #
    # + id - The ID of the filter
    # + permissionId - The ID of the share permission
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/filter/[int id]/permission/[int permissionId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/filter/${getEncodedUri(id)}/permission/${getEncodedUri(permissionId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Create group
    #
    # + headers - Headers to be sent with the request 
    # + payload - The name of the group 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/group(AddGroupBean payload, map<string|string[]> headers = {}) returns Group|error {
        string resourcePath = string `/api/3/group`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Remove group
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/group(map<string|string[]> headers = {}, *RemoveGroupQueries queries) returns error? {
        string resourcePath = string `/api/3/group`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Bulk get groups
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/group/bulk(map<string|string[]> headers = {}, *BulkGetGroupsQueries queries) returns PageBeanGroupDetails|error {
        string resourcePath = string `/api/3/group/bulk`;
        map<Encoding> queryParamEncoding = {"groupId": {style: FORM, explode: true}, "groupName": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get users from group
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/group/member(map<string|string[]> headers = {}, *GetUsersFromGroupQueries queries) returns PageBeanUserDetails|error {
        string resourcePath = string `/api/3/group/member`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add user to group
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The user to add to the group 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/group/user(UpdateUserToGroupBean payload, map<string|string[]> headers = {}, *AddUserToGroupQueries queries) returns Group|error {
        string resourcePath = string `/api/3/group/user`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Remove user from group
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/group/user(map<string|string[]> headers = {}, *RemoveUserFromGroupQueries queries) returns error? {
        string resourcePath = string `/api/3/group/user`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Find groups
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/groups/picker(map<string|string[]> headers = {}, *FindGroupsQueries queries) returns FoundGroups|error {
        string resourcePath = string `/api/3/groups/picker`;
        map<Encoding> queryParamEncoding = {"exclude": {style: FORM, explode: true}, "excludeId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Find users and groups
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/groupuserpicker(map<string|string[]> headers = {}, *FindUsersAndGroupsQueries queries) returns FoundUsersAndGroups|error {
        string resourcePath = string `/api/3/groupuserpicker`;
        map<Encoding> queryParamEncoding = {"projectId": {style: FORM, explode: true}, "issueTypeId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get license
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/instance/license(map<string|string[]> headers = {}) returns License|error {
        string resourcePath = string `/api/3/instance/license`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create issue
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/issue(IssueUpdateDetails payload, map<string|string[]> headers = {}, *CreateIssueQueries queries) returns CreatedIssue|error {
        string resourcePath = string `/api/3/issue`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Archive issue(s) by issue ID/key
    #
    # + headers - Headers to be sent with the request 
    # + payload - Contains a list of issue keys or IDs to be archived 
    # + return - Returned if there is at least one valid issue to archive in the request. The return message will include the count of archived issues and subtasks, as well as error details for issues which failed to get archived 
    resource isolated function put api/'3/issue/archive(IssueArchivalSyncRequest payload, map<string|string[]> headers = {}) returns IssueArchivalSyncResponse|error {
        string resourcePath = string `/api/3/issue/archive`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Archive issue(s) by JQL
    #
    # + headers - Headers to be sent with the request 
    # + payload - A JQL query specifying the issues to archive. Note that subtasks can only be archived through their parent issues 
    # + return - Returns the URL to check the status of the submitted request 
    resource isolated function post api/'3/issue/archive(ArchiveIssueAsyncRequest payload, map<string|string[]> headers = {}) returns string|error {
        string resourcePath = string `/api/3/issue/archive`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Bulk create issue
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if any of the issue or subtask creation requests were successful. A request may be unsuccessful when it:  *  is missing required fields.  *  contains invalid field values.  *  contains fields that cannot be set for the issue type.  *  is by a user who does not have the necessary permission.  *  is to create a subtype in a project different that of the parent issue.  *  is for a subtask when the option to create subtasks is disabled.  *  is invalid for any other reason 
    resource isolated function post api/'3/issue/bulk(IssuesUpdateBean payload, map<string|string[]> headers = {}) returns CreatedIssues|error {
        string resourcePath = string `/api/3/issue/bulk`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Bulk fetch issues
    #
    # + headers - Headers to be sent with the request 
    # + payload - A JSON object containing the information about which issues and fields to fetch 
    # + return - Returned if the request is successful. A response may contain both successful issues and issue errors 
    resource isolated function post api/'3/issue/bulkfetch(BulkFetchIssueRequestBean payload, map<string|string[]> headers = {}) returns BulkIssueResults|error {
        string resourcePath = string `/api/3/issue/bulkfetch`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get create metadata issue types for a project
    #
    # + projectIdOrKey - The ID or key of the project
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issue/createmeta/[string projectIdOrKey]/issuetypes(map<string|string[]> headers = {}, *GetCreateIssueMetaIssueTypesQueries queries) returns PageOfCreateMetaIssueTypes|error {
        string resourcePath = string `/api/3/issue/createmeta/${getEncodedUri(projectIdOrKey)}/issuetypes`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get create field metadata for a project and issue type id
    #
    # + projectIdOrKey - The ID or key of the project
    # + issueTypeId - The issuetype ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issue/createmeta/[string projectIdOrKey]/issuetypes/[string issueTypeId](map<string|string[]> headers = {}, *GetCreateIssueMetaIssueTypeIdQueries queries) returns PageOfCreateMetaIssueTypeWithField|error {
        string resourcePath = string `/api/3/issue/createmeta/${getEncodedUri(projectIdOrKey)}/issuetypes/${getEncodedUri(issueTypeId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get issue limit report
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issue/'limit/report(map<string|string[]> headers = {}, *GetIssueLimitReportQueries queries) returns IssueLimitReportResponseBean|error {
        string resourcePath = string `/api/3/issue/limit/report`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get issue picker suggestions
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issue/picker(map<string|string[]> headers = {}, *GetIssuePickerResourceQueries queries) returns IssuePickerSuggestions|error {
        string resourcePath = string `/api/3/issue/picker`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Bulk set issues properties by list
    #
    # + headers - Headers to be sent with the request 
    # + payload - Issue properties to be set or updated with values 
    # + return - Returned if the operation is successful 
    resource isolated function post api/'3/issue/properties(IssueEntityProperties payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/issue/properties`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Bulk set issue properties by issue
    #
    # + headers - Headers to be sent with the request 
    # + payload - Details of the issue properties to be set or updated. Note that if an issue is not found, it is ignored 
    # + return - Returned if the operation is successful 
    resource isolated function post api/'3/issue/properties/multi(MultiIssueEntityProperties payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/issue/properties/multi`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Bulk set issue property
    #
    # + propertyKey - The key of the property. The maximum length is 255 characters
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/issue/properties/[string propertyKey](BulkIssuePropertyUpdateRequest payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/issue/properties/${getEncodedUri(propertyKey)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Bulk delete issue property
    #
    # + propertyKey - The key of the property
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/issue/properties/[string propertyKey](IssueFilterForBulkPropertyDelete payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/issue/properties/${getEncodedUri(propertyKey)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->delete(resourcePath, request, headers);
    }

    # Unarchive issue(s) by issue keys/ID
    #
    # + headers - Headers to be sent with the request 
    # + payload - Contains a list of issue keys or IDs to be unarchived 
    # + return - Returned if there is at least one valid issue to unarchive in the request. It will return the count of unarchived issues, which also includes the count of the subtasks unarchived, and it will show the detailed errors for those issues which are not unarchived 
    resource isolated function put api/'3/issue/unarchive(IssueArchivalSyncRequest payload, map<string|string[]> headers = {}) returns IssueArchivalSyncResponse|error {
        string resourcePath = string `/api/3/issue/unarchive`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get is watching issue bulk
    #
    # + headers - Headers to be sent with the request 
    # + payload - A list of issue IDs 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/issue/watching(IssueList payload, map<string|string[]> headers = {}) returns BulkIssueIsWatching|error {
        string resourcePath = string `/api/3/issue/watching`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get issue
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issue/[string issueIdOrKey](map<string|string[]> headers = {}, *GetIssueQueries queries) returns IssueBean|error {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: true}, "properties": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Edit issue
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful and the `returnIssue` parameter is `true` 
    resource isolated function put api/'3/issue/[string issueIdOrKey](IssueUpdateDetails payload, map<string|string[]> headers = {}, *EditIssueQueries queries) returns json|error {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete issue
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/issue/[string issueIdOrKey](map<string|string[]> headers = {}, *DeleteIssueQueries queries) returns error? {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Assign issue
    #
    # + issueIdOrKey - The ID or key of the issue to be assigned
    # + headers - Headers to be sent with the request 
    # + payload - The request object with the user that the issue is assigned to 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/issue/[string issueIdOrKey]/assignee(User payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/assignee`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Add attachment
    #
    # + issueIdOrKey - The ID or key of the issue that attachments are added to
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/issue/[string issueIdOrKey]/attachments(MultipartFile[] payload, map<string|string[]> headers = {}) returns Attachment[]|error {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/attachments`;
        http:Request request = new;
        mime:Entity[] bodyParts = check createBodyParts(check jsondata:toJson(payload).ensureType());
        request.setBodyParts(bodyParts);
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get changelogs
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issue/[string issueIdOrKey]/changelog(map<string|string[]> headers = {}, *GetChangeLogsQueries queries) returns PageBeanChangelog|error {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/changelog`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get changelogs by IDs
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/issue/[string issueIdOrKey]/changelog/list(IssueChangelogIds payload, map<string|string[]> headers = {}) returns PageOfChangelogs|error {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/changelog/list`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get comments
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issue/[string issueIdOrKey]/comment(map<string|string[]> headers = {}, *GetCommentsQueries queries) returns PageOfComments|error {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/comment`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add comment
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/issue/[string issueIdOrKey]/comment(Comment payload, map<string|string[]> headers = {}, *AddCommentQueries queries) returns Comment|error {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/comment`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get comment
    #
    # + issueIdOrKey - The ID or key of the issue
    # + id - The ID of the comment
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issue/[string issueIdOrKey]/comment/[string id](map<string|string[]> headers = {}, *GetCommentQueries queries) returns Comment|error {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/comment/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update comment
    #
    # + issueIdOrKey - The ID or key of the issue
    # + id - The ID of the comment
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/issue/[string issueIdOrKey]/comment/[string id](Comment payload, map<string|string[]> headers = {}, *UpdateCommentQueries queries) returns Comment|error {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/comment/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete comment
    #
    # + issueIdOrKey - The ID or key of the issue
    # + id - The ID of the comment
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/issue/[string issueIdOrKey]/comment/[string id](map<string|string[]> headers = {}, *DeleteCommentQueries queries) returns error? {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/comment/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get edit issue metadata
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issue/[string issueIdOrKey]/editmeta(map<string|string[]> headers = {}, *GetEditIssueMetaQueries queries) returns IssueUpdateMetadata|error {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/editmeta`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Send notification for issue
    #
    # + issueIdOrKey - ID or key of the issue that the notification is sent for
    # + headers - Headers to be sent with the request 
    # + payload - The request object for the notification and recipients 
    # + return - Returned if the email is queued for sending 
    resource isolated function post api/'3/issue/[string issueIdOrKey]/notify(Notification payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/notify`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get issue property keys
    #
    # + issueIdOrKey - The key or ID of the issue
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issue/[string issueIdOrKey]/properties(map<string|string[]> headers = {}) returns PropertyKeys|error {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/properties`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get issue property
    #
    # + issueIdOrKey - The key or ID of the issue
    # + propertyKey - The key of the property
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issue/[string issueIdOrKey]/properties/[string propertyKey](map<string|string[]> headers = {}) returns EntityProperty|error {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/properties/${getEncodedUri(propertyKey)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set issue property
    #
    # + issueIdOrKey - The ID or key of the issue
    # + propertyKey - The key of the issue property. The maximum length is 255 characters
    # + headers - Headers to be sent with the request 
    # + payload - The value of the property. The value has to be a valid, non-empty [JSON](https://tools.ietf.org/html/rfc4627) value. The maximum length of the property value is 32768 bytes 
    # + return - Returned if the issue property is updated 
    resource isolated function put api/'3/issue/[string issueIdOrKey]/properties/[string propertyKey](json payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/properties/${getEncodedUri(propertyKey)}`;
        http:Request request = new;
        request.setPayload(payload, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete issue property
    #
    # + issueIdOrKey - The key or ID of the issue
    # + propertyKey - The key of the property
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/issue/[string issueIdOrKey]/properties/[string propertyKey](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/properties/${getEncodedUri(propertyKey)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get remote issue links
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issue/[string issueIdOrKey]/remotelink(map<string|string[]> headers = {}, *GetRemoteIssueLinksQueries queries) returns RemoteIssueLink|error {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/remotelink`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create or update remote issue link
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + return - Returned if the remote issue link is updated 
    resource isolated function post api/'3/issue/[string issueIdOrKey]/remotelink(RemoteIssueLinkRequest payload, map<string|string[]> headers = {}) returns RemoteIssueLinkIdentifies|error {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/remotelink`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete remote issue link by global ID
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/issue/[string issueIdOrKey]/remotelink(map<string|string[]> headers = {}, *DeleteRemoteIssueLinkByGlobalIdQueries queries) returns error? {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/remotelink`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get remote issue link by ID
    #
    # + issueIdOrKey - The ID or key of the issue
    # + linkId - The ID of the remote issue link
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issue/[string issueIdOrKey]/remotelink/[string linkId](map<string|string[]> headers = {}) returns RemoteIssueLink|error {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/remotelink/${getEncodedUri(linkId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update remote issue link by ID
    #
    # + issueIdOrKey - The ID or key of the issue
    # + linkId - The ID of the remote issue link
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/issue/[string issueIdOrKey]/remotelink/[string linkId](RemoteIssueLinkRequest payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/remotelink/${getEncodedUri(linkId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete remote issue link by ID
    #
    # + issueIdOrKey - The ID or key of the issue
    # + linkId - The ID of a remote issue link
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/issue/[string issueIdOrKey]/remotelink/[string linkId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/remotelink/${getEncodedUri(linkId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get transitions
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issue/[string issueIdOrKey]/transitions(map<string|string[]> headers = {}, *GetTransitionsQueries queries) returns Transitions|error {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/transitions`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Transition issue
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/issue/[string issueIdOrKey]/transitions(IssueUpdateDetails payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/transitions`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get votes
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issue/[string issueIdOrKey]/votes(map<string|string[]> headers = {}) returns Votes|error {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/votes`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Add vote
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/issue/[string issueIdOrKey]/votes(map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/votes`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete vote
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/issue/[string issueIdOrKey]/votes(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/votes`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get issue watchers
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issue/[string issueIdOrKey]/watchers(map<string|string[]> headers = {}) returns Watchers|error {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/watchers`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Add watcher
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + payload - The account ID of the user. Note that username cannot be used due to privacy changes 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/issue/[string issueIdOrKey]/watchers(string payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/watchers`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete watcher
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/issue/[string issueIdOrKey]/watchers(map<string|string[]> headers = {}, *RemoveWatcherQueries queries) returns error? {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/watchers`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get issue worklogs
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issue/[string issueIdOrKey]/worklog(map<string|string[]> headers = {}, *GetIssueWorklogQueries queries) returns PageOfWorklogs|error {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/worklog`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add worklog
    #
    # + issueIdOrKey - The ID or key the issue
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/issue/[string issueIdOrKey]/worklog(Worklog payload, map<string|string[]> headers = {}, *AddWorklogQueries queries) returns Worklog|error {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/worklog`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Bulk delete worklogs
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - A JSON object containing a list of worklog IDs 
    # + return - Returned if the bulk deletion request was partially successful, with a message indicating partial success 
    resource isolated function delete api/'3/issue/[string issueIdOrKey]/worklog(WorklogIdsRequestBean payload, map<string|string[]> headers = {}, *BulkDeleteWorklogsQueries queries) returns error? {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/worklog`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->delete(resourcePath, request, headers);
    }

    # Bulk move worklogs
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - A JSON object containing a list of worklog IDs and the ID or key of the destination issue 
    # + return - Returned if the request is partially successful 
    resource isolated function post api/'3/issue/[string issueIdOrKey]/worklog/move(WorklogsMoveRequestBean payload, map<string|string[]> headers = {}, *BulkMoveWorklogsQueries queries) returns error? {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/worklog/move`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get worklog
    #
    # + issueIdOrKey - The ID or key of the issue
    # + id - The ID of the worklog
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issue/[string issueIdOrKey]/worklog/[string id](map<string|string[]> headers = {}, *GetWorklogQueries queries) returns Worklog|error {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/worklog/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update worklog
    #
    # + issueIdOrKey - The ID or key the issue
    # + id - The ID of the worklog
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/issue/[string issueIdOrKey]/worklog/[string id](Worklog payload, map<string|string[]> headers = {}, *UpdateWorklogQueries queries) returns Worklog|error {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/worklog/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete worklog
    #
    # + issueIdOrKey - The ID or key of the issue
    # + id - The ID of the worklog
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/issue/[string issueIdOrKey]/worklog/[string id](map<string|string[]> headers = {}, *DeleteWorklogQueries queries) returns error? {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/worklog/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get worklog property keys
    #
    # + issueIdOrKey - The ID or key of the issue
    # + worklogId - The ID of the worklog
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issue/[string issueIdOrKey]/worklog/[string worklogId]/properties(map<string|string[]> headers = {}) returns PropertyKeys|error {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/worklog/${getEncodedUri(worklogId)}/properties`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get worklog property
    #
    # + issueIdOrKey - The ID or key of the issue
    # + worklogId - The ID of the worklog
    # + propertyKey - The key of the property
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issue/[string issueIdOrKey]/worklog/[string worklogId]/properties/[string propertyKey](map<string|string[]> headers = {}) returns EntityProperty|error {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/worklog/${getEncodedUri(worklogId)}/properties/${getEncodedUri(propertyKey)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set worklog property
    #
    # + issueIdOrKey - The ID or key of the issue
    # + worklogId - The ID of the worklog
    # + propertyKey - The key of the issue property. The maximum length is 255 characters
    # + headers - Headers to be sent with the request 
    # + payload - The value of the property. The value has to be a valid, non-empty [JSON](https://tools.ietf.org/html/rfc4627) value. The maximum length of the property value is 32768 bytes 
    # + return - Returned if the worklog property is updated 
    resource isolated function put api/'3/issue/[string issueIdOrKey]/worklog/[string worklogId]/properties/[string propertyKey](json payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/worklog/${getEncodedUri(worklogId)}/properties/${getEncodedUri(propertyKey)}`;
        http:Request request = new;
        request.setPayload(payload, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete worklog property
    #
    # + issueIdOrKey - The ID or key of the issue
    # + worklogId - The ID of the worklog
    # + propertyKey - The key of the property
    # + headers - Headers to be sent with the request 
    # + return - Returned if the worklog property is removed 
    resource isolated function delete api/'3/issue/[string issueIdOrKey]/worklog/[string worklogId]/properties/[string propertyKey](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/issue/${getEncodedUri(issueIdOrKey)}/worklog/${getEncodedUri(worklogId)}/properties/${getEncodedUri(propertyKey)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Create issue link
    #
    # + headers - Headers to be sent with the request 
    # + payload - The issue link request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/issueLink(LinkIssueRequestJsonBean payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/issueLink`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get issue link
    #
    # + linkId - The ID of the issue link
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issueLink/[string linkId](map<string|string[]> headers = {}) returns IssueLink|error {
        string resourcePath = string `/api/3/issueLink/${getEncodedUri(linkId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete issue link
    #
    # + linkId - The ID of the issue link
    # + headers - Headers to be sent with the request 
    # + return - 200 response 
    resource isolated function delete api/'3/issueLink/[string linkId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/issueLink/${getEncodedUri(linkId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get issue link types
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issueLinkType(map<string|string[]> headers = {}) returns IssueLinkTypes|error {
        string resourcePath = string `/api/3/issueLinkType`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create issue link type
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/issueLinkType(IssueLinkType payload, map<string|string[]> headers = {}) returns IssueLinkType|error {
        string resourcePath = string `/api/3/issueLinkType`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get issue link type
    #
    # + issueLinkTypeId - The ID of the issue link type
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issueLinkType/[string issueLinkTypeId](map<string|string[]> headers = {}) returns IssueLinkType|error {
        string resourcePath = string `/api/3/issueLinkType/${getEncodedUri(issueLinkTypeId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update issue link type
    #
    # + issueLinkTypeId - The ID of the issue link type
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/issueLinkType/[string issueLinkTypeId](IssueLinkType payload, map<string|string[]> headers = {}) returns IssueLinkType|error {
        string resourcePath = string `/api/3/issueLinkType/${getEncodedUri(issueLinkTypeId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete issue link type
    #
    # + issueLinkTypeId - The ID of the issue link type
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/issueLinkType/[string issueLinkTypeId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/issueLinkType/${getEncodedUri(issueLinkTypeId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Export archived issue(s)
    #
    # + headers - Headers to be sent with the request 
    # + payload - You can filter the issues in your request by the `projects`, `archivedBy`, `archivedDate`, `issueTypes`, and `reporters` fields. All filters are optional. If you don't provide any filters, you'll get a list of up to one million archived issues 
    # + return - Returns the details of your export task. You can use the [get task](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-tasks/#api-rest-api-3-task-taskid-get) API to view the progress of your request 
    resource isolated function put api/'3/issues/archive/export(ArchivedIssuesFilterRequest payload, map<string|string[]> headers = {}) returns ExportArchivedIssuesTaskProgressResponse|error {
        string resourcePath = string `/api/3/issues/archive/export`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get issue security schemes
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issuesecurityschemes(map<string|string[]> headers = {}) returns SecuritySchemes|error {
        string resourcePath = string `/api/3/issuesecurityschemes`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create issue security scheme
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/issuesecurityschemes(CreateIssueSecuritySchemeDetails payload, map<string|string[]> headers = {}) returns SecuritySchemeId|error {
        string resourcePath = string `/api/3/issuesecurityschemes`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get issue security levels
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issuesecurityschemes/level(map<string|string[]> headers = {}, *GetSecurityLevelsQueries queries) returns PageBeanSecurityLevel|error {
        string resourcePath = string `/api/3/issuesecurityschemes/level`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}, "schemeId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Set default issue security levels
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/issuesecurityschemes/level/default(SetDefaultLevelsRequest payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/issuesecurityschemes/level/default`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get issue security level members
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issuesecurityschemes/level/member(map<string|string[]> headers = {}, *GetSecurityLevelMembersQueries queries) returns PageBeanSecurityLevelMember|error {
        string resourcePath = string `/api/3/issuesecurityschemes/level/member`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}, "schemeId": {style: FORM, explode: true}, "levelId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get projects using issue security schemes
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issuesecurityschemes/project(map<string|string[]> headers = {}, *SearchProjectsUsingSecuritySchemesQueries queries) returns PageBeanIssueSecuritySchemeToProjectMapping|error {
        string resourcePath = string `/api/3/issuesecurityschemes/project`;
        map<Encoding> queryParamEncoding = {"issueSecuritySchemeId": {style: FORM, explode: true}, "projectId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Associate security scheme to project
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/issuesecurityschemes/project(AssociateSecuritySchemeWithProjectDetails payload, map<string|string[]> headers = {}) returns http:Response|error {
        string resourcePath = string `/api/3/issuesecurityschemes/project`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Search issue security schemes
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issuesecurityschemes/search(map<string|string[]> headers = {}, *SearchSecuritySchemesQueries queries) returns PageBeanSecuritySchemeWithProjects|error {
        string resourcePath = string `/api/3/issuesecurityschemes/search`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}, "projectId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get issue security scheme
    #
    # + id - The ID of the issue security scheme. Use the [Get issue security schemes](#api-rest-api-3-issuesecurityschemes-get) operation to get a list of issue security scheme IDs
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issuesecurityschemes/[int id](map<string|string[]> headers = {}) returns SecurityScheme|error {
        string resourcePath = string `/api/3/issuesecurityschemes/${getEncodedUri(id)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update issue security scheme
    #
    # + id - The ID of the issue security scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/issuesecurityschemes/[string id](UpdateIssueSecuritySchemeRequestBean payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/issuesecurityschemes/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get issue security level members by issue security scheme
    #
    # + issueSecuritySchemeId - The ID of the issue security scheme. Use the [Get issue security schemes](#api-rest-api-3-issuesecurityschemes-get) operation to get a list of issue security scheme IDs
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issuesecurityschemes/[int issueSecuritySchemeId]/members(map<string|string[]> headers = {}, *GetIssueSecurityLevelMembersQueries queries) returns PageBeanIssueSecurityLevelMember|error {
        string resourcePath = string `/api/3/issuesecurityschemes/${getEncodedUri(issueSecuritySchemeId)}/members`;
        map<Encoding> queryParamEncoding = {"issueSecurityLevelId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete issue security scheme
    #
    # + schemeId - The ID of the issue security scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/issuesecurityschemes/[string schemeId](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/issuesecurityschemes/${getEncodedUri(schemeId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Add issue security levels
    #
    # + schemeId - The ID of the issue security scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/issuesecurityschemes/[string schemeId]/level(AddSecuritySchemeLevelsRequestBean payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/issuesecurityschemes/${getEncodedUri(schemeId)}/level`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Update issue security level
    #
    # + schemeId - The ID of the issue security scheme level belongs to
    # + levelId - The ID of the issue security level to update
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/issuesecurityschemes/[string schemeId]/level/[string levelId](UpdateIssueSecurityLevelDetails payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/issuesecurityschemes/${getEncodedUri(schemeId)}/level/${getEncodedUri(levelId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Remove issue security level
    #
    # + schemeId - The ID of the issue security scheme
    # + levelId - The ID of the issue security level to remove
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/issuesecurityschemes/[string schemeId]/level/[string levelId](map<string|string[]> headers = {}, *RemoveLevelQueries queries) returns http:Response|error {
        string resourcePath = string `/api/3/issuesecurityschemes/${getEncodedUri(schemeId)}/level/${getEncodedUri(levelId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Add issue security level members
    #
    # + schemeId - The ID of the issue security scheme
    # + levelId - The ID of the issue security level
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/issuesecurityschemes/[string schemeId]/level/[string levelId]/member(SecuritySchemeMembersRequest payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/issuesecurityschemes/${getEncodedUri(schemeId)}/level/${getEncodedUri(levelId)}/member`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Remove member from issue security level
    #
    # + schemeId - The ID of the issue security scheme
    # + levelId - The ID of the issue security level
    # + memberId - The ID of the issue security level member to be removed
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/issuesecurityschemes/[string schemeId]/level/[string levelId]/member/[string memberId](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/issuesecurityschemes/${getEncodedUri(schemeId)}/level/${getEncodedUri(levelId)}/member/${getEncodedUri(memberId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get all issue types for user
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issuetype(map<string|string[]> headers = {}) returns IssueTypeDetails[]|error {
        string resourcePath = string `/api/3/issuetype`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create issue type
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/issuetype(IssueTypeCreateBean payload, map<string|string[]> headers = {}) returns IssueTypeDetails|error {
        string resourcePath = string `/api/3/issuetype`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get issue types for project
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issuetype/project(map<string|string[]> headers = {}, *GetIssueTypesForProjectQueries queries) returns IssueTypeDetails[]|error {
        string resourcePath = string `/api/3/issuetype/project`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get issue type
    #
    # + id - The ID of the issue type
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issuetype/[string id](map<string|string[]> headers = {}) returns IssueTypeDetails|error {
        string resourcePath = string `/api/3/issuetype/${getEncodedUri(id)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update issue type
    #
    # + id - The ID of the issue type
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/issuetype/[string id](IssueTypeUpdateBean payload, map<string|string[]> headers = {}) returns IssueTypeDetails|error {
        string resourcePath = string `/api/3/issuetype/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete issue type
    #
    # + id - The ID of the issue type
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/issuetype/[string id](map<string|string[]> headers = {}, *DeleteIssueTypeQueries queries) returns error? {
        string resourcePath = string `/api/3/issuetype/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get alternative issue types
    #
    # + id - The ID of the issue type
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issuetype/[string id]/alternatives(map<string|string[]> headers = {}) returns IssueTypeDetails[]|error {
        string resourcePath = string `/api/3/issuetype/${getEncodedUri(id)}/alternatives`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Load issue type avatar
    #
    # + id - The ID of the issue type
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/issuetype/[string id]/avatar2(http:Request request, map<string|string[]> headers = {}, *CreateIssueTypeAvatarQueries queries) returns Avatar|error {
        string resourcePath = string `/api/3/issuetype/${getEncodedUri(id)}/avatar2`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        // TODO: Update the request as needed;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get issue type property keys
    #
    # + issueTypeId - The ID of the issue type
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issuetype/[string issueTypeId]/properties(map<string|string[]> headers = {}) returns PropertyKeys|error {
        string resourcePath = string `/api/3/issuetype/${getEncodedUri(issueTypeId)}/properties`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get issue type property
    #
    # + issueTypeId - The ID of the issue type
    # + propertyKey - The key of the property. Use [Get issue type property keys](#api-rest-api-3-issuetype-issueTypeId-properties-get) to get a list of all issue type property keys
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issuetype/[string issueTypeId]/properties/[string propertyKey](map<string|string[]> headers = {}) returns EntityProperty|error {
        string resourcePath = string `/api/3/issuetype/${getEncodedUri(issueTypeId)}/properties/${getEncodedUri(propertyKey)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set issue type property
    #
    # + issueTypeId - The ID of the issue type
    # + propertyKey - The key of the issue type property. The maximum length is 255 characters
    # + headers - Headers to be sent with the request 
    # + payload - The value of the property. The value has to be a valid, non-empty [JSON](https://tools.ietf.org/html/rfc4627) value. The maximum length of the property value is 32768 bytes 
    # + return - Returned if the issue type property is updated 
    resource isolated function put api/'3/issuetype/[string issueTypeId]/properties/[string propertyKey](json payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/issuetype/${getEncodedUri(issueTypeId)}/properties/${getEncodedUri(propertyKey)}`;
        http:Request request = new;
        request.setPayload(payload, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete issue type property
    #
    # + issueTypeId - The ID of the issue type
    # + propertyKey - The key of the property. Use [Get issue type property keys](#api-rest-api-3-issuetype-issueTypeId-properties-get) to get a list of all issue type property keys
    # + headers - Headers to be sent with the request 
    # + return - Returned if the issue type property is deleted 
    resource isolated function delete api/'3/issuetype/[string issueTypeId]/properties/[string propertyKey](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/issuetype/${getEncodedUri(issueTypeId)}/properties/${getEncodedUri(propertyKey)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get all issue type schemes
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issuetypescheme(map<string|string[]> headers = {}, *GetAllIssueTypeSchemesQueries queries) returns PageBeanIssueTypeScheme|error {
        string resourcePath = string `/api/3/issuetypescheme`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create issue type scheme
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/issuetypescheme(IssueTypeSchemeDetails payload, map<string|string[]> headers = {}) returns IssueTypeSchemeID|error {
        string resourcePath = string `/api/3/issuetypescheme`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get issue type scheme items
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issuetypescheme/mapping(map<string|string[]> headers = {}, *GetIssueTypeSchemesMappingQueries queries) returns PageBeanIssueTypeSchemeMapping|error {
        string resourcePath = string `/api/3/issuetypescheme/mapping`;
        map<Encoding> queryParamEncoding = {"issueTypeSchemeId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get issue type schemes for projects
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issuetypescheme/project(map<string|string[]> headers = {}, *GetIssueTypeSchemeForProjectsQueries queries) returns PageBeanIssueTypeSchemeProjects|error {
        string resourcePath = string `/api/3/issuetypescheme/project`;
        map<Encoding> queryParamEncoding = {"projectId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Assign issue type scheme to project
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/issuetypescheme/project(IssueTypeSchemeProjectAssociation payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/issuetypescheme/project`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Update issue type scheme
    #
    # + issueTypeSchemeId - The ID of the issue type scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/issuetypescheme/[int issueTypeSchemeId](IssueTypeSchemeUpdateDetails payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/issuetypescheme/${getEncodedUri(issueTypeSchemeId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete issue type scheme
    #
    # + issueTypeSchemeId - The ID of the issue type scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the issue type scheme is deleted 
    resource isolated function delete api/'3/issuetypescheme/[int issueTypeSchemeId](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/issuetypescheme/${getEncodedUri(issueTypeSchemeId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Add issue types to issue type scheme
    #
    # + issueTypeSchemeId - The ID of the issue type scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/issuetypescheme/[int issueTypeSchemeId]/issuetype(IssueTypeIds payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/issuetypescheme/${getEncodedUri(issueTypeSchemeId)}/issuetype`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Change order of issue types
    #
    # + issueTypeSchemeId - The ID of the issue type scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/issuetypescheme/[int issueTypeSchemeId]/issuetype/move(OrderOfIssueTypes payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/issuetypescheme/${getEncodedUri(issueTypeSchemeId)}/issuetype/move`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Remove issue type from issue type scheme
    #
    # + issueTypeSchemeId - The ID of the issue type scheme
    # + issueTypeId - The ID of the issue type
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/issuetypescheme/[int issueTypeSchemeId]/issuetype/[int issueTypeId](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/issuetypescheme/${getEncodedUri(issueTypeSchemeId)}/issuetype/${getEncodedUri(issueTypeId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get issue type screen schemes
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issuetypescreenscheme(map<string|string[]> headers = {}, *GetIssueTypeScreenSchemesQueries queries) returns PageBeanIssueTypeScreenScheme|error {
        string resourcePath = string `/api/3/issuetypescreenscheme`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create issue type screen scheme
    #
    # + headers - Headers to be sent with the request 
    # + payload - An issue type screen scheme bean 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/issuetypescreenscheme(IssueTypeScreenSchemeDetails payload, map<string|string[]> headers = {}) returns IssueTypeScreenSchemeId|error {
        string resourcePath = string `/api/3/issuetypescreenscheme`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get issue type screen scheme items
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issuetypescreenscheme/mapping(map<string|string[]> headers = {}, *GetIssueTypeScreenSchemeMappingsQueries queries) returns PageBeanIssueTypeScreenSchemeItem|error {
        string resourcePath = string `/api/3/issuetypescreenscheme/mapping`;
        map<Encoding> queryParamEncoding = {"issueTypeScreenSchemeId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get issue type screen schemes for projects
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issuetypescreenscheme/project(map<string|string[]> headers = {}, *GetIssueTypeScreenSchemeProjectAssociationsQueries queries) returns PageBeanIssueTypeScreenSchemesProjects|error {
        string resourcePath = string `/api/3/issuetypescreenscheme/project`;
        map<Encoding> queryParamEncoding = {"projectId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Assign issue type screen scheme to project
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/issuetypescreenscheme/project(IssueTypeScreenSchemeProjectAssociation payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/issuetypescreenscheme/project`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Update issue type screen scheme
    #
    # + issueTypeScreenSchemeId - The ID of the issue type screen scheme
    # + headers - Headers to be sent with the request 
    # + payload - The issue type screen scheme update details 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/issuetypescreenscheme/[string issueTypeScreenSchemeId](IssueTypeScreenSchemeUpdateDetails payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/issuetypescreenscheme/${getEncodedUri(issueTypeScreenSchemeId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete issue type screen scheme
    #
    # + issueTypeScreenSchemeId - The ID of the issue type screen scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the issue type screen scheme is deleted 
    resource isolated function delete api/'3/issuetypescreenscheme/[string issueTypeScreenSchemeId](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/issuetypescreenscheme/${getEncodedUri(issueTypeScreenSchemeId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Append mappings to issue type screen scheme
    #
    # + issueTypeScreenSchemeId - The ID of the issue type screen scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/issuetypescreenscheme/[string issueTypeScreenSchemeId]/mapping(IssueTypeScreenSchemeMappingDetails payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/issuetypescreenscheme/${getEncodedUri(issueTypeScreenSchemeId)}/mapping`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Update issue type screen scheme default screen scheme
    #
    # + issueTypeScreenSchemeId - The ID of the issue type screen scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/issuetypescreenscheme/[string issueTypeScreenSchemeId]/mapping/default(UpdateDefaultScreenScheme payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/issuetypescreenscheme/${getEncodedUri(issueTypeScreenSchemeId)}/mapping/default`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Remove mappings from issue type screen scheme
    #
    # + issueTypeScreenSchemeId - The ID of the issue type screen scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the screen scheme mappings are removed from the issue type screen scheme 
    resource isolated function post api/'3/issuetypescreenscheme/[string issueTypeScreenSchemeId]/mapping/remove(IssueTypeIds payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/issuetypescreenscheme/${getEncodedUri(issueTypeScreenSchemeId)}/mapping/remove`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get issue type screen scheme projects
    #
    # + issueTypeScreenSchemeId - The ID of the issue type screen scheme
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/issuetypescreenscheme/[int issueTypeScreenSchemeId]/project(map<string|string[]> headers = {}, *GetProjectsForIssueTypeScreenSchemeQueries queries) returns PageBeanProjectDetails|error {
        string resourcePath = string `/api/3/issuetypescreenscheme/${getEncodedUri(issueTypeScreenSchemeId)}/project`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get field reference data (GET)
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/jql/autocompletedata(map<string|string[]> headers = {}) returns JQLReferenceData|error {
        string resourcePath = string `/api/3/jql/autocompletedata`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get field reference data (POST)
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/jql/autocompletedata(SearchAutoCompleteFilter payload, map<string|string[]> headers = {}) returns JQLReferenceData|error {
        string resourcePath = string `/api/3/jql/autocompletedata`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get field auto complete suggestions
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/jql/autocompletedata/suggestions(map<string|string[]> headers = {}, *GetFieldAutoCompleteForQueryStringQueries queries) returns AutoCompleteSuggestions|error {
        string resourcePath = string `/api/3/jql/autocompletedata/suggestions`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get precomputations (apps)
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/jql/'function/computation(map<string|string[]> headers = {}, *GetPrecomputationsQueries queries) returns PageBeanJqlFunctionPrecomputationBean|error {
        string resourcePath = string `/api/3/jql/function/computation`;
        map<Encoding> queryParamEncoding = {"functionKey": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update precomputations (apps)
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/jql/'function/computation(JqlFunctionPrecomputationUpdateRequestBean payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/jql/function/computation`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Check issues against JQL
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/jql/'match(IssuesAndJQLQueries payload, map<string|string[]> headers = {}) returns IssueMatches|error {
        string resourcePath = string `/api/3/jql/match`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Parse JQL query
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/jql/parse(JqlQueriesToParse payload, map<string|string[]> headers = {}, *ParseJqlQueriesQueries queries) returns ParsedJqlQueries|error {
        string resourcePath = string `/api/3/jql/parse`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Convert user identifiers to account IDs in JQL queries
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful. Note that the JQL queries are returned in the same order that they were passed 
    resource isolated function post api/'3/jql/pdcleaner(JQLPersonalDataMigrationRequest payload, map<string|string[]> headers = {}) returns ConvertedJQLQueries|error {
        string resourcePath = string `/api/3/jql/pdcleaner`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Sanitize JQL queries
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/jql/sanitize(JqlQueriesToSanitize payload, map<string|string[]> headers = {}) returns SanitizedJqlQueries|error {
        string resourcePath = string `/api/3/jql/sanitize`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get all labels
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/label(map<string|string[]> headers = {}, *GetAllLabelsQueries queries) returns PageBeanString|error {
        string resourcePath = string `/api/3/label`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get approximate license count
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/license/approximateLicenseCount(map<string|string[]> headers = {}) returns LicenseMetric|error {
        string resourcePath = string `/api/3/license/approximateLicenseCount`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get approximate application license count
    #
    # + applicationKey - The ID of the application, represents a specific version of Jira
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/license/approximateLicenseCount/product/["jira-core"|"jira-product-discovery"|"jira-software"|"jira-servicedesk" applicationKey](map<string|string[]> headers = {}) returns LicenseMetric|error {
        string resourcePath = string `/api/3/license/approximateLicenseCount/product/${getEncodedUri(applicationKey)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get my permissions
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/mypermissions(map<string|string[]> headers = {}, *GetMyPermissionsQueries queries) returns Permissions|error {
        string resourcePath = string `/api/3/mypermissions`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get preference
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/mypreferences(map<string|string[]> headers = {}, *GetPreferenceQueries queries) returns string|error {
        string resourcePath = string `/api/3/mypreferences`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Set preference
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The value of the preference as a plain text string. The maximum length is 255 characters 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/mypreferences(string payload, map<string|string[]> headers = {}, *SetPreferenceQueries queries) returns json|error {
        string resourcePath = string `/api/3/mypreferences`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete preference
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/mypreferences(map<string|string[]> headers = {}, *RemovePreferenceQueries queries) returns error? {
        string resourcePath = string `/api/3/mypreferences`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get locale
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/mypreferences/locale(map<string|string[]> headers = {}) returns Locale|error {
        string resourcePath = string `/api/3/mypreferences/locale`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get current user
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/myself(map<string|string[]> headers = {}, *GetCurrentUserQueries queries) returns User|error {
        string resourcePath = string `/api/3/myself`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get notification schemes paginated
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful. Only returns notification schemes that the user has permission to access. An empty list is returned if the user lacks permission to access all notification schemes 
    resource isolated function get api/'3/notificationscheme(map<string|string[]> headers = {}, *GetNotificationSchemesQueries queries) returns PageBeanNotificationScheme|error {
        string resourcePath = string `/api/3/notificationscheme`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}, "projectId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create notification scheme
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/notificationscheme(CreateNotificationSchemeDetails payload, map<string|string[]> headers = {}) returns NotificationSchemeId|error {
        string resourcePath = string `/api/3/notificationscheme`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get projects using notification schemes paginated
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/notificationscheme/project(map<string|string[]> headers = {}, *GetNotificationSchemeToProjectMappingsQueries queries) returns PageBeanNotificationSchemeAndProjectMappingJsonBean|error {
        string resourcePath = string `/api/3/notificationscheme/project`;
        map<Encoding> queryParamEncoding = {"notificationSchemeId": {style: FORM, explode: true}, "projectId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get notification scheme
    #
    # + id - The ID of the notification scheme. Use [Get notification schemes paginated](#api-rest-api-3-notificationscheme-get) to get a list of notification scheme IDs
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/notificationscheme/[int id](map<string|string[]> headers = {}, *GetNotificationSchemeQueries queries) returns NotificationScheme|error {
        string resourcePath = string `/api/3/notificationscheme/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update notification scheme
    #
    # + id - The ID of the notification scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/notificationscheme/[string id](UpdateNotificationSchemeDetails payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/notificationscheme/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Add notifications to notification scheme
    #
    # + id - The ID of the notification scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/notificationscheme/[string id]/notification(AddNotificationsDetails payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/notificationscheme/${getEncodedUri(id)}/notification`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete notification scheme
    #
    # + notificationSchemeId - The ID of the notification scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/notificationscheme/[string notificationSchemeId](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/notificationscheme/${getEncodedUri(notificationSchemeId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Remove notification from notification scheme
    #
    # + notificationSchemeId - The ID of the notification scheme
    # + notificationId - The ID of the notification
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/notificationscheme/[string notificationSchemeId]/notification/[string notificationId](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/notificationscheme/${getEncodedUri(notificationSchemeId)}/notification/${getEncodedUri(notificationId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get all permissions
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/permissions(map<string|string[]> headers = {}) returns Permissions|error {
        string resourcePath = string `/api/3/permissions`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get bulk permissions
    #
    # + headers - Headers to be sent with the request 
    # + payload - Details of the permissions to check 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/permissions/'check(BulkPermissionsRequestBean payload, map<string|string[]> headers = {}) returns BulkPermissionGrants|error {
        string resourcePath = string `/api/3/permissions/check`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get permitted projects
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/permissions/project(PermissionsKeysBean payload, map<string|string[]> headers = {}) returns PermittedProjects|error {
        string resourcePath = string `/api/3/permissions/project`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get all permission schemes
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/permissionscheme(map<string|string[]> headers = {}, *GetAllPermissionSchemesQueries queries) returns PermissionSchemes|error {
        string resourcePath = string `/api/3/permissionscheme`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create permission scheme
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The permission scheme to create 
    # + return - Returned if the permission scheme is created 
    resource isolated function post api/'3/permissionscheme(PermissionScheme payload, map<string|string[]> headers = {}, *CreatePermissionSchemeQueries queries) returns PermissionScheme|error {
        string resourcePath = string `/api/3/permissionscheme`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get permission scheme
    #
    # + schemeId - The ID of the permission scheme to return
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/permissionscheme/[int schemeId](map<string|string[]> headers = {}, *GetPermissionSchemeQueries queries) returns PermissionScheme|error {
        string resourcePath = string `/api/3/permissionscheme/${getEncodedUri(schemeId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update permission scheme
    #
    # + schemeId - The ID of the permission scheme to update
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the scheme is updated 
    resource isolated function put api/'3/permissionscheme/[int schemeId](PermissionScheme payload, map<string|string[]> headers = {}, *UpdatePermissionSchemeQueries queries) returns PermissionScheme|error {
        string resourcePath = string `/api/3/permissionscheme/${getEncodedUri(schemeId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete permission scheme
    #
    # + schemeId - The ID of the permission scheme being deleted
    # + headers - Headers to be sent with the request 
    # + return - Returned if the permission scheme is deleted 
    resource isolated function delete api/'3/permissionscheme/[int schemeId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/permissionscheme/${getEncodedUri(schemeId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get permission scheme grants
    #
    # + schemeId - The ID of the permission scheme
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/permissionscheme/[int schemeId]/permission(map<string|string[]> headers = {}, *GetPermissionSchemeGrantsQueries queries) returns PermissionGrants|error {
        string resourcePath = string `/api/3/permissionscheme/${getEncodedUri(schemeId)}/permission`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create permission grant
    #
    # + schemeId - The ID of the permission scheme in which to create a new permission grant
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The permission grant to create 
    # + return - Returned if the scheme permission is created 
    resource isolated function post api/'3/permissionscheme/[int schemeId]/permission(PermissionGrant payload, map<string|string[]> headers = {}, *CreatePermissionGrantQueries queries) returns PermissionGrant|error {
        string resourcePath = string `/api/3/permissionscheme/${getEncodedUri(schemeId)}/permission`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get permission scheme grant
    #
    # + schemeId - The ID of the permission scheme
    # + permissionId - The ID of the permission grant
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/permissionscheme/[int schemeId]/permission/[int permissionId](map<string|string[]> headers = {}, *GetPermissionSchemeGrantQueries queries) returns PermissionGrant|error {
        string resourcePath = string `/api/3/permissionscheme/${getEncodedUri(schemeId)}/permission/${getEncodedUri(permissionId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete permission scheme grant
    #
    # + schemeId - The ID of the permission scheme to delete the permission grant from
    # + permissionId - The ID of the permission grant to delete
    # + headers - Headers to be sent with the request 
    # + return - Returned if the permission grant is deleted 
    resource isolated function delete api/'3/permissionscheme/[int schemeId]/permission/[int permissionId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/permissionscheme/${getEncodedUri(schemeId)}/permission/${getEncodedUri(permissionId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Set default priority
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/priority/default(SetDefaultPriorityRequest payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/priority/default`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Move priorities
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/priority/move(ReorderIssuePriorities payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/priority/move`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get priority
    #
    # + id - The ID of the issue priority
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/priority/[string id](map<string|string[]> headers = {}) returns Priority|error {
        string resourcePath = string `/api/3/priority/${getEncodedUri(id)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete priority
    #
    # + id - The ID of the issue priority
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/priority/[string id](map<string|string[]> headers = {}) returns http:Response|error {
        string resourcePath = string `/api/3/priority/${getEncodedUri(id)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get priority schemes
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/priorityscheme(map<string|string[]> headers = {}, *GetPrioritySchemesQueries queries) returns PageBeanPrioritySchemeWithPaginatedPrioritiesAndProjects|error {
        string resourcePath = string `/api/3/priorityscheme`;
        map<Encoding> queryParamEncoding = {"priorityId": {style: FORM, explode: true}, "schemeId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create priority scheme
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is completed 
    resource isolated function post api/'3/priorityscheme(CreatePrioritySchemeDetails payload, map<string|string[]> headers = {}) returns PrioritySchemeId|error {
        string resourcePath = string `/api/3/priorityscheme`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Suggested priorities for mappings
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/priorityscheme/mappings(SuggestedMappingsRequestBean payload, map<string|string[]> headers = {}) returns PageBeanPriorityWithSequence|error {
        string resourcePath = string `/api/3/priorityscheme/mappings`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get available priorities by priority scheme
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/priorityscheme/priorities/available(map<string|string[]> headers = {}, *GetAvailablePrioritiesByPrioritySchemeQueries queries) returns PageBeanPriorityWithSequence|error {
        string resourcePath = string `/api/3/priorityscheme/priorities/available`;
        map<Encoding> queryParamEncoding = {"exclude": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update priority scheme
    #
    # + schemeId - The ID of the priority scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is accepted 
    resource isolated function put api/'3/priorityscheme/[int schemeId](UpdatePrioritySchemeRequestBean payload, map<string|string[]> headers = {}) returns UpdatePrioritySchemeResponseBean|error {
        string resourcePath = string `/api/3/priorityscheme/${getEncodedUri(schemeId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete priority scheme
    #
    # + schemeId - The priority scheme ID
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/priorityscheme/[int schemeId](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/priorityscheme/${getEncodedUri(schemeId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get priorities by priority scheme
    #
    # + schemeId - The priority scheme ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/priorityscheme/[string schemeId]/priorities(map<string|string[]> headers = {}, *GetPrioritiesByPrioritySchemeQueries queries) returns PageBeanPriorityWithSequence|error {
        string resourcePath = string `/api/3/priorityscheme/${getEncodedUri(schemeId)}/priorities`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get projects by priority scheme
    #
    # + schemeId - The priority scheme ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/priorityscheme/[string schemeId]/projects(map<string|string[]> headers = {}, *GetProjectsByPrioritySchemeQueries queries) returns PageBeanProject|error {
        string resourcePath = string `/api/3/priorityscheme/${getEncodedUri(schemeId)}/projects`;
        map<Encoding> queryParamEncoding = {"projectId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create project
    #
    # + headers - Headers to be sent with the request 
    # + payload - The JSON representation of the project being created 
    # + return - Returned if the project is created 
    resource isolated function post api/'3/project(CreateProjectDetails payload, map<string|string[]> headers = {}) returns ProjectIdentifiers|error {
        string resourcePath = string `/api/3/project`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get recent projects
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/project/recent(map<string|string[]> headers = {}, *GetRecentQueries queries) returns Project[]|error {
        string resourcePath = string `/api/3/project/recent`;
        map<Encoding> queryParamEncoding = {"properties": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get projects paginated
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/project/search(map<string|string[]> headers = {}, *SearchProjectsQueries queries) returns PageBeanProject|error {
        string resourcePath = string `/api/3/project/search`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}, "keys": {style: FORM, explode: true}, "status": {style: FORM, explode: true}, "properties": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get all project types
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/project/'type(map<string|string[]> headers = {}) returns ProjectType[]|error {
        string resourcePath = string `/api/3/project/type`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get licensed project types
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/project/'type/accessible(map<string|string[]> headers = {}) returns ProjectType[]|error {
        string resourcePath = string `/api/3/project/type/accessible`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get project type by key
    #
    # + projectTypeKey - The key of the project type
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/project/'type/["software"|"service_desk"|"business"|"product_discovery" projectTypeKey](map<string|string[]> headers = {}) returns ProjectType|error {
        string resourcePath = string `/api/3/project/type/${getEncodedUri(projectTypeKey)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get accessible project type by key
    #
    # + projectTypeKey - The key of the project type
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/project/'type/["software"|"service_desk"|"business"|"product_discovery" projectTypeKey]/accessible(map<string|string[]> headers = {}) returns ProjectType|error {
        string resourcePath = string `/api/3/project/type/${getEncodedUri(projectTypeKey)}/accessible`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get project
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if successful 
    resource isolated function get api/'3/project/[string projectIdOrKey](map<string|string[]> headers = {}, *GetProjectQueries queries) returns Project|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectIdOrKey)}`;
        map<Encoding> queryParamEncoding = {"properties": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update project
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The project details to be updated 
    # + return - Returned if the project is updated 
    resource isolated function put api/'3/project/[string projectIdOrKey](UpdateProjectDetails payload, map<string|string[]> headers = {}, *UpdateProjectQueries queries) returns Project|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectIdOrKey)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete project
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the project is deleted 
    resource isolated function delete api/'3/project/[string projectIdOrKey](map<string|string[]> headers = {}, *DeleteProjectQueries queries) returns error? {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectIdOrKey)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Archive project
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/project/[string projectIdOrKey]/archive(map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectIdOrKey)}/archive`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Set project avatar
    #
    # + projectIdOrKey - The ID or (case-sensitive) key of the project
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/project/[string projectIdOrKey]/avatar(Avatar payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectIdOrKey)}/avatar`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete project avatar
    #
    # + projectIdOrKey - The project ID or (case-sensitive) key
    # + id - The ID of the avatar
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/project/[string projectIdOrKey]/avatar/[int id](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectIdOrKey)}/avatar/${getEncodedUri(id)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Load project avatar
    #
    # + projectIdOrKey - The ID or (case-sensitive) key of the project
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/project/[string projectIdOrKey]/avatar2(http:Request request, map<string|string[]> headers = {}, *CreateProjectAvatarQueries queries) returns Avatar|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectIdOrKey)}/avatar2`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        // TODO: Update the request as needed;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get all project avatars
    #
    # + projectIdOrKey - The ID or (case-sensitive) key of the project
    # + headers - Headers to be sent with the request 
    # + return - Returned if request is successful 
    resource isolated function get api/'3/project/[string projectIdOrKey]/avatars(map<string|string[]> headers = {}) returns ProjectAvatars|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectIdOrKey)}/avatars`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get the default data classification level of a project
    #
    # + projectIdOrKey - The project ID or project key (case-sensitive)
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/project/[string projectIdOrKey]/classification\-level/default(map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectIdOrKey)}/classification-level/default`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update the default data classification level of a project
    #
    # + projectIdOrKey - The project ID or project key (case-sensitive)
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/project/[string projectIdOrKey]/classification\-level/default(UpdateDefaultProjectClassificationBean payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectIdOrKey)}/classification-level/default`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Remove the default data classification level from a project
    #
    # + projectIdOrKey - The project ID or project key (case-sensitive)
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/project/[string projectIdOrKey]/classification\-level/default(map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectIdOrKey)}/classification-level/default`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get project components paginated
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/project/[string projectIdOrKey]/component(map<string|string[]> headers = {}, *GetProjectComponentsPaginatedQueries queries) returns PageBeanComponentWithIssueCount|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectIdOrKey)}/component`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get project components
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/project/[string projectIdOrKey]/components(map<string|string[]> headers = {}, *GetProjectComponentsQueries queries) returns ProjectComponent[]|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectIdOrKey)}/components`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete project asynchronously
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/project/[string projectIdOrKey]/delete(map<string|string[]> headers = {}) returns http:Response|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectIdOrKey)}/delete`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get project features
    #
    # + projectIdOrKey - The ID or (case-sensitive) key of the project
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/project/[string projectIdOrKey]/features(map<string|string[]> headers = {}) returns ContainerForProjectFeatures|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectIdOrKey)}/features`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set project feature state
    #
    # + projectIdOrKey - The ID or (case-sensitive) key of the project
    # + featureKey - The key of the feature
    # + headers - Headers to be sent with the request 
    # + payload - Details of the feature state change 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/project/[string projectIdOrKey]/features/[string featureKey](ProjectFeatureState payload, map<string|string[]> headers = {}) returns ContainerForProjectFeatures|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectIdOrKey)}/features/${getEncodedUri(featureKey)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get project property keys
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/project/[string projectIdOrKey]/properties(map<string|string[]> headers = {}) returns PropertyKeys|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectIdOrKey)}/properties`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get project property
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + propertyKey - The project property key. Use [Get project property keys](#api-rest-api-3-project-projectIdOrKey-properties-get) to get a list of all project property keys
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/project/[string projectIdOrKey]/properties/[string propertyKey](map<string|string[]> headers = {}) returns EntityProperty|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectIdOrKey)}/properties/${getEncodedUri(propertyKey)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set project property
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + propertyKey - The key of the project property. The maximum length is 255 characters
    # + headers - Headers to be sent with the request 
    # + payload - The value of the property. The value has to be a valid, non-empty [JSON](https://tools.ietf.org/html/rfc4627) value. The maximum length of the property value is 32768 bytes 
    # + return - Returned if the project property is updated 
    resource isolated function put api/'3/project/[string projectIdOrKey]/properties/[string propertyKey](json payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectIdOrKey)}/properties/${getEncodedUri(propertyKey)}`;
        http:Request request = new;
        request.setPayload(payload, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete project property
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + propertyKey - The project property key. Use [Get project property keys](#api-rest-api-3-project-projectIdOrKey-properties-get) to get a list of all project property keys
    # + headers - Headers to be sent with the request 
    # + return - Returned if the project property is deleted 
    resource isolated function delete api/'3/project/[string projectIdOrKey]/properties/[string propertyKey](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectIdOrKey)}/properties/${getEncodedUri(propertyKey)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    resource isolated function post api/'3/project/[string projectIdOrKey](map<string|string[]> headers = {}) returns Project|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectIdOrKey)}ore`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get project roles for project
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/project/[string projectIdOrKey]/role(map<string|string[]> headers = {}) returns record {|string...;|}|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectIdOrKey)}/role`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get project role for project
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + id - The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/project/[string projectIdOrKey]/role/[int id](map<string|string[]> headers = {}, *GetProjectRoleQueries queries) returns ProjectRole|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectIdOrKey)}/role/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Set actors for project role
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + id - The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs
    # + headers - Headers to be sent with the request 
    # + payload - The groups or users to associate with the project role for this project. Provide the user account ID, group name, or group ID. As a group's name can change, use of group ID is recommended 
    # + return - Returned if the request is successful. The complete list of actors for the project is returned 
    resource isolated function put api/'3/project/[string projectIdOrKey]/role/[int id](ProjectRoleActorsUpdateBean payload, map<string|string[]> headers = {}) returns ProjectRole|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectIdOrKey)}/role/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Add actors to project role
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + id - The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs
    # + headers - Headers to be sent with the request 
    # + payload - The groups or users to associate with the project role for this project. Provide the user account ID, group name, or group ID. As a group's name can change, use of group ID is recommended 
    # + return - Returned if the request is successful. The complete list of actors for the project is returned. For example, the cURL request above adds a group, *jira-developers*. For the response below to be returned as a result of that request, the user *Mia Krystof* would have previously been added as a `user` actor for this project 
    resource isolated function post api/'3/project/[string projectIdOrKey]/role/[int id](ActorsMap payload, map<string|string[]> headers = {}) returns ProjectRole|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectIdOrKey)}/role/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete actors from project role
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + id - The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/project/[string projectIdOrKey]/role/[int id](map<string|string[]> headers = {}, *DeleteActorQueries queries) returns error? {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectIdOrKey)}/role/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get project role details
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/project/[string projectIdOrKey]/roledetails(map<string|string[]> headers = {}, *GetProjectRoleDetailsQueries queries) returns ProjectRoleDetails[]|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectIdOrKey)}/roledetails`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get all statuses for project
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/project/[string projectIdOrKey]/statuses(map<string|string[]> headers = {}) returns IssueTypeWithStatus[]|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectIdOrKey)}/statuses`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get project versions paginated
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/project/[string projectIdOrKey]/version(map<string|string[]> headers = {}, *GetProjectVersionsPaginatedQueries queries) returns PageBeanVersion|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectIdOrKey)}/version`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get project versions
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/project/[string projectIdOrKey]/versions(map<string|string[]> headers = {}, *GetProjectVersionsQueries queries) returns Version[]|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectIdOrKey)}/versions`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get project's sender email
    #
    # + projectId - The project ID
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/project/[int projectId]/email(map<string|string[]> headers = {}) returns ProjectEmailAddress|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectId)}/email`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set project's sender email
    #
    # + projectId - The project ID
    # + headers - Headers to be sent with the request 
    # + payload - The project's sender email address to be set 
    # + return - Returned if the project's sender email address is successfully set 
    resource isolated function put api/'3/project/[int projectId]/email(ProjectEmailAddress payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectId)}/email`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get project issue type hierarchy
    #
    # + projectId - The ID of the project
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/project/[int projectId]/hierarchy(map<string|string[]> headers = {}) returns ProjectIssueTypeHierarchy|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectId)}/hierarchy`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get project issue security scheme
    #
    # + projectKeyOrId - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/project/[string projectKeyOrId]/issuesecuritylevelscheme(map<string|string[]> headers = {}) returns SecurityScheme|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectKeyOrId)}/issuesecuritylevelscheme`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get project notification scheme
    #
    # + projectKeyOrId - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/project/[string projectKeyOrId]/notificationscheme(map<string|string[]> headers = {}, *GetNotificationSchemeForProjectQueries queries) returns NotificationScheme|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectKeyOrId)}/notificationscheme`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get assigned permission scheme
    #
    # + projectKeyOrId - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/project/[string projectKeyOrId]/permissionscheme(map<string|string[]> headers = {}, *GetAssignedPermissionSchemeQueries queries) returns PermissionScheme|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectKeyOrId)}/permissionscheme`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Assign permission scheme
    #
    # + projectKeyOrId - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/project/[string projectKeyOrId]/permissionscheme(IdBean payload, map<string|string[]> headers = {}, *AssignPermissionSchemeQueries queries) returns PermissionScheme|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectKeyOrId)}/permissionscheme`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get project issue security levels
    #
    # + projectKeyOrId - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/project/[string projectKeyOrId]/securitylevel(map<string|string[]> headers = {}) returns ProjectIssueSecurityLevels|error {
        string resourcePath = string `/api/3/project/${getEncodedUri(projectKeyOrId)}/securitylevel`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get all project categories
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/projectCategory(map<string|string[]> headers = {}) returns ProjectCategory[]|error {
        string resourcePath = string `/api/3/projectCategory`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create project category
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/projectCategory(ProjectCategory payload, map<string|string[]> headers = {}) returns ProjectCategory|error {
        string resourcePath = string `/api/3/projectCategory`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get project category by ID
    #
    # + id - The ID of the project category
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/projectCategory/[int id](map<string|string[]> headers = {}) returns ProjectCategory|error {
        string resourcePath = string `/api/3/projectCategory/${getEncodedUri(id)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update project category
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/projectCategory/[int id](ProjectCategory payload, map<string|string[]> headers = {}) returns UpdatedProjectCategory|error {
        string resourcePath = string `/api/3/projectCategory/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete project category
    #
    # + id - ID of the project category to delete
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/projectCategory/[int id](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/projectCategory/${getEncodedUri(id)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Validate project key
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/projectvalidate/'key(map<string|string[]> headers = {}, *ValidateProjectKeyQueries queries) returns ErrorCollection|error {
        string resourcePath = string `/api/3/projectvalidate/key`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get valid project key
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/projectvalidate/validProjectKey(map<string|string[]> headers = {}, *GetValidProjectKeyQueries queries) returns string|error {
        string resourcePath = string `/api/3/projectvalidate/validProjectKey`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get valid project name
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/projectvalidate/validProjectName(map<string|string[]> headers = {}, *GetValidProjectNameQueries queries) returns string|error {
        string resourcePath = string `/api/3/projectvalidate/validProjectName`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create resolution
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/resolution(CreateResolutionDetails payload, map<string|string[]> headers = {}) returns ResolutionId|error {
        string resourcePath = string `/api/3/resolution`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Set default resolution
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/resolution/default(SetDefaultResolutionRequest payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/resolution/default`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Move resolutions
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/resolution/move(ReorderIssueResolutionsRequest payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/resolution/move`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Search resolutions
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/resolution/search(map<string|string[]> headers = {}, *SearchResolutionsQueries queries) returns PageBeanResolutionJsonBean|error {
        string resourcePath = string `/api/3/resolution/search`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get resolution
    #
    # + id - The ID of the issue resolution value
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/resolution/[string id](map<string|string[]> headers = {}) returns Resolution|error {
        string resourcePath = string `/api/3/resolution/${getEncodedUri(id)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update resolution
    #
    # + id - The ID of the issue resolution
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/resolution/[string id](UpdateResolutionDetails payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/resolution/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete resolution
    #
    # + id - The ID of the issue resolution
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/resolution/[string id](map<string|string[]> headers = {}, *DeleteResolutionQueries queries) returns http:Response|error {
        string resourcePath = string `/api/3/resolution/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get all project roles
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/role(map<string|string[]> headers = {}) returns ProjectRole[]|error {
        string resourcePath = string `/api/3/role`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create project role
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/role(CreateUpdateRoleRequestBean payload, map<string|string[]> headers = {}) returns ProjectRole|error {
        string resourcePath = string `/api/3/role`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get project role by ID
    #
    # + id - The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/role/[int id](map<string|string[]> headers = {}) returns ProjectRole|error {
        string resourcePath = string `/api/3/role/${getEncodedUri(id)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Fully update project role
    #
    # + id - The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/role/[int id](CreateUpdateRoleRequestBean payload, map<string|string[]> headers = {}) returns ProjectRole|error {
        string resourcePath = string `/api/3/role/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Partial update project role
    #
    # + id - The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/role/[int id](CreateUpdateRoleRequestBean payload, map<string|string[]> headers = {}) returns ProjectRole|error {
        string resourcePath = string `/api/3/role/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete project role
    #
    # + id - The ID of the project role to delete. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/role/[int id](map<string|string[]> headers = {}, *DeleteProjectRoleQueries queries) returns error? {
        string resourcePath = string `/api/3/role/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get default actors for project role
    #
    # + id - The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/role/[int id]/actors(map<string|string[]> headers = {}) returns ProjectRole|error {
        string resourcePath = string `/api/3/role/${getEncodedUri(id)}/actors`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Add default actors to project role
    #
    # + id - The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/role/[int id]/actors(ActorInputBean payload, map<string|string[]> headers = {}) returns ProjectRole|error {
        string resourcePath = string `/api/3/role/${getEncodedUri(id)}/actors`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete default actors from project role
    #
    # + id - The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/role/[int id]/actors(map<string|string[]> headers = {}, *DeleteProjectRoleActorsFromRoleQueries queries) returns ProjectRole|error {
        string resourcePath = string `/api/3/role/${getEncodedUri(id)}/actors`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get screens
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/screens(map<string|string[]> headers = {}, *GetScreensQueries queries) returns PageBeanScreen|error {
        string resourcePath = string `/api/3/screens`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}, "scope": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create screen
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/screens(ScreenDetails payload, map<string|string[]> headers = {}) returns Screen|error {
        string resourcePath = string `/api/3/screens`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Add field to default screen
    #
    # + fieldId - The ID of the field
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/screens/addToDefault/[string fieldId](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/screens/addToDefault/${getEncodedUri(fieldId)}`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get bulk screen tabs
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/screens/tabs(map<string|string[]> headers = {}, *GetBulkScreenTabsQueries queries) returns json|error {
        string resourcePath = string `/api/3/screens/tabs`;
        map<Encoding> queryParamEncoding = {"screenId": {style: FORM, explode: true}, "tabId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update screen
    #
    # + screenId - The ID of the screen
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/screens/[int screenId](UpdateScreenDetails payload, map<string|string[]> headers = {}) returns Screen|error {
        string resourcePath = string `/api/3/screens/${getEncodedUri(screenId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete screen
    #
    # + screenId - The ID of the screen
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/screens/[int screenId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/screens/${getEncodedUri(screenId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get available screen fields
    #
    # + screenId - The ID of the screen
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/screens/[int screenId]/availableFields(map<string|string[]> headers = {}) returns ScreenableField[]|error {
        string resourcePath = string `/api/3/screens/${getEncodedUri(screenId)}/availableFields`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get all screen tabs
    #
    # + screenId - The ID of the screen
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/screens/[int screenId]/tabs(map<string|string[]> headers = {}, *GetAllScreenTabsQueries queries) returns ScreenableTab[]|error {
        string resourcePath = string `/api/3/screens/${getEncodedUri(screenId)}/tabs`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create screen tab
    #
    # + screenId - The ID of the screen
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/screens/[int screenId]/tabs(ScreenableTab payload, map<string|string[]> headers = {}) returns ScreenableTab|error {
        string resourcePath = string `/api/3/screens/${getEncodedUri(screenId)}/tabs`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Update screen tab
    #
    # + screenId - The ID of the screen
    # + tabId - The ID of the screen tab
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/screens/[int screenId]/tabs/[int tabId](ScreenableTab payload, map<string|string[]> headers = {}) returns ScreenableTab|error {
        string resourcePath = string `/api/3/screens/${getEncodedUri(screenId)}/tabs/${getEncodedUri(tabId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete screen tab
    #
    # + screenId - The ID of the screen
    # + tabId - The ID of the screen tab
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/screens/[int screenId]/tabs/[int tabId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/screens/${getEncodedUri(screenId)}/tabs/${getEncodedUri(tabId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get all screen tab fields
    #
    # + screenId - The ID of the screen
    # + tabId - The ID of the screen tab
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/screens/[int screenId]/tabs/[int tabId]/fields(map<string|string[]> headers = {}, *GetAllScreenTabFieldsQueries queries) returns ScreenableField[]|error {
        string resourcePath = string `/api/3/screens/${getEncodedUri(screenId)}/tabs/${getEncodedUri(tabId)}/fields`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add screen tab field
    #
    # + screenId - The ID of the screen
    # + tabId - The ID of the screen tab
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/screens/[int screenId]/tabs/[int tabId]/fields(AddFieldBean payload, map<string|string[]> headers = {}) returns ScreenableField|error {
        string resourcePath = string `/api/3/screens/${getEncodedUri(screenId)}/tabs/${getEncodedUri(tabId)}/fields`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Remove screen tab field
    #
    # + screenId - The ID of the screen
    # + tabId - The ID of the screen tab
    # + id - The ID of the field
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/screens/[int screenId]/tabs/[int tabId]/fields/[string id](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/screens/${getEncodedUri(screenId)}/tabs/${getEncodedUri(tabId)}/fields/${getEncodedUri(id)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Move screen tab field
    #
    # + screenId - The ID of the screen
    # + tabId - The ID of the screen tab
    # + id - The ID of the field
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/screens/[int screenId]/tabs/[int tabId]/fields/[string id]/move(MoveFieldBean payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/screens/${getEncodedUri(screenId)}/tabs/${getEncodedUri(tabId)}/fields/${getEncodedUri(id)}/move`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Move screen tab
    #
    # + screenId - The ID of the screen
    # + tabId - The ID of the screen tab
    # + pos - The position of tab. The base index is 0
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/screens/[int screenId]/tabs/[int tabId]/move/[int:Signed32 pos](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/screens/${getEncodedUri(screenId)}/tabs/${getEncodedUri(tabId)}/move/${getEncodedUri(pos)}`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get screen schemes
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/screenscheme(map<string|string[]> headers = {}, *GetScreenSchemesQueries queries) returns PageBeanScreenScheme|error {
        string resourcePath = string `/api/3/screenscheme`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create screen scheme
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/screenscheme(ScreenSchemeDetails payload, map<string|string[]> headers = {}) returns ScreenSchemeId|error {
        string resourcePath = string `/api/3/screenscheme`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Update screen scheme
    #
    # + screenSchemeId - The ID of the screen scheme
    # + headers - Headers to be sent with the request 
    # + payload - The screen scheme update details 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/screenscheme/[string screenSchemeId](UpdateScreenSchemeDetails payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/screenscheme/${getEncodedUri(screenSchemeId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete screen scheme
    #
    # + screenSchemeId - The ID of the screen scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the screen scheme is deleted 
    resource isolated function delete api/'3/screenscheme/[string screenSchemeId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/screenscheme/${getEncodedUri(screenSchemeId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Search for issues using JQL (GET)
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/search(map<string|string[]> headers = {}, *SearchForIssuesUsingJqlQueries queries) returns SearchResults|error {
        string resourcePath = string `/api/3/search`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: true}, "properties": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Search for issues using JQL (POST)
    #
    # + headers - Headers to be sent with the request 
    # + payload - A JSON object containing the search request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/search(SearchRequestBean payload, map<string|string[]> headers = {}) returns SearchResults|error {
        string resourcePath = string `/api/3/search`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Count issues using JQL
    #
    # + headers - Headers to be sent with the request 
    # + payload - A JSON object containing the search request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/search/approximate\-count(JQLCountRequestBean payload, map<string|string[]> headers = {}) returns JQLCountResultsBean|error {
        string resourcePath = string `/api/3/search/approximate-count`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Search issue IDs using JQL
    #
    # + headers - Headers to be sent with the request 
    # + payload - A JSON object containing the search request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/search/id(IdSearchRequestBean payload, map<string|string[]> headers = {}) returns IdSearchResults|error {
        string resourcePath = string `/api/3/search/id`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Search for issues using JQL enhanced search (GET)
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/search/jql(map<string|string[]> headers = {}) returns SearchAndReconcileResults|error {
        string resourcePath = string `/api/3/search/jql`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Search for issues using JQL enhanced search (POST)
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/search/jql(SearchAndReconcileRequestBean payload, map<string|string[]> headers = {}) returns SearchAndReconcileResults|error {
        string resourcePath = string `/api/3/search/jql`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get issue security level
    #
    # + id - The ID of the issue security level
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/securitylevel/[string id](map<string|string[]> headers = {}) returns SecurityLevel|error {
        string resourcePath = string `/api/3/securitylevel/${getEncodedUri(id)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get Jira instance info
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/serverInfo(map<string|string[]> headers = {}) returns ServerInformation|error {
        string resourcePath = string `/api/3/serverInfo`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get issue navigator default columns
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/settings/columns(map<string|string[]> headers = {}) returns ColumnItem[]|error {
        string resourcePath = string `/api/3/settings/columns`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set issue navigator default columns
    #
    # + headers - Headers to be sent with the request 
    # + request - A navigable field value 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/settings/columns(http:Request request, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/settings/columns`;
        // TODO: Update the request as needed;
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get all statuses
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/status(map<string|string[]> headers = {}) returns StatusDetails[]|error {
        string resourcePath = string `/api/3/status`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get status
    #
    # + idOrName - The ID or name of the status
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/status/[string idOrName](map<string|string[]> headers = {}) returns StatusDetails|error {
        string resourcePath = string `/api/3/status/${getEncodedUri(idOrName)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get all status categories
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/statuscategory(map<string|string[]> headers = {}) returns StatusCategory[]|error {
        string resourcePath = string `/api/3/statuscategory`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get status category
    #
    # + idOrKey - The ID or key of the status category
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/statuscategory/[string idOrKey](map<string|string[]> headers = {}) returns StatusCategory|error {
        string resourcePath = string `/api/3/statuscategory/${getEncodedUri(idOrKey)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Bulk get statuses
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/statuses(map<string|string[]> headers = {}, *GetStatusesByIdQueries queries) returns JiraStatus[]|error {
        string resourcePath = string `/api/3/statuses`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Bulk update statuses
    #
    # + headers - Headers to be sent with the request 
    # + payload - The list of statuses that will be updated 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/statuses(StatusUpdateRequest payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/statuses`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Bulk create statuses
    #
    # + headers - Headers to be sent with the request 
    # + payload - Details of the statuses being created and their scope 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/statuses(StatusCreateRequest payload, map<string|string[]> headers = {}) returns JiraStatus[]|error {
        string resourcePath = string `/api/3/statuses`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Bulk delete Statuses
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/statuses(map<string|string[]> headers = {}, *DeleteStatusesByIdQueries queries) returns json|error {
        string resourcePath = string `/api/3/statuses`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Search statuses paginated
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/statuses/search(map<string|string[]> headers = {}, *SearchQueries queries) returns PageOfStatuses|error {
        string resourcePath = string `/api/3/statuses/search`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get task
    #
    # + taskId - The ID of the task
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/task/[string taskId](map<string|string[]> headers = {}) returns TaskProgressBeanObject|error {
        string resourcePath = string `/api/3/task/${getEncodedUri(taskId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Cancel task
    #
    # + taskId - The ID of the task
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/task/[string taskId]/cancel(map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/task/${getEncodedUri(taskId)}/cancel`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get UI modifications
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/uiModifications(map<string|string[]> headers = {}, *GetUiModificationsQueries queries) returns PageBeanUiModificationDetails|error {
        string resourcePath = string `/api/3/uiModifications`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create UI modification
    #
    # + headers - Headers to be sent with the request 
    # + payload - Details of the UI modification 
    # + return - Returned if the UI modification is created 
    resource isolated function post api/'3/uiModifications(CreateUiModificationDetails payload, map<string|string[]> headers = {}) returns UiModificationIdentifiers|error {
        string resourcePath = string `/api/3/uiModifications`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Update UI modification
    #
    # + uiModificationId - The ID of the UI modification
    # + headers - Headers to be sent with the request 
    # + payload - Details of the UI modification 
    # + return - Returned if the UI modification is updated 
    resource isolated function put api/'3/uiModifications/[string uiModificationId](UpdateUiModificationDetails payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/uiModifications/${getEncodedUri(uiModificationId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete UI modification
    #
    # + uiModificationId - The ID of the UI modification
    # + headers - Headers to be sent with the request 
    # + return - Returned if the UI modification is deleted 
    resource isolated function delete api/'3/uiModifications/[string uiModificationId](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/uiModifications/${getEncodedUri(uiModificationId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get avatars
    #
    # + 'type - The avatar type
    # + entityId - The ID of the item the avatar is associated with
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/universal_avatar/'type/["project"|"issuetype"|"priority" 'type]/owner/[string entityId](map<string|string[]> headers = {}) returns Avatars|error {
        string resourcePath = string `/api/3/universal_avatar/type/${getEncodedUri('type)}/owner/${getEncodedUri(entityId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Load avatar
    #
    # + 'type - The avatar type
    # + entityId - The ID of the item the avatar is associated with
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/universal_avatar/'type/["project"|"issuetype"|"priority" 'type]/owner/[string entityId](http:Request request, map<string|string[]> headers = {}, *StoreAvatarQueries queries) returns Avatar|error {
        string resourcePath = string `/api/3/universal_avatar/type/${getEncodedUri('type)}/owner/${getEncodedUri(entityId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        // TODO: Update the request as needed;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete avatar
    #
    # + 'type - The avatar type
    # + owningObjectId - The ID of the item the avatar is associated with
    # + id - The ID of the avatar
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/universal_avatar/'type/["project"|"issuetype"|"priority" 'type]/owner/[string owningObjectId]/avatar/[int id](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/universal_avatar/type/${getEncodedUri('type)}/owner/${getEncodedUri(owningObjectId)}/avatar/${getEncodedUri(id)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get avatar image by type
    #
    # + 'type - The icon type of the avatar
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/universal_avatar/view/'type/["issuetype"|"project"|"priority" 'type](map<string|string[]> headers = {}, *GetAvatarImageByTypeQueries queries) returns StreamingResponseBody|error {
        string resourcePath = string `/api/3/universal_avatar/view/type/${getEncodedUri('type)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get avatar image by ID
    #
    # + 'type - The icon type of the avatar
    # + id - The ID of the avatar
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/universal_avatar/view/'type/["issuetype"|"project"|"priority" 'type]/avatar/[int id](map<string|string[]> headers = {}, *GetAvatarImageByIDQueries queries) returns StreamingResponseBody|error {
        string resourcePath = string `/api/3/universal_avatar/view/type/${getEncodedUri('type)}/avatar/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get avatar image by owner
    #
    # + 'type - The icon type of the avatar
    # + entityId - The ID of the project or issue type the avatar belongs to
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/universal_avatar/view/'type/["issuetype"|"project"|"priority" 'type]/owner/[string entityId](map<string|string[]> headers = {}, *GetAvatarImageByOwnerQueries queries) returns StreamingResponseBody|error {
        string resourcePath = string `/api/3/universal_avatar/view/type/${getEncodedUri('type)}/owner/${getEncodedUri(entityId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get user
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/user(map<string|string[]> headers = {}, *GetUserQueries queries) returns User|error {
        string resourcePath = string `/api/3/user`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create user
    #
    # + headers - Headers to be sent with the request 
    # + payload - Details about the user to be created 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/user(NewUserDetails payload, map<string|string[]> headers = {}) returns User|error {
        string resourcePath = string `/api/3/user`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete user
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/user(map<string|string[]> headers = {}, *RemoveUserQueries queries) returns error? {
        string resourcePath = string `/api/3/user`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Find users assignable to projects
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/user/assignable/multiProjectSearch(map<string|string[]> headers = {}, *FindBulkAssignableUsersQueries queries) returns User[]|error {
        string resourcePath = string `/api/3/user/assignable/multiProjectSearch`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Find users assignable to issues
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/user/assignable/search(map<string|string[]> headers = {}, *FindAssignableUsersQueries queries) returns User[]|error {
        string resourcePath = string `/api/3/user/assignable/search`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Bulk get users
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/user/bulk(map<string|string[]> headers = {}, *BulkGetUsersQueries queries) returns PageBeanUser|error {
        string resourcePath = string `/api/3/user/bulk`;
        map<Encoding> queryParamEncoding = {"username": {style: FORM, explode: true}, "key": {style: FORM, explode: true}, "accountId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get account IDs for users
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/user/bulk/migration(map<string|string[]> headers = {}, *BulkGetUsersMigrationQueries queries) returns UserMigrationBean[]|error {
        string resourcePath = string `/api/3/user/bulk/migration`;
        map<Encoding> queryParamEncoding = {"username": {style: FORM, explode: true}, "key": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get user default columns
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/user/columns(map<string|string[]> headers = {}, *GetUserDefaultColumnsQueries queries) returns ColumnItem[]|error {
        string resourcePath = string `/api/3/user/columns`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Set user default columns
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - The ID of a column to set. To set multiple columns, send multiple `columns` parameters 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/user/columns(http:Request request, map<string|string[]> headers = {}, *SetUserColumnsQueries queries) returns json|error {
        string resourcePath = string `/api/3/user/columns`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        // TODO: Update the request as needed;
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Reset user default columns
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/user/columns(map<string|string[]> headers = {}, *ResetUserColumnsQueries queries) returns error? {
        string resourcePath = string `/api/3/user/columns`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get user email
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/user/email(map<string|string[]> headers = {}, *GetUserEmailQueries queries) returns UnrestrictedUserEmail|error {
        string resourcePath = string `/api/3/user/email`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get user email bulk
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/user/email/bulk(map<string|string[]> headers = {}, *GetUserEmailBulkQueries queries) returns UnrestrictedUserEmail|error {
        string resourcePath = string `/api/3/user/email/bulk`;
        map<Encoding> queryParamEncoding = {"accountId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get user groups
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/user/groups(map<string|string[]> headers = {}, *GetUserGroupsQueries queries) returns GroupName[]|error {
        string resourcePath = string `/api/3/user/groups`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Find users with permissions
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/user/permission/search(map<string|string[]> headers = {}, *FindUsersWithAllPermissionsQueries queries) returns User[]|error {
        string resourcePath = string `/api/3/user/permission/search`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Find users for picker
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/user/picker(map<string|string[]> headers = {}, *FindUsersForPickerQueries queries) returns FoundUsers|error {
        string resourcePath = string `/api/3/user/picker`;
        map<Encoding> queryParamEncoding = {"exclude": {style: FORM, explode: true}, "excludeAccountIds": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get user property keys
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/user/properties(map<string|string[]> headers = {}, *GetUserPropertyKeysQueries queries) returns PropertyKeys|error {
        string resourcePath = string `/api/3/user/properties`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get user property
    #
    # + propertyKey - The key of the user's property
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/user/properties/[string propertyKey](map<string|string[]> headers = {}, *GetUserPropertyQueries queries) returns EntityProperty|error {
        string resourcePath = string `/api/3/user/properties/${getEncodedUri(propertyKey)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Set user property
    #
    # + propertyKey - The key of the user's property. The maximum length is 255 characters
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The value of the property. The value has to be a valid, non-empty [JSON](https://tools.ietf.org/html/rfc4627) value. The maximum length of the property value is 32768 bytes 
    # + return - Returned if the user property is updated 
    resource isolated function put api/'3/user/properties/[string propertyKey](json payload, map<string|string[]> headers = {}, *SetUserPropertyQueries queries) returns json|error {
        string resourcePath = string `/api/3/user/properties/${getEncodedUri(propertyKey)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        request.setPayload(payload, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete user property
    #
    # + propertyKey - The key of the user's property
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the user property is deleted 
    resource isolated function delete api/'3/user/properties/[string propertyKey](map<string|string[]> headers = {}, *DeleteUserPropertyQueries queries) returns error? {
        string resourcePath = string `/api/3/user/properties/${getEncodedUri(propertyKey)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Find users
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/user/search(map<string|string[]> headers = {}, *FindUsersQueries queries) returns User[]|error {
        string resourcePath = string `/api/3/user/search`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Find users by query
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/user/search/query(map<string|string[]> headers = {}, *FindUsersByQueryQueries queries) returns PageBeanUser|error {
        string resourcePath = string `/api/3/user/search/query`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Find user keys by query
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/user/search/query/'key(map<string|string[]> headers = {}, *FindUserKeysByQueryQueries queries) returns PageBeanUserKey|error {
        string resourcePath = string `/api/3/user/search/query/key`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Find users with browse permission
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/user/viewissue/search(map<string|string[]> headers = {}, *FindUsersWithBrowsePermissionQueries queries) returns User[]|error {
        string resourcePath = string `/api/3/user/viewissue/search`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get all users default
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/users(map<string|string[]> headers = {}, *GetAllUsersDefaultQueries queries) returns User[]|error {
        string resourcePath = string `/api/3/users`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get all users
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/users/search(map<string|string[]> headers = {}, *GetAllUsersQueries queries) returns User[]|error {
        string resourcePath = string `/api/3/users/search`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create version
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/version(Version payload, map<string|string[]> headers = {}) returns Version|error {
        string resourcePath = string `/api/3/version`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get version
    #
    # + id - The ID of the version
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/version/[string id](map<string|string[]> headers = {}, *GetVersionQueries queries) returns Version|error {
        string resourcePath = string `/api/3/version/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update version
    #
    # + id - The ID of the version
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/version/[string id](Version payload, map<string|string[]> headers = {}) returns Version|error {
        string resourcePath = string `/api/3/version/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Merge versions
    #
    # + id - The ID of the version to delete
    # + moveIssuesTo - The ID of the version to merge into
    # + headers - Headers to be sent with the request 
    # + return - Returned if the version is deleted 
    resource isolated function put api/'3/version/[string id]/mergeto/[string moveIssuesTo](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/version/${getEncodedUri(id)}/mergeto/${getEncodedUri(moveIssuesTo)}`;
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Move version
    #
    # + id - The ID of the version to be moved
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/version/[string id]/move(VersionMoveBean payload, map<string|string[]> headers = {}) returns Version|error {
        string resourcePath = string `/api/3/version/${getEncodedUri(id)}/move`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get version's related issues count
    #
    # + id - The ID of the version
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/version/[string id]/relatedIssueCounts(map<string|string[]> headers = {}) returns VersionIssueCounts|error {
        string resourcePath = string `/api/3/version/${getEncodedUri(id)}/relatedIssueCounts`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get related work
    #
    # + id - The ID of the version
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/version/[string id]/relatedwork(map<string|string[]> headers = {}) returns VersionRelatedWork[]|error {
        string resourcePath = string `/api/3/version/${getEncodedUri(id)}/relatedwork`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update related work
    #
    # + id - The ID of the version to update the related work on. For the related work id, pass it to the input JSON
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful together with updated related work 
    resource isolated function put api/'3/version/[string id]/relatedwork(VersionRelatedWork payload, map<string|string[]> headers = {}) returns VersionRelatedWork|error {
        string resourcePath = string `/api/3/version/${getEncodedUri(id)}/relatedwork`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Create related work
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/version/[string id]/relatedwork(VersionRelatedWork payload, map<string|string[]> headers = {}) returns VersionRelatedWork|error {
        string resourcePath = string `/api/3/version/${getEncodedUri(id)}/relatedwork`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete and replace version
    #
    # + id - The ID of the version
    # + headers - Headers to be sent with the request 
    # + return - Returned if the version is deleted 
    resource isolated function post api/'3/version/[string id]/removeAndSwap(DeleteAndReplaceVersionBean payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/version/${getEncodedUri(id)}/removeAndSwap`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get version's unresolved issues count
    #
    # + id - The ID of the version
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/version/[string id]/unresolvedIssueCount(map<string|string[]> headers = {}) returns VersionUnresolvedIssuesCount|error {
        string resourcePath = string `/api/3/version/${getEncodedUri(id)}/unresolvedIssueCount`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete related work
    #
    # + versionId - The ID of the version that the target related work belongs to
    # + relatedWorkId - The ID of the related work to delete
    # + headers - Headers to be sent with the request 
    # + return - Returned if the related work is deleted 
    resource isolated function delete api/'3/version/[string versionId]/relatedwork/[string relatedWorkId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/version/${getEncodedUri(versionId)}/relatedwork/${getEncodedUri(relatedWorkId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get dynamic webhooks for app
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/webhook(map<string|string[]> headers = {}, *GetDynamicWebhooksForAppQueries queries) returns PageBeanWebhook|error {
        string resourcePath = string `/api/3/webhook`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Register dynamic webhooks
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/webhook(WebhookRegistrationDetails payload, map<string|string[]> headers = {}) returns ContainerForRegisteredWebhooks|error {
        string resourcePath = string `/api/3/webhook`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete webhooks by ID
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/webhook(ContainerForWebhookIDs payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/webhook`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->delete(resourcePath, request, headers);
    }

    # Get failed webhooks
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/webhook/failed(map<string|string[]> headers = {}, *GetFailedWebhooksQueries queries) returns FailedWebhooks|error {
        string resourcePath = string `/api/3/webhook/failed`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Extend webhook life
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/webhook/refresh(ContainerForWebhookIDs payload, map<string|string[]> headers = {}) returns WebhooksExpirationDate|error {
        string resourcePath = string `/api/3/webhook/refresh`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get workflow transition rule configurations
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/workflow/rule/config(map<string|string[]> headers = {}, *GetWorkflowTransitionRuleConfigurationsQueries queries) returns PageBeanWorkflowTransitionRules|error {
        string resourcePath = string `/api/3/workflow/rule/config`;
        map<Encoding> queryParamEncoding = {"types": {style: FORM, explode: true}, "keys": {style: FORM, explode: true}, "workflowNames": {style: FORM, explode: true}, "withTags": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update workflow transition rule configurations
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/workflow/rule/config(WorkflowTransitionRulesUpdate payload, map<string|string[]> headers = {}) returns WorkflowTransitionRulesUpdateErrors|error {
        string resourcePath = string `/api/3/workflow/rule/config`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete workflow transition rule configurations
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/workflow/rule/config/delete(WorkflowsWithTransitionRulesDetails payload, map<string|string[]> headers = {}) returns WorkflowTransitionRulesUpdateErrors|error {
        string resourcePath = string `/api/3/workflow/rule/config/delete`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get workflows paginated
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/workflow/search(map<string|string[]> headers = {}, *GetWorkflowsPaginatedQueries queries) returns PageBeanWorkflow|error {
        string resourcePath = string `/api/3/workflow/search`;
        map<Encoding> queryParamEncoding = {"workflowName": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get workflow transition properties
    #
    # + transitionId - The ID of the transition. To get the ID, view the workflow in text mode in the Jira administration console. The ID is shown next to the transition
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response 
    resource isolated function get api/'3/workflow/transitions/[int transitionId]/properties(map<string|string[]> headers = {}, *GetWorkflowTransitionPropertiesQueries queries) returns WorkflowTransitionProperty|error {
        string resourcePath = string `/api/3/workflow/transitions/${getEncodedUri(transitionId)}/properties`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update workflow transition property
    #
    # + transitionId - The ID of the transition. To get the ID, view the workflow in text mode in the Jira admin settings. The ID is shown next to the transition
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response 
    resource isolated function put api/'3/workflow/transitions/[int transitionId]/properties(WorkflowTransitionProperty payload, map<string|string[]> headers = {}, *UpdateWorkflowTransitionPropertyQueries queries) returns WorkflowTransitionProperty|error? {
        string resourcePath = string `/api/3/workflow/transitions/${getEncodedUri(transitionId)}/properties`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Create workflow transition property
    #
    # + transitionId - The ID of the transition. To get the ID, view the workflow in text mode in the Jira admin settings. The ID is shown next to the transition
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response 
    resource isolated function post api/'3/workflow/transitions/[int transitionId]/properties(WorkflowTransitionProperty payload, map<string|string[]> headers = {}, *CreateWorkflowTransitionPropertyQueries queries) returns WorkflowTransitionProperty|error {
        string resourcePath = string `/api/3/workflow/transitions/${getEncodedUri(transitionId)}/properties`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete workflow transition property
    #
    # + transitionId - The ID of the transition. To get the ID, view the workflow in text mode in the Jira admin settings. The ID is shown next to the transition
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response 
    resource isolated function delete api/'3/workflow/transitions/[int transitionId]/properties(map<string|string[]> headers = {}, *DeleteWorkflowTransitionPropertyQueries queries) returns error? {
        string resourcePath = string `/api/3/workflow/transitions/${getEncodedUri(transitionId)}/properties`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Delete inactive workflow
    #
    # + entityId - The entity ID of the workflow
    # + headers - Headers to be sent with the request 
    # + return - Returned if the workflow is deleted 
    resource isolated function delete api/'3/workflow/[string entityId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/workflow/${getEncodedUri(entityId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Bulk get workflows
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/workflows(WorkflowReadRequest payload, map<string|string[]> headers = {}, *ReadWorkflowsQueries queries) returns WorkflowReadResponse|error {
        string resourcePath = string `/api/3/workflows`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get available workflow capabilities
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/workflows/capabilities(map<string|string[]> headers = {}, *WorkflowCapabilitiesQueries queries) returns WorkflowCapabilities|error {
        string resourcePath = string `/api/3/workflows/capabilities`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Bulk create workflows
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/workflows/create(WorkflowCreateRequest payload, map<string|string[]> headers = {}) returns WorkflowCreateResponse|error {
        string resourcePath = string `/api/3/workflows/create`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Validate create workflows
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/workflows/create/validation(WorkflowCreateValidateRequest payload, map<string|string[]> headers = {}) returns WorkflowValidationErrorList|error {
        string resourcePath = string `/api/3/workflows/create/validation`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Bulk update workflows
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/workflows/update(WorkflowUpdateRequest payload, map<string|string[]> headers = {}, *UpdateWorkflowsQueries queries) returns WorkflowUpdateResponse|error {
        string resourcePath = string `/api/3/workflows/update`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Validate update workflows
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/workflows/update/validation(WorkflowUpdateValidateRequestBean payload, map<string|string[]> headers = {}) returns WorkflowValidationErrorList|error {
        string resourcePath = string `/api/3/workflows/update/validation`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get all workflow schemes
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/workflowscheme(map<string|string[]> headers = {}, *GetAllWorkflowSchemesQueries queries) returns PageBeanWorkflowScheme|error {
        string resourcePath = string `/api/3/workflowscheme`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create workflow scheme
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/workflowscheme(WorkflowScheme payload, map<string|string[]> headers = {}) returns WorkflowScheme|error {
        string resourcePath = string `/api/3/workflowscheme`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get workflow scheme project associations
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/workflowscheme/project(map<string|string[]> headers = {}, *GetWorkflowSchemeProjectAssociationsQueries queries) returns ContainerOfWorkflowSchemeAssociations|error {
        string resourcePath = string `/api/3/workflowscheme/project`;
        map<Encoding> queryParamEncoding = {"projectId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Assign workflow scheme to project
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/workflowscheme/project(WorkflowSchemeProjectAssociation payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/workflowscheme/project`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Bulk get workflow schemes
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/workflowscheme/read(WorkflowSchemeReadRequest payload, map<string|string[]> headers = {}, *ReadWorkflowSchemesQueries queries) returns WorkflowSchemeReadResponse[]|error {
        string resourcePath = string `/api/3/workflowscheme/read`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Update workflow scheme
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful and there is no asynchronous task 
    resource isolated function post api/'3/workflowscheme/update(WorkflowSchemeUpdateRequest payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/workflowscheme/update`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get required status mappings for workflow scheme update
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/workflowscheme/update/mappings(WorkflowSchemeUpdateRequiredMappingsRequest payload, map<string|string[]> headers = {}) returns WorkflowSchemeUpdateRequiredMappingsResponse|error {
        string resourcePath = string `/api/3/workflowscheme/update/mappings`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get workflow scheme
    #
    # + id - The ID of the workflow scheme. Find this ID by editing the desired workflow scheme in Jira. The ID is shown in the URL as `schemeId`. For example, *schemeId=10301*
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/workflowscheme/[int id](map<string|string[]> headers = {}, *GetWorkflowSchemeQueries queries) returns WorkflowScheme|error {
        string resourcePath = string `/api/3/workflowscheme/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Classic update workflow scheme
    #
    # + id - The ID of the workflow scheme. Find this ID by editing the desired workflow scheme in Jira. The ID is shown in the URL as `schemeId`. For example, *schemeId=10301*
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/workflowscheme/[int id](WorkflowScheme payload, map<string|string[]> headers = {}) returns WorkflowScheme|error {
        string resourcePath = string `/api/3/workflowscheme/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete workflow scheme
    #
    # + id - The ID of the workflow scheme. Find this ID by editing the desired workflow scheme in Jira. The ID is shown in the URL as `schemeId`. For example, *schemeId=10301*
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/workflowscheme/[int id](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/api/3/workflowscheme/${getEncodedUri(id)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Create draft workflow scheme
    #
    # + id - The ID of the active workflow scheme that the draft is created from
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/workflowscheme/[int id]/createdraft(map<string|string[]> headers = {}) returns WorkflowScheme|error {
        string resourcePath = string `/api/3/workflowscheme/${getEncodedUri(id)}/createdraft`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get default workflow
    #
    # + id - The ID of the workflow scheme
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/workflowscheme/[int id]/default(map<string|string[]> headers = {}, *GetDefaultWorkflowQueries queries) returns DefaultWorkflow|error {
        string resourcePath = string `/api/3/workflowscheme/${getEncodedUri(id)}/default`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update default workflow
    #
    # + id - The ID of the workflow scheme
    # + headers - Headers to be sent with the request 
    # + payload - The new default workflow 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/workflowscheme/[int id]/default(DefaultWorkflow payload, map<string|string[]> headers = {}) returns WorkflowScheme|error {
        string resourcePath = string `/api/3/workflowscheme/${getEncodedUri(id)}/default`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete default workflow
    #
    # + id - The ID of the workflow scheme
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/workflowscheme/[int id]/default(map<string|string[]> headers = {}, *DeleteDefaultWorkflowQueries queries) returns WorkflowScheme|error {
        string resourcePath = string `/api/3/workflowscheme/${getEncodedUri(id)}/default`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get draft workflow scheme
    #
    # + id - The ID of the active workflow scheme that the draft was created from
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/workflowscheme/[int id]/draft(map<string|string[]> headers = {}) returns WorkflowScheme|error {
        string resourcePath = string `/api/3/workflowscheme/${getEncodedUri(id)}/draft`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update draft workflow scheme
    #
    # + id - The ID of the active workflow scheme that the draft was created from
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/workflowscheme/[int id]/draft(WorkflowScheme payload, map<string|string[]> headers = {}) returns WorkflowScheme|error {
        string resourcePath = string `/api/3/workflowscheme/${getEncodedUri(id)}/draft`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete draft workflow scheme
    #
    # + id - The ID of the active workflow scheme that the draft was created from
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/workflowscheme/[int id]/draft(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/3/workflowscheme/${getEncodedUri(id)}/draft`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get draft default workflow
    #
    # + id - The ID of the workflow scheme that the draft belongs to
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/workflowscheme/[int id]/draft/default(map<string|string[]> headers = {}) returns DefaultWorkflow|error {
        string resourcePath = string `/api/3/workflowscheme/${getEncodedUri(id)}/draft/default`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update draft default workflow
    #
    # + id - The ID of the workflow scheme that the draft belongs to
    # + headers - Headers to be sent with the request 
    # + payload - The object for the new default workflow 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/workflowscheme/[int id]/draft/default(DefaultWorkflow payload, map<string|string[]> headers = {}) returns WorkflowScheme|error {
        string resourcePath = string `/api/3/workflowscheme/${getEncodedUri(id)}/draft/default`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete draft default workflow
    #
    # + id - The ID of the workflow scheme that the draft belongs to
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/workflowscheme/[int id]/draft/default(map<string|string[]> headers = {}) returns WorkflowScheme|error {
        string resourcePath = string `/api/3/workflowscheme/${getEncodedUri(id)}/draft/default`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get workflow for issue type in draft workflow scheme
    #
    # + id - The ID of the workflow scheme that the draft belongs to
    # + issueType - The ID of the issue type
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/workflowscheme/[int id]/draft/issuetype/[string issueType](map<string|string[]> headers = {}) returns IssueTypeWorkflowMapping|error {
        string resourcePath = string `/api/3/workflowscheme/${getEncodedUri(id)}/draft/issuetype/${getEncodedUri(issueType)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set workflow for issue type in draft workflow scheme
    #
    # + id - The ID of the workflow scheme that the draft belongs to
    # + issueType - The ID of the issue type
    # + headers - Headers to be sent with the request 
    # + payload - The issue type-project mapping 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/workflowscheme/[int id]/draft/issuetype/[string issueType](IssueTypeWorkflowMapping payload, map<string|string[]> headers = {}) returns WorkflowScheme|error {
        string resourcePath = string `/api/3/workflowscheme/${getEncodedUri(id)}/draft/issuetype/${getEncodedUri(issueType)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete workflow for issue type in draft workflow scheme
    #
    # + id - The ID of the workflow scheme that the draft belongs to
    # + issueType - The ID of the issue type
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/workflowscheme/[int id]/draft/issuetype/[string issueType](map<string|string[]> headers = {}) returns WorkflowScheme|error {
        string resourcePath = string `/api/3/workflowscheme/${getEncodedUri(id)}/draft/issuetype/${getEncodedUri(issueType)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Publish draft workflow scheme
    #
    # + id - The ID of the workflow scheme that the draft belongs to
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Details of the status mappings 
    # + return - Returned if the request is only for validation and is successful 
    resource isolated function post api/'3/workflowscheme/[int id]/draft/publish(PublishDraftWorkflowScheme payload, map<string|string[]> headers = {}, *PublishDraftWorkflowSchemeQueries queries) returns error? {
        string resourcePath = string `/api/3/workflowscheme/${getEncodedUri(id)}/draft/publish`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get issue types for workflows in draft workflow scheme
    #
    # + id - The ID of the workflow scheme that the draft belongs to
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/workflowscheme/[int id]/draft/workflow(map<string|string[]> headers = {}, *GetDraftWorkflowQueries queries) returns IssueTypesWorkflowMapping|error {
        string resourcePath = string `/api/3/workflowscheme/${getEncodedUri(id)}/draft/workflow`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Set issue types for workflow in workflow scheme
    #
    # + id - The ID of the workflow scheme that the draft belongs to
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/workflowscheme/[int id]/draft/workflow(IssueTypesWorkflowMapping payload, map<string|string[]> headers = {}, *UpdateDraftWorkflowMappingQueries queries) returns WorkflowScheme|error {
        string resourcePath = string `/api/3/workflowscheme/${getEncodedUri(id)}/draft/workflow`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete issue types for workflow in draft workflow scheme
    #
    # + id - The ID of the workflow scheme that the draft belongs to
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/workflowscheme/[int id]/draft/workflow(map<string|string[]> headers = {}, *DeleteDraftWorkflowMappingQueries queries) returns error? {
        string resourcePath = string `/api/3/workflowscheme/${getEncodedUri(id)}/draft/workflow`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get workflow for issue type in workflow scheme
    #
    # + id - The ID of the workflow scheme
    # + issueType - The ID of the issue type
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/workflowscheme/[int id]/issuetype/[string issueType](map<string|string[]> headers = {}, *GetWorkflowSchemeIssueTypeQueries queries) returns IssueTypeWorkflowMapping|error {
        string resourcePath = string `/api/3/workflowscheme/${getEncodedUri(id)}/issuetype/${getEncodedUri(issueType)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Set workflow for issue type in workflow scheme
    #
    # + id - The ID of the workflow scheme
    # + issueType - The ID of the issue type
    # + headers - Headers to be sent with the request 
    # + payload - The issue type-project mapping 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/workflowscheme/[int id]/issuetype/[string issueType](IssueTypeWorkflowMapping payload, map<string|string[]> headers = {}) returns WorkflowScheme|error {
        string resourcePath = string `/api/3/workflowscheme/${getEncodedUri(id)}/issuetype/${getEncodedUri(issueType)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete workflow for issue type in workflow scheme
    #
    # + id - The ID of the workflow scheme
    # + issueType - The ID of the issue type
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/workflowscheme/[int id]/issuetype/[string issueType](map<string|string[]> headers = {}, *DeleteWorkflowSchemeIssueTypeQueries queries) returns WorkflowScheme|error {
        string resourcePath = string `/api/3/workflowscheme/${getEncodedUri(id)}/issuetype/${getEncodedUri(issueType)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get issue types for workflows in workflow scheme
    #
    # + id - The ID of the workflow scheme
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/workflowscheme/[int id]/workflow(map<string|string[]> headers = {}, *GetWorkflowQueries queries) returns IssueTypesWorkflowMapping|error {
        string resourcePath = string `/api/3/workflowscheme/${getEncodedUri(id)}/workflow`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Set issue types for workflow in workflow scheme
    #
    # + id - The ID of the workflow scheme
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put api/'3/workflowscheme/[int id]/workflow(IssueTypesWorkflowMapping payload, map<string|string[]> headers = {}, *UpdateWorkflowMappingQueries queries) returns WorkflowScheme|error {
        string resourcePath = string `/api/3/workflowscheme/${getEncodedUri(id)}/workflow`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete issue types for workflow in workflow scheme
    #
    # + id - The ID of the workflow scheme
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete api/'3/workflowscheme/[int id]/workflow(map<string|string[]> headers = {}, *DeleteWorkflowMappingQueries queries) returns error? {
        string resourcePath = string `/api/3/workflowscheme/${getEncodedUri(id)}/workflow`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get IDs of deleted worklogs
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/worklog/deleted(map<string|string[]> headers = {}, *GetIdsOfWorklogsDeletedSinceQueries queries) returns ChangedWorklogs|error {
        string resourcePath = string `/api/3/worklog/deleted`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get worklogs
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - A JSON object containing a list of worklog IDs 
    # + return - Returned if the request is successful 
    resource isolated function post api/'3/worklog/list(WorklogIdsRequestBean payload, map<string|string[]> headers = {}, *GetWorklogsForIdsQueries queries) returns Worklog[]|error {
        string resourcePath = string `/api/3/worklog/list`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get IDs of updated worklogs
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get api/'3/worklog/updated(map<string|string[]> headers = {}, *GetIdsOfWorklogsModifiedSinceQueries queries) returns ChangedWorklogs|error {
        string resourcePath = string `/api/3/worklog/updated`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get app properties
    #
    # + addonKey - The key of the app, as defined in its descriptor
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get atlassian\-connect/'1/addons/[string addonKey]/properties(map<string|string[]> headers = {}) returns PropertyKeys|error {
        string resourcePath = string `/atlassian-connect/1/addons/${getEncodedUri(addonKey)}/properties`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get app property
    #
    # + addonKey - The key of the app, as defined in its descriptor
    # + propertyKey - The key of the property
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get atlassian\-connect/'1/addons/[string addonKey]/properties/[string propertyKey](map<string|string[]> headers = {}) returns EntityProperty|error {
        string resourcePath = string `/atlassian-connect/1/addons/${getEncodedUri(addonKey)}/properties/${getEncodedUri(propertyKey)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set app property
    #
    # + addonKey - The key of the app, as defined in its descriptor
    # + propertyKey - The key of the property
    # + headers - Headers to be sent with the request 
    # + return - Returned if the property is updated 
    resource isolated function put atlassian\-connect/'1/addons/[string addonKey]/properties/[string propertyKey](json payload, map<string|string[]> headers = {}) returns OperationMessage|error {
        string resourcePath = string `/atlassian-connect/1/addons/${getEncodedUri(addonKey)}/properties/${getEncodedUri(propertyKey)}`;
        http:Request request = new;
        request.setPayload(payload, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete app property
    #
    # + addonKey - The key of the app, as defined in its descriptor
    # + propertyKey - The key of the property
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete atlassian\-connect/'1/addons/[string addonKey]/properties/[string propertyKey](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/atlassian-connect/1/addons/${getEncodedUri(addonKey)}/properties/${getEncodedUri(propertyKey)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get modules
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get atlassian\-connect/'1/app/module/dynamic(map<string|string[]> headers = {}) returns ConnectModules|error {
        string resourcePath = string `/atlassian-connect/1/app/module/dynamic`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Register modules
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post atlassian\-connect/'1/app/module/dynamic(ConnectModules payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/atlassian-connect/1/app/module/dynamic`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Remove modules
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete atlassian\-connect/'1/app/module/dynamic(map<string|string[]> headers = {}, *DynamicModulesResourceRemoveModulesDeleteQueries queries) returns error? {
        string resourcePath = string `/atlassian-connect/1/app/module/dynamic`;
        map<Encoding> queryParamEncoding = {"moduleKey": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Bulk update custom field value
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put atlassian\-connect/'1/migration/'field(AppIssueFieldValueUpdateResourceUpdateIssueFieldsPutHeaders headers, ConnectCustomFieldValues payload) returns json|error {
        string resourcePath = string `/atlassian-connect/1/migration/field`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Bulk update entity properties
    #
    # + entityType - The type indicating the object that contains the entity properties
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put atlassian\-connect/'1/migration/properties/["IssueProperty"|"CommentProperty"|"DashboardItemProperty"|"IssueTypeProperty"|"ProjectProperty"|"UserProperty"|"WorklogProperty"|"BoardProperty"|"SprintProperty" entityType](MigrationResourceUpdateEntityPropertiesValuePutHeaders headers, EntityPropertyDetails[] payload) returns error? {
        string resourcePath = string `/atlassian-connect/1/migration/properties/${getEncodedUri(entityType)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Get workflow transition rule configurations
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post atlassian\-connect/'1/migration/workflow/rule/search(MigrationResourceWorkflowRuleSearchPostHeaders headers, WorkflowRulesSearch payload) returns WorkflowRulesSearchDetails|error {
        string resourcePath = string `/atlassian-connect/1/migration/workflow/rule/search`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Retrieve the attributes of service registries
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get atlassian\-connect/'1/service\-registry(map<string|string[]> headers = {}, *ServiceRegistryResourceServicesGetQueries queries) returns ServiceRegistry[]|error {
        string resourcePath = string `/atlassian-connect/1/service-registry`;
        map<Encoding> queryParamEncoding = {"serviceIds": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Set app property (Forge)
    #
    # + propertyKey - The key of the property
    # + headers - Headers to be sent with the request 
    # + return - Returned if the property is updated 
    resource isolated function put forge/'1/app/properties/[string propertyKey](json payload, map<string|string[]> headers = {}) returns OperationMessage|error {
        string resourcePath = string `/forge/1/app/properties/${getEncodedUri(propertyKey)}`;
        http:Request request = new;
        request.setPayload(payload, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete app property (Forge)
    #
    # + propertyKey - The key of the property
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete forge/'1/app/properties/[string propertyKey](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/forge/1/app/properties/${getEncodedUri(propertyKey)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }
}
