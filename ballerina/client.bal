// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

// Copyright (c) 2025, WSO2 LLC. (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/data.jsondata;
import ballerina/http;
import ballerina/mime;

# Jira Cloud platform REST API documentation
public isolated client class Client {
    final http:Client clientEp;
    # Gets invoked to initialize the `connector`.
    #
    # + config - The configurations to be used when initializing the `connector` 
    # + serviceUrl - URL of the target service 
    # + return - An error if connector initialization failed 
    public isolated function init(ConnectionConfig config, string serviceUrl = "https://your-domain.atlassian.net/rest/api/'3") returns error? {
        http:ClientConfiguration httpClientConfig = {auth: config.auth, httpVersion: config.httpVersion, http1Settings: config.http1Settings, http2Settings: config.http2Settings, timeout: config.timeout, forwarded: config.forwarded, followRedirects: config.followRedirects, poolConfig: config.poolConfig, cache: config.cache, compression: config.compression, circuitBreaker: config.circuitBreaker, retryConfig: config.retryConfig, cookieConfig: config.cookieConfig, responseLimits: config.responseLimits, secureSocket: config.secureSocket, proxy: config.proxy, socketConfig: config.socketConfig, validation: config.validation, laxDataBinding: config.laxDataBinding};
        self.clientEp = check new (serviceUrl, httpClientConfig);
    }

    # Get issue type screen schemes
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issuetypescreenscheme(map<string|string[]> headers = {}, *GetIssueTypeScreenSchemesQueries queries) returns PageBeanIssueTypeScreenScheme|error {
        string resourcePath = string `/issuetypescreenscheme`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create issue type screen scheme
    #
    # + headers - Headers to be sent with the request 
    # + payload - An issue type screen scheme bean 
    # + return - Returned if the request is successful 
    resource isolated function post issuetypescreenscheme(IssueTypeScreenSchemeDetails payload, map<string|string[]> headers = {}) returns IssueTypeScreenSchemeId|error {
        string resourcePath = string `/issuetypescreenscheme`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Find users for picker
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get user/picker(map<string|string[]> headers = {}, *FindUsersForPickerQueries queries) returns FoundUsers|error {
        string resourcePath = string `/user/picker`;
        map<Encoding> queryParamEncoding = {"exclude": {style: FORM, explode: true}, "excludeAccountIds": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get application property
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get application\-properties(map<string|string[]> headers = {}, *GetApplicationPropertyQueries queries) returns ApplicationProperty[]|error {
        string resourcePath = string `/application-properties`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get valid project name
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get projectvalidate/validProjectName(map<string|string[]> headers = {}, *GetValidProjectNameQueries queries) returns string|error {
        string resourcePath = string `/projectvalidate/validProjectName`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create draft workflow scheme
    #
    # + id - The ID of the active workflow scheme that the draft is created from
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post workflowscheme/[int id]/createdraft(map<string|string[]> headers = {}) returns WorkflowScheme|error {
        string resourcePath = string `/workflowscheme/${getEncodedUri(id)}/createdraft`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get project's sender email
    #
    # + projectId - The project ID
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get project/[int projectId]/email(map<string|string[]> headers = {}) returns ProjectEmailAddress|error {
        string resourcePath = string `/project/${getEncodedUri(projectId)}/email`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set project's sender email
    #
    # + projectId - The project ID
    # + headers - Headers to be sent with the request 
    # + payload - The project's sender email address to be set 
    # + return - Returned if the project's sender email address is successfully set 
    resource isolated function put project/[int projectId]/email(ProjectEmailAddress payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/project/${getEncodedUri(projectId)}/email`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Bulk watch issues
    #
    # + headers - Headers to be sent with the request 
    # + payload - The request body containing the issues to be watched 
    # + return - Returned if the request is successful 
    resource isolated function post bulk/issues/watch(IssueBulkWatchOrUnwatchPayload payload, map<string|string[]> headers = {}) returns SubmittedBulkOperation|error {
        string resourcePath = string `/bulk/issues/watch`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Set default resolution
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put resolution/default(SetDefaultResolutionRequest payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/resolution/default`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get issue field option
    #
    # + fieldKey - The field key is specified in the following format: **$(app-key)\_\_$(field-key)**. For example, *example-add-on\_\_example-issue-field*. To determine the `fieldKey` value, do one of the following:
    # *  open the app's plugin descriptor, then **app-key** is the key at the top and **field-key** is the key in the `jiraIssueFields` module. **app-key** can also be found in the app listing in the Atlassian Universal Plugin Manager.
    # *  run [Get fields](#api-rest-api-3-field-get) and in the field details the value is returned in `key`. For example, `"key": "teams-add-on__team-issue-field"`
    # + optionId - The ID of the option to be returned
    # + headers - Headers to be sent with the request 
    # + return - Returned if the requested option is returned 
    resource isolated function get 'field/[string fieldKey]/option/[int optionId](map<string|string[]> headers = {}) returns IssueFieldOption|error {
        string resourcePath = string `/field/${getEncodedUri(fieldKey)}/option/${getEncodedUri(optionId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update issue field option
    #
    # + fieldKey - The field key is specified in the following format: **$(app-key)\_\_$(field-key)**. For example, *example-add-on\_\_example-issue-field*. To determine the `fieldKey` value, do one of the following:
    # *  open the app's plugin descriptor, then **app-key** is the key at the top and **field-key** is the key in the `jiraIssueFields` module. **app-key** can also be found in the app listing in the Atlassian Universal Plugin Manager.
    # *  run [Get fields](#api-rest-api-3-field-get) and in the field details the value is returned in `key`. For example, `"key": "teams-add-on__team-issue-field"`
    # + optionId - The ID of the option to be updated
    # + headers - Headers to be sent with the request 
    # + return - Returned if the option is updated or created 
    resource isolated function put 'field/[string fieldKey]/option/[int optionId](IssueFieldOption payload, map<string|string[]> headers = {}) returns IssueFieldOption|error {
        string resourcePath = string `/field/${getEncodedUri(fieldKey)}/option/${getEncodedUri(optionId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete issue field option
    #
    # + fieldKey - The field key is specified in the following format: **$(app-key)\_\_$(field-key)**. For example, *example-add-on\_\_example-issue-field*. To determine the `fieldKey` value, do one of the following:
    # *  open the app's plugin descriptor, then **app-key** is the key at the top and **field-key** is the key in the `jiraIssueFields` module. **app-key** can also be found in the app listing in the Atlassian Universal Plugin Manager.
    # *  run [Get fields](#api-rest-api-3-field-get) and in the field details the value is returned in `key`. For example, `"key": "teams-add-on__team-issue-field"`
    # + optionId - The ID of the option to be deleted
    # + headers - Headers to be sent with the request 
    # + return - Returned if the field option is deleted 
    resource isolated function delete 'field/[string fieldKey]/option/[int optionId](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/field/${getEncodedUri(fieldKey)}/option/${getEncodedUri(optionId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get dynamic webhooks for app
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get webhook(map<string|string[]> headers = {}, *GetDynamicWebhooksForAppQueries queries) returns PageBeanWebhook|error {
        string resourcePath = string `/webhook`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Register dynamic webhooks
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post webhook(WebhookRegistrationDetails payload, map<string|string[]> headers = {}) returns ContainerForRegisteredWebhooks|error {
        string resourcePath = string `/webhook`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete webhooks by ID
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete webhook(ContainerForWebhookIDs payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/webhook`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->delete(resourcePath, request, headers);
    }

    # Move screen tab
    #
    # + screenId - The ID of the screen
    # + tabId - The ID of the screen tab
    # + pos - The position of tab. The base index is 0
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post screens/[int screenId]/tabs/[int tabId]/move/[int:Signed32 pos](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/screens/${getEncodedUri(screenId)}/tabs/${getEncodedUri(tabId)}/move/${getEncodedUri(pos)}`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get user default columns
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get user/columns(map<string|string[]> headers = {}, *GetUserDefaultColumnsQueries queries) returns ColumnItem[]|error {
        string resourcePath = string `/user/columns`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Set user default columns
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - The ID of a column to set. To set multiple columns, send multiple `columns` parameters 
    # + return - Returned if the request is successful 
    resource isolated function put user/columns(http:Request request, map<string|string[]> headers = {}, *SetUserColumnsQueries queries) returns json|error {
        string resourcePath = string `/user/columns`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        // TODO: Update the request as needed;
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Reset user default columns
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete user/columns(map<string|string[]> headers = {}, *ResetUserColumnsQueries queries) returns error? {
        string resourcePath = string `/user/columns`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get fields
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get 'field(map<string|string[]> headers = {}) returns FieldDetails[]|error {
        string resourcePath = string `/field`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create custom field
    #
    # + headers - Headers to be sent with the request 
    # + payload - Definition of the custom field to be created 
    # + return - Returned if the custom field is created 
    resource isolated function post 'field(CustomFieldDefinitionJsonBean payload, map<string|string[]> headers = {}) returns FieldDetails|error {
        string resourcePath = string `/field`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Bulk update workflows
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post workflows/update(WorkflowUpdateRequest payload, map<string|string[]> headers = {}, *UpdateWorkflowsQueries queries) returns WorkflowUpdateResponse|error {
        string resourcePath = string `/workflows/update`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get version's related issues count
    #
    # + id - The ID of the version
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get version/[string id]/relatedIssueCounts(map<string|string[]> headers = {}) returns VersionIssueCounts|error {
        string resourcePath = string `/version/${getEncodedUri(id)}/relatedIssueCounts`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get issue picker suggestions
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issue/picker(map<string|string[]> headers = {}, *GetIssuePickerResourceQueries queries) returns IssuePickerSuggestions|error {
        string resourcePath = string `/issue/picker`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Export archived issue(s)
    #
    # + headers - Headers to be sent with the request 
    # + payload - You can filter the issues in your request by the `projects`, `archivedBy`, `archivedDate`, `issueTypes`, and `reporters` fields. All filters are optional. If you don't provide any filters, you'll get a list of up to one million archived issues 
    # + return - Returns the details of your export task. You can use the [get task](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-tasks/#api-rest-api-3-task-taskid-get) API to view the progress of your request 
    resource isolated function put issues/archive/export(ArchivedIssuesFilterRequest payload, map<string|string[]> headers = {}) returns ExportArchivedIssuesTaskProgressResponse|error {
        string resourcePath = string `/issues/archive/export`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Remove notification from notification scheme
    #
    # + notificationSchemeId - The ID of the notification scheme
    # + notificationId - The ID of the notification
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete notificationscheme/[string notificationSchemeId]/notification/[string notificationId](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/notificationscheme/${getEncodedUri(notificationSchemeId)}/notification/${getEncodedUri(notificationId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get field configuration issue type items
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get fieldconfigurationscheme/mapping(map<string|string[]> headers = {}, *GetFieldConfigurationSchemeMappingsQueries queries) returns PageBeanFieldConfigurationIssueTypeItem|error {
        string resourcePath = string `/fieldconfigurationscheme/mapping`;
        map<Encoding> queryParamEncoding = {"fieldConfigurationSchemeId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create issue
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post issue(IssueUpdateDetails payload, map<string|string[]> headers = {}, *CreateIssueQueries queries) returns CreatedIssue|error {
        string resourcePath = string `/issue`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get all dashboards
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get dashboard(map<string|string[]> headers = {}, *GetAllDashboardsQueries queries) returns PageOfDashboards|error {
        string resourcePath = string `/dashboard`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create dashboard
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Dashboard details 
    # + return - Returned if the request is successful 
    resource isolated function post dashboard(DashboardDetails payload, map<string|string[]> headers = {}, *CreateDashboardQueries queries) returns Dashboard|error {
        string resourcePath = string `/dashboard`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get screens for a field
    #
    # + fieldId - The ID of the field to return screens for
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get 'field/[string fieldId]/screens(map<string|string[]> headers = {}, *GetScreensForFieldQueries queries) returns PageBeanScreenWithTab|error {
        string resourcePath = string `/field/${getEncodedUri(fieldId)}/screens`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add issue security levels
    #
    # + schemeId - The ID of the issue security scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put issuesecurityschemes/[string schemeId]/level(AddSecuritySchemeLevelsRequestBean payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/issuesecurityschemes/${getEncodedUri(schemeId)}/level`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get worklog property
    #
    # + issueIdOrKey - The ID or key of the issue
    # + worklogId - The ID of the worklog
    # + propertyKey - The key of the property
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issue/[string issueIdOrKey]/worklog/[string worklogId]/properties/[string propertyKey](map<string|string[]> headers = {}) returns EntityProperty|error {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/worklog/${getEncodedUri(worklogId)}/properties/${getEncodedUri(propertyKey)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set worklog property
    #
    # + issueIdOrKey - The ID or key of the issue
    # + worklogId - The ID of the worklog
    # + propertyKey - The key of the issue property. The maximum length is 255 characters
    # + headers - Headers to be sent with the request 
    # + payload - The value of the property. The value has to be a valid, non-empty [JSON](https://tools.ietf.org/html/rfc4627) value. The maximum length of the property value is 32768 bytes 
    # + return - Returned if the worklog property is updated 
    resource isolated function put issue/[string issueIdOrKey]/worklog/[string worklogId]/properties/[string propertyKey](json payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/worklog/${getEncodedUri(worklogId)}/properties/${getEncodedUri(propertyKey)}`;
        http:Request request = new;
        request.setPayload(payload, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete worklog property
    #
    # + issueIdOrKey - The ID or key of the issue
    # + worklogId - The ID of the worklog
    # + propertyKey - The key of the property
    # + headers - Headers to be sent with the request 
    # + return - Returned if the worklog property is removed 
    resource isolated function delete issue/[string issueIdOrKey]/worklog/[string worklogId]/properties/[string propertyKey](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/worklog/${getEncodedUri(worklogId)}/properties/${getEncodedUri(propertyKey)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get modules
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get atlassian\-connect/'1/app/module/dynamic(map<string|string[]> headers = {}) returns ConnectModules|error {
        string resourcePath = string `/atlassian-connect/1/app/module/dynamic`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Register modules
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post atlassian\-connect/'1/app/module/dynamic(ConnectModules payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/atlassian-connect/1/app/module/dynamic`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Remove modules
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete atlassian\-connect/'1/app/module/dynamic(map<string|string[]> headers = {}, *DynamicModulesResourceRemoveModulesDeleteQueries queries) returns error? {
        string resourcePath = string `/atlassian-connect/1/app/module/dynamic`;
        map<Encoding> queryParamEncoding = {"moduleKey": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update field configuration scheme
    #
    # + id - The ID of the field configuration scheme
    # + headers - Headers to be sent with the request 
    # + payload - The details of the field configuration scheme 
    # + return - Returned if the request is successful 
    resource isolated function put fieldconfigurationscheme/[int id](UpdateFieldConfigurationSchemeDetails payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/fieldconfigurationscheme/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete field configuration scheme
    #
    # + id - The ID of the field configuration scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete fieldconfigurationscheme/[int id](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/fieldconfigurationscheme/${getEncodedUri(id)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Check issues against JQL
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post jql/'match(IssuesAndJQLQueries payload, map<string|string[]> headers = {}) returns IssueMatches|error {
        string resourcePath = string `/jql/match`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get plans paginated
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get plans/plan(map<string|string[]> headers = {}, *GetPlansQueries queries) returns PageWithCursorGetPlanResponseForPage|error {
        string resourcePath = string `/plans/plan`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create plan
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post plans/plan(CreatePlanRequest payload, map<string|string[]> headers = {}, *CreatePlanQueries queries) returns int|error {
        string resourcePath = string `/plans/plan`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get Jira attachment settings
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get attachment/meta(map<string|string[]> headers = {}) returns AttachmentSettings|error {
        string resourcePath = string `/attachment/meta`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get teams in plan paginated
    #
    # + planId - The ID of the plan
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get plans/plan/[int planId]/team(map<string|string[]> headers = {}, *GetTeamsQueries queries) returns PageWithCursorGetTeamResponseForPage|error {
        string resourcePath = string `/plans/plan/${getEncodedUri(planId)}/team`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Search for dashboards
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get dashboard/search(map<string|string[]> headers = {}, *GetDashboardsPaginatedQueries queries) returns PageBeanDashboard|error {
        string resourcePath = string `/dashboard/search`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Suggested priorities for mappings
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post priorityscheme/mappings(SuggestedMappingsRequestBean payload, map<string|string[]> headers = {}) returns PageBeanPriorityWithSequence|error {
        string resourcePath = string `/priorityscheme/mappings`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get avatar image by ID
    #
    # + 'type - The icon type of the avatar
    # + id - The ID of the avatar
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get universal_avatar/view/'type/["issuetype"|"project"|"priority" 'type]/avatar/[int id](map<string|string[]> headers = {}, *GetAvatarImageByIDQueries queries) returns StreamingResponseBody|error {
        string resourcePath = string `/universal_avatar/view/type/${getEncodedUri('type)}/avatar/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get favorite filters
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get filter/favourite(map<string|string[]> headers = {}, *GetFavouriteFiltersQueries queries) returns Filter[]|error {
        string resourcePath = string `/filter/favourite`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get comments
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issue/[string issueIdOrKey]/comment(map<string|string[]> headers = {}, *GetCommentsQueries queries) returns PageOfComments|error {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/comment`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add comment
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post issue/[string issueIdOrKey]/comment(Comment payload, map<string|string[]> headers = {}, *AddCommentQueries queries) returns Comment|error {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/comment`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get permission scheme grants
    #
    # + schemeId - The ID of the permission scheme
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get permissionscheme/[int schemeId]/permission(map<string|string[]> headers = {}, *GetPermissionSchemeGrantsQueries queries) returns PermissionGrants|error {
        string resourcePath = string `/permissionscheme/${getEncodedUri(schemeId)}/permission`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create permission grant
    #
    # + schemeId - The ID of the permission scheme in which to create a new permission grant
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The permission grant to create 
    # + return - Returned if the scheme permission is created 
    resource isolated function post permissionscheme/[int schemeId]/permission(PermissionGrant payload, map<string|string[]> headers = {}, *CreatePermissionGrantQueries queries) returns PermissionGrant|error {
        string resourcePath = string `/permissionscheme/${getEncodedUri(schemeId)}/permission`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get is watching issue bulk
    #
    # + headers - Headers to be sent with the request 
    # + payload - A list of issue IDs 
    # + return - Returned if the request is successful 
    resource isolated function post issue/watching(IssueList payload, map<string|string[]> headers = {}) returns BulkIssueIsWatching|error {
        string resourcePath = string `/issue/watching`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get comment
    #
    # + issueIdOrKey - The ID or key of the issue
    # + id - The ID of the comment
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issue/[string issueIdOrKey]/comment/[string id](map<string|string[]> headers = {}, *GetCommentQueries queries) returns Comment|error {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/comment/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update comment
    #
    # + issueIdOrKey - The ID or key of the issue
    # + id - The ID of the comment
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put issue/[string issueIdOrKey]/comment/[string id](Comment payload, map<string|string[]> headers = {}, *UpdateCommentQueries queries) returns Comment|error {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/comment/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete comment
    #
    # + issueIdOrKey - The ID or key of the issue
    # + id - The ID of the comment
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete issue/[string issueIdOrKey]/comment/[string id](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/comment/${getEncodedUri(id)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Delete custom field
    #
    # + id - The ID of a custom field
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete 'field/[string id](map<string|string[]> headers = {}) returns http:Response|error {
        string resourcePath = string `/field/${getEncodedUri(id)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get plan-only team
    #
    # + planId - The ID of the plan
    # + planOnlyTeamId - The ID of the plan-only team
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get plans/plan/[int planId]/team/planonly/[int planOnlyTeamId](map<string|string[]> headers = {}) returns GetPlanOnlyTeamResponse|error {
        string resourcePath = string `/plans/plan/${getEncodedUri(planId)}/team/planonly/${getEncodedUri(planOnlyTeamId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update plan-only team
    #
    # + planId - The ID of the plan
    # + planOnlyTeamId - The ID of the plan-only team
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put plans/plan/[int planId]/team/planonly/[int planOnlyTeamId](record {} payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/plans/plan/${getEncodedUri(planId)}/team/planonly/${getEncodedUri(planOnlyTeamId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json-patch+json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete plan-only team
    #
    # + planId - The ID of the plan
    # + planOnlyTeamId - The ID of the plan-only team
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete plans/plan/[int planId]/team/planonly/[int planOnlyTeamId](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/plans/plan/${getEncodedUri(planId)}/team/planonly/${getEncodedUri(planOnlyTeamId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get project issue type hierarchy
    #
    # + projectId - The ID of the project
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get project/[int projectId]/hierarchy(map<string|string[]> headers = {}) returns ProjectIssueTypeHierarchy|error {
        string resourcePath = string `/project/${getEncodedUri(projectId)}/hierarchy`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get license
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get instance/license(map<string|string[]> headers = {}) returns License|error {
        string resourcePath = string `/instance/license`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Find users
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get user/search(map<string|string[]> headers = {}, *FindUsersQueries queries) returns User[]|error {
        string resourcePath = string `/user/search`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get licensed project types
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get project/'type/accessible(map<string|string[]> headers = {}) returns ProjectType[]|error {
        string resourcePath = string `/project/type/accessible`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get resolution
    #
    # + id - The ID of the issue resolution value
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get resolution/[string id](map<string|string[]> headers = {}) returns Resolution|error {
        string resourcePath = string `/resolution/${getEncodedUri(id)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update resolution
    #
    # + id - The ID of the issue resolution
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put resolution/[string id](UpdateResolutionDetails payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/resolution/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete resolution
    #
    # + id - The ID of the issue resolution
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete resolution/[string id](map<string|string[]> headers = {}, *DeleteResolutionQueries queries) returns http:Response|error {
        string resourcePath = string `/resolution/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get bulk screen tabs
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get screens/tabs(map<string|string[]> headers = {}, *GetBulkScreenTabsQueries queries) returns json|error {
        string resourcePath = string `/screens/tabs`;
        map<Encoding> queryParamEncoding = {"screenId": {style: FORM, explode: true}, "tabId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get workflow schemes which are using a given workflow
    #
    # + workflowId - The workflow ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get workflow/[string workflowId]/workflowSchemes(map<string|string[]> headers = {}, *GetWorkflowSchemeUsagesForWorkflowQueries queries) returns WorkflowSchemeUsageDTO|error {
        string resourcePath = string `/workflow/${getEncodedUri(workflowId)}/workflowSchemes`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get attachment content
    #
    # + id - The ID of the attachment
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful when `redirect` is set to `false` 
    resource isolated function get attachment/content/[string id](map<string|string[]> headers = {}, *GetAttachmentContentQueries queries) returns anydata[]|error? {
        string resourcePath = string `/attachment/content/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get resolutions
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    # 
    # # Deprecated
    @deprecated
    resource isolated function get resolution(map<string|string[]> headers = {}) returns Resolution[]|error {
        string resourcePath = string `/resolution`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create resolution
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post resolution(CreateResolutionDetails payload, map<string|string[]> headers = {}) returns ResolutionId|error {
        string resourcePath = string `/resolution`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Search statuses paginated
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get statuses/search(map<string|string[]> headers = {}, *SearchQueries queries) returns PageOfStatuses|error {
        string resourcePath = string `/statuses/search`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get workflow transition properties
    #
    # + transitionId - The ID of the transition. To get the ID, view the workflow in text mode in the Jira administration console. The ID is shown next to the transition
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response 
    # 
    # # Deprecated
    @deprecated
    resource isolated function get workflow/transitions/[int transitionId]/properties(map<string|string[]> headers = {}, *GetWorkflowTransitionPropertiesQueries queries) returns WorkflowTransitionProperty|error {
        string resourcePath = string `/workflow/transitions/${getEncodedUri(transitionId)}/properties`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update workflow transition property
    #
    # + transitionId - The ID of the transition. To get the ID, view the workflow in text mode in the Jira admin settings. The ID is shown next to the transition
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response 
    # 
    # # Deprecated
    @deprecated
    resource isolated function put workflow/transitions/[int transitionId]/properties(WorkflowTransitionProperty payload, map<string|string[]> headers = {}, *UpdateWorkflowTransitionPropertyQueries queries) returns WorkflowTransitionProperty|error? {
        string resourcePath = string `/workflow/transitions/${getEncodedUri(transitionId)}/properties`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Create workflow transition property
    #
    # + transitionId - The ID of the transition. To get the ID, view the workflow in text mode in the Jira admin settings. The ID is shown next to the transition
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response 
    # 
    # # Deprecated
    @deprecated
    resource isolated function post workflow/transitions/[int transitionId]/properties(WorkflowTransitionProperty payload, map<string|string[]> headers = {}, *CreateWorkflowTransitionPropertyQueries queries) returns WorkflowTransitionProperty|error {
        string resourcePath = string `/workflow/transitions/${getEncodedUri(transitionId)}/properties`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete workflow transition property
    #
    # + transitionId - The ID of the transition. To get the ID, view the workflow in text mode in the Jira admin settings. The ID is shown next to the transition
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response 
    # 
    # # Deprecated
    @deprecated
    resource isolated function delete workflow/transitions/[int transitionId]/properties(map<string|string[]> headers = {}, *DeleteWorkflowTransitionPropertyQueries queries) returns error? {
        string resourcePath = string `/workflow/transitions/${getEncodedUri(transitionId)}/properties`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Assign issue
    #
    # + issueIdOrKey - The ID or key of the issue to be assigned
    # + headers - Headers to be sent with the request 
    # + payload - The request object with the user that the issue is assigned to 
    # + return - Returned if the request is successful 
    resource isolated function put issue/[string issueIdOrKey]/assignee(User payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/assignee`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get user nav property
    #
    # + propertyKey - The key of the user's property
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get user/nav4\-opt\-property/[string propertyKey](map<string|string[]> headers = {}, *GetUserNavPropertyQueries queries) returns UserNavPropertyJsonBean|error {
        string resourcePath = string `/user/nav4-opt-property/${getEncodedUri(propertyKey)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Set user nav property
    #
    # + propertyKey - The key of the nav property. The maximum length is 255 characters
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The value of the property. The value has to be a boolean [JSON](https://tools.ietf.org/html/rfc4627) value. The maximum length of the property value is 32768 bytes 
    # + return - Returned if the user property is updated/created 
    resource isolated function put user/nav4\-opt\-property/[string propertyKey](json payload, map<string|string[]> headers = {}, *SetUserNavPropertyQueries queries) returns json|error {
        string resourcePath = string `/user/nav4-opt-property/${getEncodedUri(propertyKey)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        request.setPayload(payload, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get selectable issue field options
    #
    # + fieldKey - The field key is specified in the following format: **$(app-key)\_\_$(field-key)**. For example, *example-add-on\_\_example-issue-field*. To determine the `fieldKey` value, do one of the following:
    # *  open the app's plugin descriptor, then **app-key** is the key at the top and **field-key** is the key in the `jiraIssueFields` module. **app-key** can also be found in the app listing in the Atlassian Universal Plugin Manager.
    # *  run [Get fields](#api-rest-api-3-field-get) and in the field details the value is returned in `key`. For example, `"key": "teams-add-on__team-issue-field"`
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get 'field/[string fieldKey]/option/suggestions/edit(map<string|string[]> headers = {}, *GetSelectableIssueFieldOptionsQueries queries) returns PageBeanIssueFieldOption|error {
        string resourcePath = string `/field/${getEncodedUri(fieldKey)}/option/suggestions/edit`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Search priorities
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    # 
    # # Deprecated
    @deprecated
    resource isolated function get priority/search(map<string|string[]> headers = {}, *SearchPrioritiesQueries queries) returns PageBeanPriority|error {
        string resourcePath = string `/priority/search`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}, "projectId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update workflow scheme
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful and there is no asynchronous task 
    resource isolated function post workflowscheme/update(WorkflowSchemeUpdateRequest payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/workflowscheme/update`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Replace custom field options
    #
    # + fieldId - The ID of the custom field
    # + optionId - The ID of the option to be deselected
    # + contextId - The ID of the context
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the long-running task to deselect the option is started 
    resource isolated function delete 'field/[string fieldId]/context/[int contextId]/option/[int optionId]/issue(map<string|string[]> headers = {}, *ReplaceCustomFieldOptionQueries queries) returns http:Response|error {
        string resourcePath = string `/field/${getEncodedUri(fieldId)}/context/${getEncodedUri(contextId)}/option/${getEncodedUri(optionId)}/issue`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Remove issue types from context
    #
    # + fieldId - The ID of the custom field
    # + contextId - The ID of the context
    # + headers - Headers to be sent with the request 
    # + return - Returned if operation is successful 
    resource isolated function post 'field/[string fieldId]/context/[int contextId]/issuetype/remove(IssueTypeIds payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/field/${getEncodedUri(fieldId)}/context/${getEncodedUri(contextId)}/issuetype/remove`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete related work
    #
    # + versionId - The ID of the version that the target related work belongs to
    # + relatedWorkId - The ID of the related work to delete
    # + headers - Headers to be sent with the request 
    # + return - Returned if the related work is deleted 
    resource isolated function delete version/[string versionId]/relatedwork/[string relatedWorkId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/version/${getEncodedUri(versionId)}/relatedwork/${getEncodedUri(relatedWorkId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Bulk update custom field value
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put atlassian\-connect/'1/migration/'field(AppIssueFieldValueUpdateResourceUpdateIssueFieldsPutHeaders headers, ConnectCustomFieldValues payload) returns json|error {
        string resourcePath = string `/atlassian-connect/1/migration/field`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Get project category by ID
    #
    # + id - The ID of the project category
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get projectCategory/[int id](map<string|string[]> headers = {}) returns ProjectCategory|error {
        string resourcePath = string `/projectCategory/${getEncodedUri(id)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update project category
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put projectCategory/[int id](ProjectCategory payload, map<string|string[]> headers = {}) returns UpdatedProjectCategory|error {
        string resourcePath = string `/projectCategory/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete project category
    #
    # + id - ID of the project category to delete
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete projectCategory/[int id](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/projectCategory/${getEncodedUri(id)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get issue navigator default columns
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get settings/columns(map<string|string[]> headers = {}) returns ColumnItem[]|error {
        string resourcePath = string `/settings/columns`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set issue navigator default columns
    #
    # + headers - Headers to be sent with the request 
    # + request - A navigable field value 
    # + return - Returned if the request is successful 
    resource isolated function put settings/columns(http:Request request, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/settings/columns`;
        // TODO: Update the request as needed;
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get valid project key
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get projectvalidate/validProjectKey(map<string|string[]> headers = {}, *GetValidProjectKeyQueries queries) returns string|error {
        string resourcePath = string `/projectvalidate/validProjectKey`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get my filters
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get filter/my(map<string|string[]> headers = {}, *GetMyFiltersQueries queries) returns Filter[]|error {
        string resourcePath = string `/filter/my`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update gadget on dashboard
    #
    # + dashboardId - The ID of the dashboard
    # + gadgetId - The ID of the gadget
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put dashboard/[int dashboardId]/gadget/[int gadgetId](DashboardGadgetUpdateRequest payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/dashboard/${getEncodedUri(dashboardId)}/gadget/${getEncodedUri(gadgetId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Remove gadget from dashboard
    #
    # + dashboardId - The ID of the dashboard
    # + gadgetId - The ID of the gadget
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete dashboard/[int dashboardId]/gadget/[int gadgetId](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/dashboard/${getEncodedUri(dashboardId)}/gadget/${getEncodedUri(gadgetId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get comment property keys
    #
    # + commentId - The ID of the comment
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get comment/[string commentId]/properties(map<string|string[]> headers = {}) returns PropertyKeys|error {
        string resourcePath = string `/comment/${getEncodedUri(commentId)}/properties`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Validate project key
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get projectvalidate/'key(map<string|string[]> headers = {}, *ValidateProjectKeyQueries queries) returns ErrorCollection|error {
        string resourcePath = string `/projectvalidate/key`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    resource isolated function post 'field/[string id](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/field/${getEncodedUri(id)}ore`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Bulk create issue
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if any of the issue or subtask creation requests were successful. A request may be unsuccessful when it:  *  is missing required fields.  *  contains invalid field values.  *  contains fields that cannot be set for the issue type.  *  is by a user who does not have the necessary permission.  *  is to create a subtype in a project different that of the parent issue.  *  is for a subtask when the option to create subtasks is disabled.  *  is invalid for any other reason 
    resource isolated function post issue/bulk(IssuesUpdateBean payload, map<string|string[]> headers = {}) returns CreatedIssues|error {
        string resourcePath = string `/issue/bulk`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get component issues count
    #
    # + id - The ID of the component
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get component/[string id]/relatedIssueCounts(map<string|string[]> headers = {}) returns ComponentIssuesCount|error {
        string resourcePath = string `/component/${getEncodedUri(id)}/relatedIssueCounts`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get approximate license count
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get license/approximateLicenseCount(map<string|string[]> headers = {}) returns LicenseMetric|error {
        string resourcePath = string `/license/approximateLicenseCount`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get issue security schemes
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issuesecurityschemes(map<string|string[]> headers = {}) returns SecuritySchemes|error {
        string resourcePath = string `/issuesecurityschemes`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create issue security scheme
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post issuesecurityschemes(CreateIssueSecuritySchemeDetails payload, map<string|string[]> headers = {}) returns SecuritySchemeId|error {
        string resourcePath = string `/issuesecurityschemes`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Find users assignable to projects
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get user/assignable/multiProjectSearch(map<string|string[]> headers = {}, *FindBulkAssignableUsersQueries queries) returns User[]|error {
        string resourcePath = string `/user/assignable/multiProjectSearch`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Convert user identifiers to account IDs in JQL queries
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful. Note that the JQL queries are returned in the same order that they were passed 
    resource isolated function post jql/pdcleaner(JQLPersonalDataMigrationRequest payload, map<string|string[]> headers = {}) returns ConvertedJQLQueries|error {
        string resourcePath = string `/jql/pdcleaner`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Add notifications to notification scheme
    #
    # + id - The ID of the notification scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put notificationscheme/[string id]/notification(AddNotificationsDetails payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/notificationscheme/${getEncodedUri(id)}/notification`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get available priorities by priority scheme
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get priorityscheme/priorities/available(map<string|string[]> headers = {}, *GetAvailablePrioritiesByPrioritySchemeQueries queries) returns PageBeanPriorityWithSequence|error {
        string resourcePath = string `/priorityscheme/priorities/available`;
        map<Encoding> queryParamEncoding = {"exclude": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Validate update workflows
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post workflows/update/validation(WorkflowUpdateValidateRequestBean payload, map<string|string[]> headers = {}) returns WorkflowValidationErrorList|error {
        string resourcePath = string `/workflows/update/validation`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get issue
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issue/[string issueIdOrKey](map<string|string[]> headers = {}, *GetIssueQueries queries) returns IssueBean|error {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: true}, "properties": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Edit issue
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful and the `returnIssue` parameter is `true` 
    resource isolated function put issue/[string issueIdOrKey](IssueUpdateDetails payload, map<string|string[]> headers = {}, *EditIssueQueries queries) returns json|error {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete issue
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete issue/[string issueIdOrKey](map<string|string[]> headers = {}, *DeleteIssueQueries queries) returns error? {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get all screen tab fields
    #
    # + screenId - The ID of the screen
    # + tabId - The ID of the screen tab
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get screens/[int screenId]/tabs/[int tabId]/fields(map<string|string[]> headers = {}, *GetAllScreenTabFieldsQueries queries) returns ScreenableField[]|error {
        string resourcePath = string `/screens/${getEncodedUri(screenId)}/tabs/${getEncodedUri(tabId)}/fields`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add screen tab field
    #
    # + screenId - The ID of the screen
    # + tabId - The ID of the screen tab
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post screens/[int screenId]/tabs/[int tabId]/fields(AddFieldBean payload, map<string|string[]> headers = {}) returns ScreenableField|error {
        string resourcePath = string `/screens/${getEncodedUri(screenId)}/tabs/${getEncodedUri(tabId)}/fields`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get workflow usages by status
    #
    # + statusId - The statusId to fetch workflow usages for
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get statuses/[string statusId]/workflowUsages(map<string|string[]> headers = {}, *GetWorkflowUsagesForStatusQueries queries) returns StatusWorkflowUsageDTO|error {
        string resourcePath = string `/statuses/${getEncodedUri(statusId)}/workflowUsages`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get fields paginated
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get 'field/search(map<string|string[]> headers = {}, *GetFieldsPaginatedQueries queries) returns PageBeanField|error {
        string resourcePath = string `/field/search`;
        map<Encoding> queryParamEncoding = {"type": {style: FORM, explode: true}, "id": {style: FORM, explode: true}, "projectIds": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get failed webhooks
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get webhook/failed(map<string|string[]> headers = {}, *GetFailedWebhooksQueries queries) returns FailedWebhooks|error {
        string resourcePath = string `/webhook/failed`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Remove mappings from issue type screen scheme
    #
    # + issueTypeScreenSchemeId - The ID of the issue type screen scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the screen scheme mappings are removed from the issue type screen scheme 
    resource isolated function post issuetypescreenscheme/[string issueTypeScreenSchemeId]/mapping/remove(IssueTypeIds payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/issuetypescreenscheme/${getEncodedUri(issueTypeScreenSchemeId)}/mapping/remove`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get current user
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get myself(map<string|string[]> headers = {}, *GetCurrentUserQueries queries) returns User|error {
        string resourcePath = string `/myself`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get votes
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issue/[string issueIdOrKey]/votes(map<string|string[]> headers = {}) returns Votes|error {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/votes`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Add vote
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post issue/[string issueIdOrKey]/votes(map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/votes`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete vote
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete issue/[string issueIdOrKey]/votes(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/votes`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get all issue types for user
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issuetype(map<string|string[]> headers = {}) returns IssueTypeDetails[]|error {
        string resourcePath = string `/issuetype`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create issue type
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post issuetype(IssueTypeCreateBean payload, map<string|string[]> headers = {}) returns IssueTypeDetails|error {
        string resourcePath = string `/issuetype`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete and replace version
    #
    # + id - The ID of the version
    # + headers - Headers to be sent with the request 
    # + return - Returned if the version is deleted 
    resource isolated function post version/[string id]/removeAndSwap(DeleteAndReplaceVersionBean payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/version/${getEncodedUri(id)}/removeAndSwap`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get workflows paginated
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    # 
    # # Deprecated
    @deprecated
    resource isolated function get workflow/search(map<string|string[]> headers = {}, *GetWorkflowsPaginatedQueries queries) returns PageBeanWorkflow|error {
        string resourcePath = string `/workflow/search`;
        map<Encoding> queryParamEncoding = {"workflowName": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update issue type scheme
    #
    # + issueTypeSchemeId - The ID of the issue type scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put issuetypescheme/[int issueTypeSchemeId](IssueTypeSchemeUpdateDetails payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/issuetypescheme/${getEncodedUri(issueTypeSchemeId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete issue type scheme
    #
    # + issueTypeSchemeId - The ID of the issue type scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the issue type scheme is deleted 
    resource isolated function delete issuetypescheme/[int issueTypeSchemeId](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/issuetypescheme/${getEncodedUri(issueTypeSchemeId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get issue type screen scheme items
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issuetypescreenscheme/mapping(map<string|string[]> headers = {}, *GetIssueTypeScreenSchemeMappingsQueries queries) returns PageBeanIssueTypeScreenSchemeItem|error {
        string resourcePath = string `/issuetypescreenscheme/mapping`;
        map<Encoding> queryParamEncoding = {"issueTypeScreenSchemeId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Set project feature state
    #
    # + projectIdOrKey - The ID or (case-sensitive) key of the project
    # + featureKey - The key of the feature
    # + headers - Headers to be sent with the request 
    # + payload - Details of the feature state change 
    # + return - Returned if the request is successful 
    resource isolated function put project/[string projectIdOrKey]/features/[string featureKey](ProjectFeatureState payload, map<string|string[]> headers = {}) returns ContainerForProjectFeatures|error {
        string resourcePath = string `/project/${getEncodedUri(projectIdOrKey)}/features/${getEncodedUri(featureKey)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Move resolutions
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put resolution/move(ReorderIssueResolutionsRequest payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/resolution/move`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get projects which are using a given workflow scheme
    #
    # + workflowSchemeId - The workflow scheme ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get workflowscheme/[string workflowSchemeId]/projectUsages(map<string|string[]> headers = {}, *GetProjectUsagesForWorkflowSchemeQueries queries) returns WorkflowSchemeProjectUsageDTO|error {
        string resourcePath = string `/workflowscheme/${getEncodedUri(workflowSchemeId)}/projectUsages`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Search issue security schemes
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issuesecurityschemes/search(map<string|string[]> headers = {}, *SearchSecuritySchemesQueries queries) returns PageBeanSecuritySchemeWithProjects|error {
        string resourcePath = string `/issuesecurityschemes/search`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}, "projectId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get issue link
    #
    # + linkId - The ID of the issue link
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issueLink/[string linkId](map<string|string[]> headers = {}) returns IssueLink|error {
        string resourcePath = string `/issueLink/${getEncodedUri(linkId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete issue link
    #
    # + linkId - The ID of the issue link
    # + headers - Headers to be sent with the request 
    # + return - 200 response 
    resource isolated function delete issueLink/[string linkId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/issueLink/${getEncodedUri(linkId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get issue link types
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issueLinkType(map<string|string[]> headers = {}) returns IssueLinkTypes|error {
        string resourcePath = string `/issueLinkType`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create issue link type
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post issueLinkType(IssueLinkType payload, map<string|string[]> headers = {}) returns IssueLinkType|error {
        string resourcePath = string `/issueLinkType`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get custom field options (context)
    #
    # + fieldId - The ID of the custom field
    # + contextId - The ID of the context
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get 'field/[string fieldId]/context/[int contextId]/option(map<string|string[]> headers = {}, *GetOptionsForContextQueries queries) returns PageBeanCustomFieldContextOption|error {
        string resourcePath = string `/field/${getEncodedUri(fieldId)}/context/${getEncodedUri(contextId)}/option`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update custom field options (context)
    #
    # + fieldId - The ID of the custom field
    # + contextId - The ID of the context
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put 'field/[string fieldId]/context/[int contextId]/option(BulkCustomFieldOptionUpdateRequest payload, map<string|string[]> headers = {}) returns CustomFieldUpdatedContextOptionsList|error {
        string resourcePath = string `/field/${getEncodedUri(fieldId)}/context/${getEncodedUri(contextId)}/option`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Create custom field options (context)
    #
    # + fieldId - The ID of the custom field
    # + contextId - The ID of the context
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post 'field/[string fieldId]/context/[int contextId]/option(BulkCustomFieldOptionCreateRequest payload, map<string|string[]> headers = {}) returns CustomFieldCreatedContextOptionsList|error {
        string resourcePath = string `/field/${getEncodedUri(fieldId)}/context/${getEncodedUri(contextId)}/option`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Update custom fields
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post app/'field/value(MultipleCustomFieldValuesUpdateDetails payload, map<string|string[]> headers = {}, *UpdateMultipleCustomFieldValuesQueries queries) returns json|error {
        string resourcePath = string `/app/field/value`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Archive issue(s) by issue ID/key
    #
    # + headers - Headers to be sent with the request 
    # + payload - Contains a list of issue keys or IDs to be archived 
    # + return - Returned if there is at least one valid issue to archive in the request. The return message will include the count of archived issues and subtasks, as well as error details for issues which failed to get archived 
    resource isolated function put issue/archive(IssueArchivalSyncRequest payload, map<string|string[]> headers = {}) returns IssueArchivalSyncResponse|error {
        string resourcePath = string `/issue/archive`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Archive issue(s) by JQL
    #
    # + headers - Headers to be sent with the request 
    # + payload - A JQL query specifying the issues to archive. Note that subtasks can only be archived through their parent issues 
    # + return - Returns the URL to check the status of the submitted request 
    resource isolated function post issue/archive(ArchiveIssueAsyncRequest payload, map<string|string[]> headers = {}) returns string|error {
        string resourcePath = string `/issue/archive`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get create issue metadata
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    # 
    # # Deprecated
    @deprecated
    resource isolated function get issue/createmeta(map<string|string[]> headers = {}, *GetCreateIssueMetaQueries queries) returns IssueCreateMetadata|error {
        string resourcePath = string `/issue/createmeta`;
        map<Encoding> queryParamEncoding = {"projectIds": {style: FORM, explode: true}, "projectKeys": {style: FORM, explode: true}, "issuetypeIds": {style: FORM, explode: true}, "issuetypeNames": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get project issue security scheme
    #
    # + projectKeyOrId - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get project/[string projectKeyOrId]/issuesecuritylevelscheme(map<string|string[]> headers = {}) returns SecurityScheme|error {
        string resourcePath = string `/project/${getEncodedUri(projectKeyOrId)}/issuesecuritylevelscheme`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Find users assignable to issues
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get user/assignable/search(map<string|string[]> headers = {}, *FindAssignableUsersQueries queries) returns User[]|error {
        string resourcePath = string `/user/assignable/search`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Merge versions
    #
    # + id - The ID of the version to delete
    # + moveIssuesTo - The ID of the version to merge into
    # + headers - Headers to be sent with the request 
    # + return - Returned if the version is deleted 
    resource isolated function put version/[string id]/mergeto/[string moveIssuesTo](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/version/${getEncodedUri(id)}/mergeto/${getEncodedUri(moveIssuesTo)}`;
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get filter
    #
    # + id - The ID of the filter to return
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get filter/[int id](map<string|string[]> headers = {}, *GetFilterQueries queries) returns Filter|error {
        string resourcePath = string `/filter/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update filter
    #
    # + id - The ID of the filter to update
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The filter to update 
    # + return - Returned if the request is successful 
    resource isolated function put filter/[int id](Filter payload, map<string|string[]> headers = {}, *UpdateFilterQueries queries) returns Filter|error {
        string resourcePath = string `/filter/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete filter
    #
    # + id - The ID of the filter to delete
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete filter/[int id](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/filter/${getEncodedUri(id)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Add user to group
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The user to add to the group 
    # + return - Returned if the request is successful 
    resource isolated function post group/user(UpdateUserToGroupBean payload, map<string|string[]> headers = {}, *AddUserToGroupQueries queries) returns Group|error {
        string resourcePath = string `/group/user`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Remove user from group
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete group/user(map<string|string[]> headers = {}, *RemoveUserFromGroupQueries queries) returns error? {
        string resourcePath = string `/group/user`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get all project avatars
    #
    # + projectIdOrKey - The ID or (case-sensitive) key of the project
    # + headers - Headers to be sent with the request 
    # + return - Returned if request is successful 
    resource isolated function get project/[string projectIdOrKey]/avatars(map<string|string[]> headers = {}) returns ProjectAvatars|error {
        string resourcePath = string `/project/${getEncodedUri(projectIdOrKey)}/avatars`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get available screen fields
    #
    # + screenId - The ID of the screen
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get screens/[int screenId]/availableFields(map<string|string[]> headers = {}) returns ScreenableField[]|error {
        string resourcePath = string `/screens/${getEncodedUri(screenId)}/availableFields`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get priority schemes
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get priorityscheme(map<string|string[]> headers = {}, *GetPrioritySchemesQueries queries) returns PageBeanPrioritySchemeWithPaginatedPrioritiesAndProjects|error {
        string resourcePath = string `/priorityscheme`;
        map<Encoding> queryParamEncoding = {"priorityId": {style: FORM, explode: true}, "schemeId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create priority scheme
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is completed 
    resource isolated function post priorityscheme(CreatePrioritySchemeDetails payload, map<string|string[]> headers = {}) returns PrioritySchemeId|error {
        string resourcePath = string `/priorityscheme`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get workflow transition rule configurations
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post atlassian\-connect/'1/migration/workflow/rule/search(MigrationResourceWorkflowRuleSearchPostHeaders headers, WorkflowRulesSearch payload) returns WorkflowRulesSearchDetails|error {
        string resourcePath = string `/atlassian-connect/1/migration/workflow/rule/search`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get app property
    #
    # + addonKey - The key of the app, as defined in its descriptor
    # + propertyKey - The key of the property
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get atlassian\-connect/'1/addons/[string addonKey]/properties/[string propertyKey](map<string|string[]> headers = {}) returns EntityProperty|error {
        string resourcePath = string `/atlassian-connect/1/addons/${getEncodedUri(addonKey)}/properties/${getEncodedUri(propertyKey)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set app property
    #
    # + addonKey - The key of the app, as defined in its descriptor
    # + propertyKey - The key of the property
    # + headers - Headers to be sent with the request 
    # + return - Returned if the property is updated 
    resource isolated function put atlassian\-connect/'1/addons/[string addonKey]/properties/[string propertyKey](json payload, map<string|string[]> headers = {}) returns OperationMessage|error {
        string resourcePath = string `/atlassian-connect/1/addons/${getEncodedUri(addonKey)}/properties/${getEncodedUri(propertyKey)}`;
        http:Request request = new;
        request.setPayload(payload, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete app property
    #
    # + addonKey - The key of the app, as defined in its descriptor
    # + propertyKey - The key of the property
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete atlassian\-connect/'1/addons/[string addonKey]/properties/[string propertyKey](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/atlassian-connect/1/addons/${getEncodedUri(addonKey)}/properties/${getEncodedUri(propertyKey)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get priority
    #
    # + id - The ID of the issue priority
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get priority/[string id](map<string|string[]> headers = {}) returns Priority|error {
        string resourcePath = string `/priority/${getEncodedUri(id)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update priority
    #
    # + id - The ID of the issue priority
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    # 
    # # Deprecated
    @deprecated
    resource isolated function put priority/[string id](UpdatePriorityDetails payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/priority/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete priority
    #
    # + id - The ID of the issue priority
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete priority/[string id](map<string|string[]> headers = {}) returns http:Response|error {
        string resourcePath = string `/priority/${getEncodedUri(id)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get Jira instance info
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get serverInfo(map<string|string[]> headers = {}) returns ServerInformation|error {
        string resourcePath = string `/serverInfo`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update custom field value
    #
    # + fieldIdOrKey - The ID or key of the custom field. For example, `customfield_10010`
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put app/'field/[string fieldIdOrKey]/value(CustomFieldValueUpdateDetails payload, map<string|string[]> headers = {}, *UpdateCustomFieldValueQueries queries) returns json|error {
        string resourcePath = string `/app/field/${getEncodedUri(fieldIdOrKey)}/value`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get data policy for the workspace
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get data\-policy(map<string|string[]> headers = {}) returns WorkspaceDataPolicy|error {
        string resourcePath = string `/data-policy`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Bulk move worklogs
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - A JSON object containing a list of worklog IDs and the ID or key of the destination issue 
    # + return - Returned if the request is partially successful 
    resource isolated function post issue/[string issueIdOrKey]/worklog/move(WorklogsMoveRequestBean payload, map<string|string[]> headers = {}, *BulkMoveWorklogsQueries queries) returns error? {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/worklog/move`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get contents metadata for an expanded attachment
    #
    # + id - The ID of the attachment
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful. If an empty list is returned in the response, the attachment is empty, corrupt, or not an archive 
    resource isolated function get attachment/[string id]/expand/raw(map<string|string[]> headers = {}) returns AttachmentArchiveImpl|error {
        string resourcePath = string `/attachment/${getEncodedUri(id)}/expand/raw`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get comments by IDs
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The list of comment IDs 
    # + return - Returned if the request is successful 
    resource isolated function post comment/list(IssueCommentListRequestBean payload, map<string|string[]> headers = {}, *GetCommentsByIdsQueries queries) returns PageBeanComment|error {
        string resourcePath = string `/comment/list`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Bulk set issue properties by issue
    #
    # + headers - Headers to be sent with the request 
    # + payload - Details of the issue properties to be set or updated. Note that if an issue is not found, it is ignored 
    # + return - Returned if the operation is successful 
    resource isolated function post issue/properties/multi(MultiIssueEntityProperties payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/issue/properties/multi`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get worklog property keys
    #
    # + issueIdOrKey - The ID or key of the issue
    # + worklogId - The ID of the worklog
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issue/[string issueIdOrKey]/worklog/[string worklogId]/properties(map<string|string[]> headers = {}) returns PropertyKeys|error {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/worklog/${getEncodedUri(worklogId)}/properties`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get workflow transition rule configurations
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get workflow/rule/config(map<string|string[]> headers = {}, *GetWorkflowTransitionRuleConfigurationsQueries queries) returns PageBeanWorkflowTransitionRules|error {
        string resourcePath = string `/workflow/rule/config`;
        map<Encoding> queryParamEncoding = {"types": {style: FORM, explode: true}, "keys": {style: FORM, explode: true}, "workflowNames": {style: FORM, explode: true}, "withTags": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update workflow transition rule configurations
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put workflow/rule/config(WorkflowTransitionRulesUpdate payload, map<string|string[]> headers = {}) returns WorkflowTransitionRulesUpdateErrors|error {
        string resourcePath = string `/workflow/rule/config`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Bulk move issues
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post bulk/issues/move(IssueBulkMovePayload payload, map<string|string[]> headers = {}) returns SubmittedBulkOperation|error {
        string resourcePath = string `/bulk/issues/move`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete issue security scheme
    #
    # + schemeId - The ID of the issue security scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete issuesecurityschemes/[string schemeId](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/issuesecurityschemes/${getEncodedUri(schemeId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Load project avatar
    #
    # + projectIdOrKey - The ID or (case-sensitive) key of the project
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post project/[string projectIdOrKey]/avatar2(http:Request request, map<string|string[]> headers = {}, *CreateProjectAvatarQueries queries) returns Avatar|error {
        string resourcePath = string `/project/${getEncodedUri(projectIdOrKey)}/avatar2`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        // TODO: Update the request as needed;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get all metadata for an expanded attachment
    #
    # + id - The ID of the attachment
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful. If an empty list is returned in the response, the attachment is empty, corrupt, or not an archive 
    resource isolated function get attachment/[string id]/expand/human(map<string|string[]> headers = {}) returns AttachmentArchiveMetadataReadable|error {
        string resourcePath = string `/attachment/${getEncodedUri(id)}/expand/human`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get dashboard item property keys
    #
    # + dashboardId - The ID of the dashboard
    # + itemId - The ID of the dashboard item
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get dashboard/[string dashboardId]/items/[string itemId]/properties(map<string|string[]> headers = {}) returns PropertyKeys|error {
        string resourcePath = string `/dashboard/${getEncodedUri(dashboardId)}/items/${getEncodedUri(itemId)}/properties`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Remove screen tab field
    #
    # + screenId - The ID of the screen
    # + tabId - The ID of the screen tab
    # + id - The ID of the field
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete screens/[int screenId]/tabs/[int tabId]/fields/[string id](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/screens/${getEncodedUri(screenId)}/tabs/${getEncodedUri(tabId)}/fields/${getEncodedUri(id)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Assign custom field context to projects
    #
    # + fieldId - The ID of the custom field
    # + contextId - The ID of the context
    # + headers - Headers to be sent with the request 
    # + return - Returned if operation is successful 
    resource isolated function put 'field/[string fieldId]/context/[int contextId]/project(ProjectIds payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/field/${getEncodedUri(fieldId)}/context/${getEncodedUri(contextId)}/project`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get changelogs by IDs
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post issue/[string issueIdOrKey]/changelog/list(IssueChangelogIds payload, map<string|string[]> headers = {}) returns PageOfChangelogs|error {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/changelog/list`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Search workflows
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get workflows/search(map<string|string[]> headers = {}, *SearchWorkflowsQueries queries) returns WorkflowSearchResponse|error {
        string resourcePath = string `/workflows/search`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get issue type property keys
    #
    # + issueTypeId - The ID of the issue type
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issuetype/[string issueTypeId]/properties(map<string|string[]> headers = {}) returns PropertyKeys|error {
        string resourcePath = string `/issuetype/${getEncodedUri(issueTypeId)}/properties`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get projects using notification schemes paginated
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get notificationscheme/project(map<string|string[]> headers = {}, *GetNotificationSchemeToProjectMappingsQueries queries) returns PageBeanNotificationSchemeAndProjectMappingJsonBean|error {
        string resourcePath = string `/notificationscheme/project`;
        map<Encoding> queryParamEncoding = {"notificationSchemeId": {style: FORM, explode: true}, "projectId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get available gadgets
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get dashboard/gadgets(map<string|string[]> headers = {}) returns AvailableDashboardGadgetsResponse|error {
        string resourcePath = string `/dashboard/gadgets`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update screen scheme
    #
    # + screenSchemeId - The ID of the screen scheme
    # + headers - Headers to be sent with the request 
    # + payload - The screen scheme update details 
    # + return - Returned if the request is successful 
    resource isolated function put screenscheme/[string screenSchemeId](UpdateScreenSchemeDetails payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/screenscheme/${getEncodedUri(screenSchemeId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete screen scheme
    #
    # + screenSchemeId - The ID of the screen scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the screen scheme is deleted 
    resource isolated function delete screenscheme/[string screenSchemeId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/screenscheme/${getEncodedUri(screenSchemeId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get plan
    #
    # + planId - The ID of the plan
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get plans/plan/[int planId](map<string|string[]> headers = {}, *GetPlanQueries queries) returns GetPlanResponse|error {
        string resourcePath = string `/plans/plan/${getEncodedUri(planId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update plan
    #
    # + planId - The ID of the plan
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put plans/plan/[int planId](record {} payload, map<string|string[]> headers = {}, *UpdatePlanQueries queries) returns json|error {
        string resourcePath = string `/plans/plan/${getEncodedUri(planId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json-patch+json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Create issue link
    #
    # + headers - Headers to be sent with the request 
    # + payload - The issue link request 
    # + return - Returned if the request is successful 
    resource isolated function post issueLink(LinkIssueRequestJsonBean payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/issueLink`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get all issue type schemes
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issuetypescheme(map<string|string[]> headers = {}, *GetAllIssueTypeSchemesQueries queries) returns PageBeanIssueTypeScheme|error {
        string resourcePath = string `/issuetypescheme`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create issue type scheme
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post issuetypescheme(IssueTypeSchemeDetails payload, map<string|string[]> headers = {}) returns IssueTypeSchemeID|error {
        string resourcePath = string `/issuetypescheme`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Create plan-only team
    #
    # + planId - The ID of the plan
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post plans/plan/[int planId]/team/planonly(CreatePlanOnlyTeamRequest payload, map<string|string[]> headers = {}) returns int|error {
        string resourcePath = string `/plans/plan/${getEncodedUri(planId)}/team/planonly`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get screen schemes
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get screenscheme(map<string|string[]> headers = {}, *GetScreenSchemesQueries queries) returns PageBeanScreenScheme|error {
        string resourcePath = string `/screenscheme`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create screen scheme
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post screenscheme(ScreenSchemeDetails payload, map<string|string[]> headers = {}) returns ScreenSchemeId|error {
        string resourcePath = string `/screenscheme`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get draft default workflow
    #
    # + id - The ID of the workflow scheme that the draft belongs to
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get workflowscheme/[int id]/draft/default(map<string|string[]> headers = {}) returns DefaultWorkflow|error {
        string resourcePath = string `/workflowscheme/${getEncodedUri(id)}/draft/default`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update draft default workflow
    #
    # + id - The ID of the workflow scheme that the draft belongs to
    # + headers - Headers to be sent with the request 
    # + payload - The object for the new default workflow 
    # + return - Returned if the request is successful 
    resource isolated function put workflowscheme/[int id]/draft/default(DefaultWorkflow payload, map<string|string[]> headers = {}) returns WorkflowScheme|error {
        string resourcePath = string `/workflowscheme/${getEncodedUri(id)}/draft/default`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete draft default workflow
    #
    # + id - The ID of the workflow scheme that the draft belongs to
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete workflowscheme/[int id]/draft/default(map<string|string[]> headers = {}) returns WorkflowScheme|error {
        string resourcePath = string `/workflowscheme/${getEncodedUri(id)}/draft/default`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Analyse Jira expression
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The Jira expressions to analyse 
    # + return - Returned if the request is successful 
    resource isolated function post expression/analyse(JiraExpressionForAnalysis payload, map<string|string[]> headers = {}, *AnalyseExpressionQueries queries) returns JiraExpressionsAnalysis|error {
        string resourcePath = string `/expression/analyse`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get field reference data (GET)
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get jql/autocompletedata(map<string|string[]> headers = {}) returns JQLReferenceData|error {
        string resourcePath = string `/jql/autocompletedata`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get field reference data (POST)
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post jql/autocompletedata(SearchAutoCompleteFilter payload, map<string|string[]> headers = {}) returns JQLReferenceData|error {
        string resourcePath = string `/jql/autocompletedata`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get all project types
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get project/'type(map<string|string[]> headers = {}) returns ProjectType[]|error {
        string resourcePath = string `/project/type`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete workflow transition rule configurations
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put workflow/rule/config/delete(WorkflowsWithTransitionRulesDetails payload, map<string|string[]> headers = {}) returns WorkflowTransitionRulesUpdateErrors|error {
        string resourcePath = string `/workflow/rule/config/delete`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get remote issue links
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issue/[string issueIdOrKey]/remotelink(map<string|string[]> headers = {}, *GetRemoteIssueLinksQueries queries) returns RemoteIssueLink|error {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/remotelink`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create or update remote issue link
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + return - Returned if the remote issue link is updated 
    resource isolated function post issue/[string issueIdOrKey]/remotelink(RemoteIssueLinkRequest payload, map<string|string[]> headers = {}) returns RemoteIssueLinkIdentifies|error {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/remotelink`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete remote issue link by global ID
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete issue/[string issueIdOrKey]/remotelink(map<string|string[]> headers = {}, *DeleteRemoteIssueLinkByGlobalIdQueries queries) returns error? {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/remotelink`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Assign issue types to field configurations
    #
    # + id - The ID of the field configuration scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put fieldconfigurationscheme/[int id]/mapping(AssociateFieldConfigurationsWithIssueTypesRequest payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/fieldconfigurationscheme/${getEncodedUri(id)}/mapping`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Bulk fetch changelogs
    #
    # + headers - Headers to be sent with the request 
    # + payload - A JSON object containing the bulk fetch changelog request filters such as issue IDs and field IDs 
    # + return - Returned if the request is successful 
    resource isolated function post changelog/bulkfetch(BulkChangelogRequestBean payload, map<string|string[]> headers = {}) returns BulkChangelogResponseBean|error {
        string resourcePath = string `/changelog/bulkfetch`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get field configuration schemes for projects
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get fieldconfigurationscheme/project(map<string|string[]> headers = {}, *GetFieldConfigurationSchemeProjectMappingQueries queries) returns PageBeanFieldConfigurationSchemeProjects|error {
        string resourcePath = string `/fieldconfigurationscheme/project`;
        map<Encoding> queryParamEncoding = {"projectId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Assign field configuration scheme to project
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put fieldconfigurationscheme/project(FieldConfigurationSchemeProjectAssociation payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/fieldconfigurationscheme/project`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get time tracking settings
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get configuration/timetracking/options(map<string|string[]> headers = {}) returns TimeTrackingConfiguration|error {
        string resourcePath = string `/configuration/timetracking/options`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set time tracking settings
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put configuration/timetracking/options(TimeTrackingConfiguration payload, map<string|string[]> headers = {}) returns TimeTrackingConfiguration|error {
        string resourcePath = string `/configuration/timetracking/options`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get worklog
    #
    # + issueIdOrKey - The ID or key of the issue
    # + id - The ID of the worklog
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issue/[string issueIdOrKey]/worklog/[string id](map<string|string[]> headers = {}, *GetWorklogQueries queries) returns Worklog|error {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/worklog/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update worklog
    #
    # + issueIdOrKey - The ID or key the issue
    # + id - The ID of the worklog
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put issue/[string issueIdOrKey]/worklog/[string id](Worklog payload, map<string|string[]> headers = {}, *UpdateWorklogQueries queries) returns Worklog|error {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/worklog/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete worklog
    #
    # + issueIdOrKey - The ID or key of the issue
    # + id - The ID of the worklog
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete issue/[string issueIdOrKey]/worklog/[string id](map<string|string[]> headers = {}, *DeleteWorklogQueries queries) returns error? {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/worklog/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get create metadata issue types for a project
    #
    # + projectIdOrKey - The ID or key of the project
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issue/createmeta/[string projectIdOrKey]/issuetypes(map<string|string[]> headers = {}, *GetCreateIssueMetaIssueTypesQueries queries) returns PageOfCreateMetaIssueTypes|error {
        string resourcePath = string `/issue/createmeta/${getEncodedUri(projectIdOrKey)}/issuetypes`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get project notification scheme
    #
    # + projectKeyOrId - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get project/[string projectKeyOrId]/notificationscheme(map<string|string[]> headers = {}, *GetNotificationSchemeForProjectQueries queries) returns NotificationScheme|error {
        string resourcePath = string `/project/${getEncodedUri(projectKeyOrId)}/notificationscheme`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get project property
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + propertyKey - The project property key. Use [Get project property keys](#api-rest-api-3-project-projectIdOrKey-properties-get) to get a list of all project property keys
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get project/[string projectIdOrKey]/properties/[string propertyKey](map<string|string[]> headers = {}) returns EntityProperty|error {
        string resourcePath = string `/project/${getEncodedUri(projectIdOrKey)}/properties/${getEncodedUri(propertyKey)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set project property
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + propertyKey - The key of the project property. The maximum length is 255 characters
    # + headers - Headers to be sent with the request 
    # + payload - The value of the property. The value has to be a valid, non-empty [JSON](https://tools.ietf.org/html/rfc4627) value. The maximum length of the property value is 32768 bytes 
    # + return - Returned if the project property is updated 
    resource isolated function put project/[string projectIdOrKey]/properties/[string propertyKey](json payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/project/${getEncodedUri(projectIdOrKey)}/properties/${getEncodedUri(propertyKey)}`;
        http:Request request = new;
        request.setPayload(payload, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete project property
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + propertyKey - The project property key. Use [Get project property keys](#api-rest-api-3-project-projectIdOrKey-properties-get) to get a list of all project property keys
    # + headers - Headers to be sent with the request 
    # + return - Returned if the project property is deleted 
    resource isolated function delete project/[string projectIdOrKey]/properties/[string propertyKey](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/project/${getEncodedUri(projectIdOrKey)}/properties/${getEncodedUri(propertyKey)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get group
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    # 
    # # Deprecated
    @deprecated
    resource isolated function get group(map<string|string[]> headers = {}, *GetGroupQueries queries) returns Group|error {
        string resourcePath = string `/group`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create group
    #
    # + headers - Headers to be sent with the request 
    # + payload - The name of the group 
    # + return - Returned if the request is successful 
    resource isolated function post group(AddGroupBean payload, map<string|string[]> headers = {}) returns Group|error {
        string resourcePath = string `/group`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Remove group
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete group(map<string|string[]> headers = {}, *RemoveGroupQueries queries) returns error? {
        string resourcePath = string `/group`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get data policy for projects
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get data\-policy/project(map<string|string[]> headers = {}, *GetPoliciesQueries queries) returns ProjectDataPolicies|error {
        string resourcePath = string `/data-policy/project`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get dashboard
    #
    # + id - The ID of the dashboard
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get dashboard/[string id](map<string|string[]> headers = {}) returns Dashboard|error {
        string resourcePath = string `/dashboard/${getEncodedUri(id)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update dashboard
    #
    # + id - The ID of the dashboard to update
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Replacement dashboard details 
    # + return - Returned if the request is successful 
    resource isolated function put dashboard/[string id](DashboardDetails payload, map<string|string[]> headers = {}, *UpdateDashboardQueries queries) returns Dashboard|error {
        string resourcePath = string `/dashboard/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete dashboard
    #
    # + id - The ID of the dashboard
    # + headers - Headers to be sent with the request 
    # + return - Returned if the dashboard is deleted 
    resource isolated function delete dashboard/[string id](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/dashboard/${getEncodedUri(id)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get custom field configurations
    #
    # + fieldIdOrKey - The ID or key of the custom field, for example `customfield_10000`
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get app/'field/[string fieldIdOrKey]/context/configuration(map<string|string[]> headers = {}, *GetCustomFieldConfigurationQueries queries) returns PageBeanContextualConfiguration|error {
        string resourcePath = string `/app/field/${getEncodedUri(fieldIdOrKey)}/context/configuration`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}, "fieldContextId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update custom field configurations
    #
    # + fieldIdOrKey - The ID or key of the custom field, for example `customfield_10000`
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put app/'field/[string fieldIdOrKey]/context/configuration(CustomFieldConfigurations payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/app/field/${getEncodedUri(fieldIdOrKey)}/context/configuration`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get permission scheme grant
    #
    # + schemeId - The ID of the permission scheme
    # + permissionId - The ID of the permission grant
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get permissionscheme/[int schemeId]/permission/[int permissionId](map<string|string[]> headers = {}, *GetPermissionSchemeGrantQueries queries) returns PermissionGrant|error {
        string resourcePath = string `/permissionscheme/${getEncodedUri(schemeId)}/permission/${getEncodedUri(permissionId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete permission scheme grant
    #
    # + schemeId - The ID of the permission scheme to delete the permission grant from
    # + permissionId - The ID of the permission grant to delete
    # + headers - Headers to be sent with the request 
    # + return - Returned if the permission grant is deleted 
    resource isolated function delete permissionscheme/[int schemeId]/permission/[int permissionId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/permissionscheme/${getEncodedUri(schemeId)}/permission/${getEncodedUri(permissionId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get audit records
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get auditing/'record(map<string|string[]> headers = {}, *GetAuditRecordsQueries queries) returns AuditRecords|error {
        string resourcePath = string `/auditing/record`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get UI modifications
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get uiModifications(map<string|string[]> headers = {}, *GetUiModificationsQueries queries) returns PageBeanUiModificationDetails|error {
        string resourcePath = string `/uiModifications`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create UI modification
    #
    # + headers - Headers to be sent with the request 
    # + payload - Details of the UI modification 
    # + return - Returned if the UI modification is created 
    resource isolated function post uiModifications(CreateUiModificationDetails payload, map<string|string[]> headers = {}) returns UiModificationIdentifiers|error {
        string resourcePath = string `/uiModifications`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Validate create workflows
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post workflows/create/validation(WorkflowCreateValidateRequest payload, map<string|string[]> headers = {}) returns WorkflowValidationErrorList|error {
        string resourcePath = string `/workflows/create/validation`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Remove member from issue security level
    #
    # + schemeId - The ID of the issue security scheme
    # + levelId - The ID of the issue security level
    # + memberId - The ID of the issue security level member to be removed
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete issuesecurityschemes/[string schemeId]/level/[string levelId]/member/[string memberId](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/issuesecurityschemes/${getEncodedUri(schemeId)}/level/${getEncodedUri(levelId)}/member/${getEncodedUri(memberId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get version
    #
    # + id - The ID of the version
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get version/[string id](map<string|string[]> headers = {}, *GetVersionQueries queries) returns Version|error {
        string resourcePath = string `/version/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update version
    #
    # + id - The ID of the version
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put version/[string id](Version payload, map<string|string[]> headers = {}) returns Version|error {
        string resourcePath = string `/version/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete version
    #
    # + id - The ID of the version
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the version is deleted 
    # 
    # # Deprecated
    @deprecated
    resource isolated function delete version/[string id](map<string|string[]> headers = {}, *DeleteVersionQueries queries) returns error? {
        string resourcePath = string `/version/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Append mappings to issue type screen scheme
    #
    # + issueTypeScreenSchemeId - The ID of the issue type screen scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put issuetypescreenscheme/[string issueTypeScreenSchemeId]/mapping(IssueTypeScreenSchemeMappingDetails payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/issuetypescreenscheme/${getEncodedUri(issueTypeScreenSchemeId)}/mapping`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get all permissions
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get permissions(map<string|string[]> headers = {}) returns Permissions|error {
        string resourcePath = string `/permissions`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get priorities
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    # 
    # # Deprecated
    @deprecated
    resource isolated function get priority(map<string|string[]> headers = {}) returns Priority[]|error {
        string resourcePath = string `/priority`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create priority
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    # 
    # # Deprecated
    @deprecated
    resource isolated function post priority(CreatePriorityDetails payload, map<string|string[]> headers = {}) returns PriorityId|error {
        string resourcePath = string `/priority`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get alternative issue types
    #
    # + id - The ID of the issue type
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issuetype/[string id]/alternatives(map<string|string[]> headers = {}) returns IssueTypeDetails[]|error {
        string resourcePath = string `/issuetype/${getEncodedUri(id)}/alternatives`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get issue type schemes for projects
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issuetypescheme/project(map<string|string[]> headers = {}, *GetIssueTypeSchemeForProjectsQueries queries) returns PageBeanIssueTypeSchemeProjects|error {
        string resourcePath = string `/issuetypescheme/project`;
        map<Encoding> queryParamEncoding = {"projectId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Assign issue type scheme to project
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put issuetypescheme/project(IssueTypeSchemeProjectAssociation payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/issuetypescheme/project`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get precomputations by ID (apps)
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post jql/'function/computation/search(JqlFunctionPrecomputationGetByIdRequest payload, map<string|string[]> headers = {}, *GetPrecomputationsByIDQueries queries) returns JqlFunctionPrecomputationGetByIdResponse|error {
        string resourcePath = string `/jql/function/computation/search`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Evaluate Jira expression using enhanced search API
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The Jira expression and the evaluation context 
    # + return - Returned if the evaluation results in a value. The result is a JSON primitive value, list, or object 
    resource isolated function post expression/evaluate(JiraExpressionEvaluateRequestBean payload, map<string|string[]> headers = {}, *EvaluateJSISJiraExpressionQueries queries) returns JExpEvaluateJiraExpressionResultBean|error {
        string resourcePath = string `/expression/evaluate`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Update issue type screen scheme default screen scheme
    #
    # + issueTypeScreenSchemeId - The ID of the issue type screen scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put issuetypescreenscheme/[string issueTypeScreenSchemeId]/mapping/default(UpdateDefaultScreenScheme payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/issuetypescreenscheme/${getEncodedUri(issueTypeScreenSchemeId)}/mapping/default`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get users from group
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get group/member(map<string|string[]> headers = {}, *GetUsersFromGroupQueries queries) returns PageBeanUserDetails|error {
        string resourcePath = string `/group/member`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Sanitize JQL queries
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post jql/sanitize(JqlQueriesToSanitize payload, map<string|string[]> headers = {}) returns SanitizedJqlQueries|error {
        string resourcePath = string `/jql/sanitize`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get issue link type
    #
    # + issueLinkTypeId - The ID of the issue link type
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issueLinkType/[string issueLinkTypeId](map<string|string[]> headers = {}) returns IssueLinkType|error {
        string resourcePath = string `/issueLinkType/${getEncodedUri(issueLinkTypeId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update issue link type
    #
    # + issueLinkTypeId - The ID of the issue link type
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put issueLinkType/[string issueLinkTypeId](IssueLinkType payload, map<string|string[]> headers = {}) returns IssueLinkType|error {
        string resourcePath = string `/issueLinkType/${getEncodedUri(issueLinkTypeId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete issue link type
    #
    # + issueLinkTypeId - The ID of the issue link type
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete issueLinkType/[string issueLinkTypeId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/issueLinkType/${getEncodedUri(issueLinkTypeId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    resource isolated function post project/[string projectIdOrKey](map<string|string[]> headers = {}) returns Project|error {
        string resourcePath = string `/project/${getEncodedUri(projectIdOrKey)}ore`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Redact
    #
    # + headers - Headers to be sent with the request 
    # + payload - List of redaction requests 
    # + return - Returned if the job submission is successful. The response contains the job id 
    resource isolated function post redact(BulkRedactionRequest payload, map<string|string[]> headers = {}) returns string|error {
        string resourcePath = string `/redact`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Update custom field
    #
    # + fieldId - The ID of the custom field
    # + headers - Headers to be sent with the request 
    # + payload - The custom field update details 
    # + return - Returned if the request is successful 
    resource isolated function put 'field/[string fieldId](UpdateCustomFieldDetails payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/field/${getEncodedUri(fieldId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get status category
    #
    # + idOrKey - The ID or key of the status category
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get statuscategory/[string idOrKey](map<string|string[]> headers = {}) returns StatusCategory|error {
        string resourcePath = string `/statuscategory/${getEncodedUri(idOrKey)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get user groups
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get user/groups(map<string|string[]> headers = {}, *GetUserGroupsQueries queries) returns GroupName[]|error {
        string resourcePath = string `/user/groups`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get avatar image by owner
    #
    # + 'type - The icon type of the avatar
    # + entityId - The ID of the project or issue type the avatar belongs to
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get universal_avatar/view/'type/["issuetype"|"project"|"priority" 'type]/owner/[string entityId](map<string|string[]> headers = {}, *GetAvatarImageByOwnerQueries queries) returns StreamingResponseBody|error {
        string resourcePath = string `/universal_avatar/view/type/${getEncodedUri('type)}/owner/${getEncodedUri(entityId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get all users default
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get users(map<string|string[]> headers = {}, *GetAllUsersDefaultQueries queries) returns User[]|error {
        string resourcePath = string `/users`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Reorder custom field options (context)
    #
    # + fieldId - The ID of the custom field
    # + contextId - The ID of the context
    # + headers - Headers to be sent with the request 
    # + return - Returned if options are reordered 
    resource isolated function put 'field/[string fieldId]/context/[int contextId]/option/move(OrderOfCustomFieldOptions payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/field/${getEncodedUri(fieldId)}/context/${getEncodedUri(contextId)}/option/move`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get issue worklogs
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issue/[string issueIdOrKey]/worklog(map<string|string[]> headers = {}, *GetIssueWorklogQueries queries) returns PageOfWorklogs|error {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/worklog`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add worklog
    #
    # + issueIdOrKey - The ID or key the issue
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post issue/[string issueIdOrKey]/worklog(Worklog payload, map<string|string[]> headers = {}, *AddWorklogQueries queries) returns Worklog|error {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/worklog`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Bulk delete worklogs
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - A JSON object containing a list of worklog IDs 
    # + return - Returned if the bulk deletion request was partially successful, with a message indicating partial success 
    resource isolated function delete issue/[string issueIdOrKey]/worklog(WorklogIdsRequestBean payload, map<string|string[]> headers = {}, *BulkDeleteWorklogsQueries queries) returns error? {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/worklog`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->delete(resourcePath, request, headers);
    }

    # Get issue security level members
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issuesecurityschemes/level/member(map<string|string[]> headers = {}, *GetSecurityLevelMembersQueries queries) returns PageBeanSecurityLevelMember|error {
        string resourcePath = string `/issuesecurityschemes/level/member`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}, "schemeId": {style: FORM, explode: true}, "levelId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get project components
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get project/[string projectIdOrKey]/components(map<string|string[]> headers = {}, *GetProjectComponentsQueries queries) returns ProjectComponent[]|error {
        string resourcePath = string `/project/${getEncodedUri(projectIdOrKey)}/components`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Bulk edit dashboards
    #
    # + headers - Headers to be sent with the request 
    # + payload - The details of dashboards being updated in bulk 
    # + return - Returned if the request is successful 
    resource isolated function put dashboard/bulk/edit(BulkEditShareableEntityRequest payload, map<string|string[]> headers = {}) returns BulkEditShareableEntityResponse|error {
        string resourcePath = string `/dashboard/bulk/edit`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get issue type
    #
    # + id - The ID of the issue type
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issuetype/[string id](map<string|string[]> headers = {}) returns IssueTypeDetails|error {
        string resourcePath = string `/issuetype/${getEncodedUri(id)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update issue type
    #
    # + id - The ID of the issue type
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put issuetype/[string id](IssueTypeUpdateBean payload, map<string|string[]> headers = {}) returns IssueTypeDetails|error {
        string resourcePath = string `/issuetype/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete issue type
    #
    # + id - The ID of the issue type
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete issuetype/[string id](map<string|string[]> headers = {}, *DeleteIssueTypeQueries queries) returns error? {
        string resourcePath = string `/issuetype/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get project role by ID
    #
    # + id - The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get role/[int id](map<string|string[]> headers = {}) returns ProjectRole|error {
        string resourcePath = string `/role/${getEncodedUri(id)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Fully update project role
    #
    # + id - The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put role/[int id](CreateUpdateRoleRequestBean payload, map<string|string[]> headers = {}) returns ProjectRole|error {
        string resourcePath = string `/role/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Partial update project role
    #
    # + id - The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post role/[int id](CreateUpdateRoleRequestBean payload, map<string|string[]> headers = {}) returns ProjectRole|error {
        string resourcePath = string `/role/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete project role
    #
    # + id - The ID of the project role to delete. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete role/[int id](map<string|string[]> headers = {}, *DeleteProjectRoleQueries queries) returns error? {
        string resourcePath = string `/role/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get all statuses
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get status(map<string|string[]> headers = {}) returns StatusDetails[]|error {
        string resourcePath = string `/status`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get issue types for custom field context
    #
    # + fieldId - The ID of the custom field
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if operation is successful 
    resource isolated function get 'field/[string fieldId]/context/issuetypemapping(map<string|string[]> headers = {}, *GetIssueTypeMappingsForContextsQueries queries) returns PageBeanIssueTypeToContextMapping|error {
        string resourcePath = string `/field/${getEncodedUri(fieldId)}/context/issuetypemapping`;
        map<Encoding> queryParamEncoding = {"contextId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get create field metadata for a project and issue type id
    #
    # + projectIdOrKey - The ID or key of the project
    # + issueTypeId - The issuetype ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issue/createmeta/[string projectIdOrKey]/issuetypes/[string issueTypeId](map<string|string[]> headers = {}, *GetCreateIssueMetaIssueTypeIdQueries queries) returns PageOfCreateMetaIssueTypeWithField|error {
        string resourcePath = string `/issue/createmeta/${getEncodedUri(projectIdOrKey)}/issuetypes/${getEncodedUri(issueTypeId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get field auto complete suggestions
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get jql/autocompletedata/suggestions(map<string|string[]> headers = {}, *GetFieldAutoCompleteForQueryStringQueries queries) returns AutoCompleteSuggestions|error {
        string resourcePath = string `/jql/autocompletedata/suggestions`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get workflow scheme
    #
    # + id - The ID of the workflow scheme. Find this ID by editing the desired workflow scheme in Jira. The ID is shown in the URL as `schemeId`. For example, *schemeId=10301*
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get workflowscheme/[int id](map<string|string[]> headers = {}, *GetWorkflowSchemeQueries queries) returns WorkflowScheme|error {
        string resourcePath = string `/workflowscheme/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Classic update workflow scheme
    #
    # + id - The ID of the workflow scheme. Find this ID by editing the desired workflow scheme in Jira. The ID is shown in the URL as `schemeId`. For example, *schemeId=10301*
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put workflowscheme/[int id](WorkflowScheme payload, map<string|string[]> headers = {}) returns WorkflowScheme|error {
        string resourcePath = string `/workflowscheme/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete workflow scheme
    #
    # + id - The ID of the workflow scheme. Find this ID by editing the desired workflow scheme in Jira. The ID is shown in the URL as `schemeId`. For example, *schemeId=10301*
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete workflowscheme/[int id](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/workflowscheme/${getEncodedUri(id)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Find users by query
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get user/search/query(map<string|string[]> headers = {}, *FindUsersByQueryQueries queries) returns PageBeanUser|error {
        string resourcePath = string `/user/search/query`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get project role details
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get project/[string projectIdOrKey]/roledetails(map<string|string[]> headers = {}, *GetProjectRoleDetailsQueries queries) returns ProjectRoleDetails[]|error {
        string resourcePath = string `/project/${getEncodedUri(projectIdOrKey)}/roledetails`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get selected time tracking provider
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful and time tracking is enabled 
    resource isolated function get configuration/timetracking(map<string|string[]> headers = {}) returns TimeTrackingProvider|json|error {
        string resourcePath = string `/configuration/timetracking`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Select time tracking provider
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put configuration/timetracking(TimeTrackingProvider payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/configuration/timetracking`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Move custom field to trash
    #
    # + id - The ID of a custom field
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post 'field/[string id]/trash(map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/field/${getEncodedUri(id)}/trash`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Retrieve the attributes of service registries
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get atlassian\-connect/'1/service\-registry(map<string|string[]> headers = {}, *ServiceRegistryResourceServicesGetQueries queries) returns ServiceRegistry[]|error {
        string resourcePath = string `/atlassian-connect/1/service-registry`;
        map<Encoding> queryParamEncoding = {"serviceIds": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add filter as favorite
    #
    # + id - The ID of the filter
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put filter/[int id]/favourite(map<string|string[]> headers = {}, *SetFavouriteForFilterQueries queries) returns Filter|error {
        string resourcePath = string `/filter/${getEncodedUri(id)}/favourite`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Remove filter as favorite
    #
    # + id - The ID of the filter
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete filter/[int id]/favourite(map<string|string[]> headers = {}, *DeleteFavouriteForFilterQueries queries) returns Filter|error {
        string resourcePath = string `/filter/${getEncodedUri(id)}/favourite`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get required status mappings for workflow scheme update
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post workflowscheme/update/mappings(WorkflowSchemeUpdateRequiredMappingsRequest payload, map<string|string[]> headers = {}) returns WorkflowSchemeUpdateRequiredMappingsResponse|error {
        string resourcePath = string `/workflowscheme/update/mappings`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get visible issue field options
    #
    # + fieldKey - The field key is specified in the following format: **$(app-key)\_\_$(field-key)**. For example, *example-add-on\_\_example-issue-field*. To determine the `fieldKey` value, do one of the following:
    # *  open the app's plugin descriptor, then **app-key** is the key at the top and **field-key** is the key in the `jiraIssueFields` module. **app-key** can also be found in the app listing in the Atlassian Universal Plugin Manager.
    # *  run [Get fields](#api-rest-api-3-field-get) and in the field details the value is returned in `key`. For example, `"key": "teams-add-on__team-issue-field"`
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get 'field/[string fieldKey]/option/suggestions/search(map<string|string[]> headers = {}, *GetVisibleIssueFieldOptionsQueries queries) returns PageBeanIssueFieldOption|error {
        string resourcePath = string `/field/${getEncodedUri(fieldKey)}/option/suggestions/search`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get application role
    #
    # + 'key - The key of the application role. Use the [Get all application roles](#api-rest-api-3-applicationrole-get) operation to get the key for each application role
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get applicationrole/[string 'key](map<string|string[]> headers = {}) returns ApplicationRole|error {
        string resourcePath = string `/applicationrole/${getEncodedUri('key)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create filter
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The filter to create 
    # + return - Returned if the request is successful 
    resource isolated function post filter(Filter payload, map<string|string[]> headers = {}, *CreateFilterQueries queries) returns Filter|error {
        string resourcePath = string `/filter`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get Atlassian team in plan
    #
    # + planId - The ID of the plan
    # + atlassianTeamId - The ID of the Atlassian team
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get plans/plan/[int planId]/team/atlassian/[string atlassianTeamId](map<string|string[]> headers = {}) returns GetAtlassianTeamResponse|error {
        string resourcePath = string `/plans/plan/${getEncodedUri(planId)}/team/atlassian/${getEncodedUri(atlassianTeamId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update Atlassian team in plan
    #
    # + planId - The ID of the plan
    # + atlassianTeamId - The ID of the Atlassian team
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put plans/plan/[int planId]/team/atlassian/[string atlassianTeamId](record {} payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/plans/plan/${getEncodedUri(planId)}/team/atlassian/${getEncodedUri(atlassianTeamId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json-patch+json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Remove Atlassian team from plan
    #
    # + planId - The ID of the plan
    # + atlassianTeamId - The ID of the Atlassian team
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete plans/plan/[int planId]/team/atlassian/[string atlassianTeamId](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/plans/plan/${getEncodedUri(planId)}/team/atlassian/${getEncodedUri(atlassianTeamId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get issue type screen schemes for projects
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issuetypescreenscheme/project(map<string|string[]> headers = {}, *GetIssueTypeScreenSchemeProjectAssociationsQueries queries) returns PageBeanIssueTypeScreenSchemesProjects|error {
        string resourcePath = string `/issuetypescreenscheme/project`;
        map<Encoding> queryParamEncoding = {"projectId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Assign issue type screen scheme to project
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put issuetypescreenscheme/project(IssueTypeScreenSchemeProjectAssociation payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/issuetypescreenscheme/project`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get user email bulk
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get user/email/bulk(map<string|string[]> headers = {}, *GetUserEmailBulkQueries queries) returns UnrestrictedUserEmail|error {
        string resourcePath = string `/user/email/bulk`;
        map<Encoding> queryParamEncoding = {"accountId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get custom field contexts default values
    #
    # + fieldId - The ID of the custom field, for example `customfield\_10000`
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get 'field/[string fieldId]/context/defaultValue(map<string|string[]> headers = {}, *GetDefaultValuesQueries queries) returns PageBeanCustomFieldContextDefaultValue|error {
        string resourcePath = string `/field/${getEncodedUri(fieldId)}/context/defaultValue`;
        map<Encoding> queryParamEncoding = {"contextId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Set custom field contexts default values
    #
    # + fieldId - The ID of the custom field
    # + headers - Headers to be sent with the request 
    # + return - Returned if operation is successful 
    resource isolated function put 'field/[string fieldId]/context/defaultValue(CustomFieldContextDefaultValueUpdate payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/field/${getEncodedUri(fieldId)}/context/defaultValue`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get all screen tabs
    #
    # + screenId - The ID of the screen
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get screens/[int screenId]/tabs(map<string|string[]> headers = {}, *GetAllScreenTabsQueries queries) returns ScreenableTab[]|error {
        string resourcePath = string `/screens/${getEncodedUri(screenId)}/tabs`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create screen tab
    #
    # + screenId - The ID of the screen
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post screens/[int screenId]/tabs(ScreenableTab payload, map<string|string[]> headers = {}) returns ScreenableTab|error {
        string resourcePath = string `/screens/${getEncodedUri(screenId)}/tabs`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Replace issue field option
    #
    # + fieldKey - The field key is specified in the following format: **$(app-key)\_\_$(field-key)**. For example, *example-add-on\_\_example-issue-field*. To determine the `fieldKey` value, do one of the following:
    # *  open the app's plugin descriptor, then **app-key** is the key at the top and **field-key** is the key in the `jiraIssueFields` module. **app-key** can also be found in the app listing in the Atlassian Universal Plugin Manager.
    # *  run [Get fields](#api-rest-api-3-field-get) and in the field details the value is returned in `key`. For example, `"key": "teams-add-on__team-issue-field"`
    # + optionId - The ID of the option to be deselected
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the long-running task to deselect the option is started 
    resource isolated function delete 'field/[string fieldKey]/option/[int optionId]/issue(map<string|string[]> headers = {}, *ReplaceIssueFieldOptionQueries queries) returns http:Response|error {
        string resourcePath = string `/field/${getEncodedUri(fieldKey)}/option/${getEncodedUri(optionId)}/issue`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get issue types for workflows in draft workflow scheme
    #
    # + id - The ID of the workflow scheme that the draft belongs to
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get workflowscheme/[int id]/draft/workflow(map<string|string[]> headers = {}, *GetDraftWorkflowQueries queries) returns IssueTypesWorkflowMapping|error {
        string resourcePath = string `/workflowscheme/${getEncodedUri(id)}/draft/workflow`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Set issue types for workflow in workflow scheme
    #
    # + id - The ID of the workflow scheme that the draft belongs to
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put workflowscheme/[int id]/draft/workflow(IssueTypesWorkflowMapping payload, map<string|string[]> headers = {}, *UpdateDraftWorkflowMappingQueries queries) returns WorkflowScheme|error {
        string resourcePath = string `/workflowscheme/${getEncodedUri(id)}/draft/workflow`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete issue types for workflow in draft workflow scheme
    #
    # + id - The ID of the workflow scheme that the draft belongs to
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete workflowscheme/[int id]/draft/workflow(map<string|string[]> headers = {}, *DeleteDraftWorkflowMappingQueries queries) returns error? {
        string resourcePath = string `/workflowscheme/${getEncodedUri(id)}/draft/workflow`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Add attachment
    #
    # + issueIdOrKey - The ID or key of the issue that attachments are added to
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post issue/[string issueIdOrKey]/attachments(MultipartFile[] payload, map<string|string[]> headers = {}) returns Attachment[]|error {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/attachments`;
        http:Request request = new;
        mime:Entity[] bodyParts = check createBodyParts(check jsondata:toJson(payload).ensureType());
        request.setBodyParts(bodyParts);
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get all project categories
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get projectCategory(map<string|string[]> headers = {}) returns ProjectCategory[]|error {
        string resourcePath = string `/projectCategory`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create project category
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post projectCategory(ProjectCategory payload, map<string|string[]> headers = {}) returns ProjectCategory|error {
        string resourcePath = string `/projectCategory`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get changelogs
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issue/[string issueIdOrKey]/changelog(map<string|string[]> headers = {}, *GetChangeLogsQueries queries) returns PageBeanChangelog|error {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/changelog`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get all workflows
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    # 
    # # Deprecated
    @deprecated
    resource isolated function get workflow(map<string|string[]> headers = {}, *GetAllWorkflowsQueries queries) returns DeprecatedWorkflow[]|error {
        string resourcePath = string `/workflow`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create workflow
    #
    # + headers - Headers to be sent with the request 
    # + payload - The workflow details 
    # + return - Returned if the workflow is created 
    # 
    # # Deprecated
    @deprecated
    resource isolated function post workflow(CreateWorkflowDetails payload, map<string|string[]> headers = {}) returns WorkflowIDs|error {
        string resourcePath = string `/workflow`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Set app property (Forge)
    #
    # + propertyKey - The key of the property
    # + headers - Headers to be sent with the request 
    # + return - Returned if the property is updated 
    resource isolated function put forge/'1/app/properties/[string propertyKey](json payload, map<string|string[]> headers = {}) returns OperationMessage|error {
        string resourcePath = string `/forge/1/app/properties/${getEncodedUri(propertyKey)}`;
        http:Request request = new;
        request.setPayload(payload, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete app property (Forge)
    #
    # + propertyKey - The key of the property
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete forge/'1/app/properties/[string propertyKey](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/forge/1/app/properties/${getEncodedUri(propertyKey)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get custom field option
    #
    # + id - The ID of the custom field option
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get customFieldOption/[string id](map<string|string[]> headers = {}) returns CustomFieldOption|error {
        string resourcePath = string `/customFieldOption/${getEncodedUri(id)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get notification schemes paginated
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful. Only returns notification schemes that the user has permission to access. An empty list is returned if the user lacks permission to access all notification schemes 
    resource isolated function get notificationscheme(map<string|string[]> headers = {}, *GetNotificationSchemesQueries queries) returns PageBeanNotificationScheme|error {
        string resourcePath = string `/notificationscheme`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}, "projectId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create notification scheme
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post notificationscheme(CreateNotificationSchemeDetails payload, map<string|string[]> headers = {}) returns NotificationSchemeId|error {
        string resourcePath = string `/notificationscheme`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get system avatars by type
    #
    # + 'type - The avatar type
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get avatar/["issuetype"|"project"|"user"|"priority" 'type]/system(map<string|string[]> headers = {}) returns SystemAvatars|error {
        string resourcePath = string `/avatar/${getEncodedUri('type)}/system`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get projects by priority scheme
    #
    # + schemeId - The priority scheme ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get priorityscheme/[string schemeId]/projects(map<string|string[]> headers = {}, *GetProjectsByPrioritySchemeQueries queries) returns PageBeanProject|error {
        string resourcePath = string `/priorityscheme/${getEncodedUri(schemeId)}/projects`;
        map<Encoding> queryParamEncoding = {"projectId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Bulk get custom field configurations
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post app/'field/context/configuration/list(ConfigurationsListParameters payload, map<string|string[]> headers = {}, *GetCustomFieldsConfigurationsQueries queries) returns PageBeanBulkContextualConfiguration|error {
        string resourcePath = string `/app/field/context/configuration/list`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}, "fieldContextId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get all statuses for project
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get project/[string projectIdOrKey]/statuses(map<string|string[]> headers = {}) returns IssueTypeWithStatus[]|error {
        string resourcePath = string `/project/${getEncodedUri(projectIdOrKey)}/statuses`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Move screen tab field
    #
    # + screenId - The ID of the screen
    # + tabId - The ID of the screen tab
    # + id - The ID of the field
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post screens/[int screenId]/tabs/[int tabId]/fields/[string id]/move(MoveFieldBean payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/screens/${getEncodedUri(screenId)}/tabs/${getEncodedUri(tabId)}/fields/${getEncodedUri(id)}/move`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get all status categories
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get statuscategory(map<string|string[]> headers = {}) returns StatusCategory[]|error {
        string resourcePath = string `/statuscategory`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get projects paginated
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get project/search(map<string|string[]> headers = {}, *SearchProjectsQueries queries) returns PageBeanProject|error {
        string resourcePath = string `/project/search`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}, "keys": {style: FORM, explode: true}, "status": {style: FORM, explode: true}, "properties": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get all permission schemes
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get permissionscheme(map<string|string[]> headers = {}, *GetAllPermissionSchemesQueries queries) returns PermissionSchemes|error {
        string resourcePath = string `/permissionscheme`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create permission scheme
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The permission scheme to create 
    # + return - Returned if the permission scheme is created 
    resource isolated function post permissionscheme(PermissionScheme payload, map<string|string[]> headers = {}, *CreatePermissionSchemeQueries queries) returns PermissionScheme|error {
        string resourcePath = string `/permissionscheme`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Archive project
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post project/[string projectIdOrKey]/archive(map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/project/${getEncodedUri(projectIdOrKey)}/archive`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get project role for project
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + id - The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get project/[string projectIdOrKey]/role/[int id](map<string|string[]> headers = {}, *GetProjectRoleQueries queries) returns ProjectRole|error {
        string resourcePath = string `/project/${getEncodedUri(projectIdOrKey)}/role/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Set actors for project role
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + id - The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs
    # + headers - Headers to be sent with the request 
    # + payload - The groups or users to associate with the project role for this project. Provide the user account ID, group name, or group ID. As a group's name can change, use of group ID is recommended 
    # + return - Returned if the request is successful. The complete list of actors for the project is returned 
    resource isolated function put project/[string projectIdOrKey]/role/[int id](ProjectRoleActorsUpdateBean payload, map<string|string[]> headers = {}) returns ProjectRole|error {
        string resourcePath = string `/project/${getEncodedUri(projectIdOrKey)}/role/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Add actors to project role
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + id - The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs
    # + headers - Headers to be sent with the request 
    # + payload - The groups or users to associate with the project role for this project. Provide the user account ID, group name, or group ID. As a group's name can change, use of group ID is recommended 
    # + return - Returned if the request is successful. The complete list of actors for the project is returned. For example, the cURL request above adds a group, *jira-developers*. For the response below to be returned as a result of that request, the user *Mia Krystof* would have previously been added as a `user` actor for this project 
    resource isolated function post project/[string projectIdOrKey]/role/[int id](ActorsMap payload, map<string|string[]> headers = {}) returns ProjectRole|error {
        string resourcePath = string `/project/${getEncodedUri(projectIdOrKey)}/role/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete actors from project role
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + id - The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete project/[string projectIdOrKey]/role/[int id](map<string|string[]> headers = {}, *DeleteActorQueries queries) returns error? {
        string resourcePath = string `/project/${getEncodedUri(projectIdOrKey)}/role/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Bulk get statuses
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get statuses(map<string|string[]> headers = {}, *GetStatusesByIdQueries queries) returns JiraStatus[]|error {
        string resourcePath = string `/statuses`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Bulk update statuses
    #
    # + headers - Headers to be sent with the request 
    # + payload - The list of statuses that will be updated 
    # + return - Returned if the request is successful 
    resource isolated function put statuses(StatusUpdateRequest payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/statuses`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Bulk create statuses
    #
    # + headers - Headers to be sent with the request 
    # + payload - Details of the statuses being created and their scope 
    # + return - Returned if the request is successful 
    resource isolated function post statuses(StatusCreateRequest payload, map<string|string[]> headers = {}) returns JiraStatus[]|error {
        string resourcePath = string `/statuses`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Bulk delete Statuses
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete statuses(map<string|string[]> headers = {}, *DeleteStatusesByIdQueries queries) returns json|error {
        string resourcePath = string `/statuses`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get bulk issue operation progress
    #
    # + taskId - The ID of the task
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get bulk/queue/[string taskId](map<string|string[]> headers = {}) returns BulkOperationProgress|error {
        string resourcePath = string `/bulk/queue/${getEncodedUri(taskId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete notification scheme
    #
    # + notificationSchemeId - The ID of the notification scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete notificationscheme/[string notificationSchemeId](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/notificationscheme/${getEncodedUri(notificationSchemeId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get share permission
    #
    # + id - The ID of the filter
    # + permissionId - The ID of the share permission
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get filter/[int id]/permission/[int permissionId](map<string|string[]> headers = {}) returns SharePermission|error {
        string resourcePath = string `/filter/${getEncodedUri(id)}/permission/${getEncodedUri(permissionId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete share permission
    #
    # + id - The ID of the filter
    # + permissionId - The ID of the share permission
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete filter/[int id]/permission/[int permissionId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/filter/${getEncodedUri(id)}/permission/${getEncodedUri(permissionId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Move version
    #
    # + id - The ID of the version to be moved
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post version/[string id]/move(VersionMoveBean payload, map<string|string[]> headers = {}) returns Version|error {
        string resourcePath = string `/version/${getEncodedUri(id)}/move`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get issue types for project
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issuetype/project(map<string|string[]> headers = {}, *GetIssueTypesForProjectQueries queries) returns IssueTypeDetails[]|error {
        string resourcePath = string `/issuetype/project`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get transitions
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issue/[string issueIdOrKey]/transitions(map<string|string[]> headers = {}, *GetTransitionsQueries queries) returns Transitions|error {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/transitions`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Transition issue
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post issue/[string issueIdOrKey]/transitions(IssueUpdateDetails payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/transitions`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get all labels
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get label(map<string|string[]> headers = {}, *GetAllLabelsQueries queries) returns PageBeanString|error {
        string resourcePath = string `/label`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get avatars
    #
    # + 'type - The avatar type
    # + entityId - The ID of the item the avatar is associated with
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get universal_avatar/'type/["project"|"issuetype"|"priority" 'type]/owner/[string entityId](map<string|string[]> headers = {}) returns Avatars|error {
        string resourcePath = string `/universal_avatar/type/${getEncodedUri('type)}/owner/${getEncodedUri(entityId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Load avatar
    #
    # + 'type - The avatar type
    # + entityId - The ID of the item the avatar is associated with
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post universal_avatar/'type/["project"|"issuetype"|"priority" 'type]/owner/[string entityId](http:Request request, map<string|string[]> headers = {}, *StoreAvatarQueries queries) returns Avatar|error {
        string resourcePath = string `/universal_avatar/type/${getEncodedUri('type)}/owner/${getEncodedUri(entityId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        // TODO: Update the request as needed;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get component
    #
    # + id - The ID of the component
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get component/[string id](map<string|string[]> headers = {}) returns ProjectComponent|error {
        string resourcePath = string `/component/${getEncodedUri(id)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update component
    #
    # + id - The ID of the component
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put component/[string id](ProjectComponent payload, map<string|string[]> headers = {}) returns ProjectComponent|error {
        string resourcePath = string `/component/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete component
    #
    # + id - The ID of the component
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete component/[string id](map<string|string[]> headers = {}, *DeleteComponentQueries queries) returns error? {
        string resourcePath = string `/component/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Delete project avatar
    #
    # + projectIdOrKey - The project ID or (case-sensitive) key
    # + id - The ID of the avatar
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete project/[string projectIdOrKey]/avatar/[int id](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/project/${getEncodedUri(projectIdOrKey)}/avatar/${getEncodedUri(id)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Create version
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post version(Version payload, map<string|string[]> headers = {}) returns Version|error {
        string resourcePath = string `/version`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Bulk get users
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get user/bulk(map<string|string[]> headers = {}, *BulkGetUsersQueries queries) returns PageBeanUser|error {
        string resourcePath = string `/user/bulk`;
        map<Encoding> queryParamEncoding = {"username": {style: FORM, explode: true}, "key": {style: FORM, explode: true}, "accountId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get bulk permissions
    #
    # + headers - Headers to be sent with the request 
    # + payload - Details of the permissions to check 
    # + return - Returned if the request is successful 
    resource isolated function post permissions/'check(BulkPermissionsRequestBean payload, map<string|string[]> headers = {}) returns BulkPermissionGrants|error {
        string resourcePath = string `/permissions/check`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get fields in trash paginated
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get 'field/search/trashed(map<string|string[]> headers = {}, *GetTrashedFieldsPaginatedQueries queries) returns PageBeanField|error {
        string resourcePath = string `/field/search/trashed`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get project usages by status
    #
    # + statusId - The statusId to fetch project usages for
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get statuses/[string statusId]/projectUsages(map<string|string[]> headers = {}, *GetProjectUsagesForStatusQueries queries) returns StatusProjectUsageDTO|error {
        string resourcePath = string `/statuses/${getEncodedUri(statusId)}/projectUsages`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get issue limit report
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issue/'limit/report(map<string|string[]> headers = {}, *GetIssueLimitReportQueries queries) returns IssueLimitReportResponseBean|error {
        string resourcePath = string `/issue/limit/report`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete custom field options (context)
    #
    # + fieldId - The ID of the custom field
    # + contextId - The ID of the context from which an option should be deleted
    # + optionId - The ID of the option to delete
    # + headers - Headers to be sent with the request 
    # + return - Returned if the option is deleted 
    resource isolated function delete 'field/[string fieldId]/context/[int contextId]/option/[int optionId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/field/${getEncodedUri(fieldId)}/context/${getEncodedUri(contextId)}/option/${getEncodedUri(optionId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get issue property keys
    #
    # + issueIdOrKey - The key or ID of the issue
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issue/[string issueIdOrKey]/properties(map<string|string[]> headers = {}) returns PropertyKeys|error {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/properties`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Trash plan
    #
    # + planId - The ID of the plan
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put plans/plan/[int planId]/trash(map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/plans/plan/${getEncodedUri(planId)}/trash`;
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Create associations
    #
    # + headers - Headers to be sent with the request 
    # + payload - Payload containing the fields to associate and the projects to associate them to 
    # + return - Returned if the field association validation passes 
    resource isolated function put 'field/association(FieldAssociationsRequest payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/field/association`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Remove associations
    #
    # + headers - Headers to be sent with the request 
    # + payload - Payload containing the fields to uassociate and the projects and issue types to unassociate them to 
    # + return - Returned if the field association validation passes 
    resource isolated function delete 'field/association(FieldAssociationsRequest payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/field/association`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->delete(resourcePath, request, headers);
    }

    # Bulk set issue property
    #
    # + propertyKey - The key of the property. The maximum length is 255 characters
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put issue/properties/[string propertyKey](BulkIssuePropertyUpdateRequest payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/issue/properties/${getEncodedUri(propertyKey)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Bulk delete issue property
    #
    # + propertyKey - The key of the property
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete issue/properties/[string propertyKey](IssueFilterForBulkPropertyDelete payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/issue/properties/${getEncodedUri(propertyKey)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->delete(resourcePath, request, headers);
    }

    # Get all workflow schemes
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get workflowscheme(map<string|string[]> headers = {}, *GetAllWorkflowSchemesQueries queries) returns PageBeanWorkflowScheme|error {
        string resourcePath = string `/workflowscheme`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create workflow scheme
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post workflowscheme(WorkflowScheme payload, map<string|string[]> headers = {}) returns WorkflowScheme|error {
        string resourcePath = string `/workflowscheme`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get user property keys
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get user/properties(map<string|string[]> headers = {}, *GetUserPropertyKeysQueries queries) returns PropertyKeys|error {
        string resourcePath = string `/user/properties`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get user property
    #
    # + propertyKey - The key of the user's property
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get user/properties/[string propertyKey](map<string|string[]> headers = {}, *GetUserPropertyQueries queries) returns EntityProperty|error {
        string resourcePath = string `/user/properties/${getEncodedUri(propertyKey)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Set user property
    #
    # + propertyKey - The key of the user's property. The maximum length is 255 characters
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The value of the property. The value has to be a valid, non-empty [JSON](https://tools.ietf.org/html/rfc4627) value. The maximum length of the property value is 32768 bytes 
    # + return - Returned if the user property is updated 
    resource isolated function put user/properties/[string propertyKey](json payload, map<string|string[]> headers = {}, *SetUserPropertyQueries queries) returns json|error {
        string resourcePath = string `/user/properties/${getEncodedUri(propertyKey)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        request.setPayload(payload, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete user property
    #
    # + propertyKey - The key of the user's property
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the user property is deleted 
    resource isolated function delete user/properties/[string propertyKey](map<string|string[]> headers = {}, *DeleteUserPropertyQueries queries) returns error? {
        string resourcePath = string `/user/properties/${getEncodedUri(propertyKey)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get project type by key
    #
    # + projectTypeKey - The key of the project type
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get project/'type/["software"|"service_desk"|"business"|"product_discovery" projectTypeKey](map<string|string[]> headers = {}) returns ProjectType|error {
        string resourcePath = string `/project/type/${getEncodedUri(projectTypeKey)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Find users with browse permission
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get user/viewissue/search(map<string|string[]> headers = {}, *FindUsersWithBrowsePermissionQueries queries) returns User[]|error {
        string resourcePath = string `/user/viewissue/search`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Search for issues using JQL (GET)
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    # 
    # # Deprecated
    @deprecated
    resource isolated function get search(map<string|string[]> headers = {}, *SearchForIssuesUsingJqlQueries queries) returns SearchResults|error {
        string resourcePath = string `/search`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: true}, "properties": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Search for issues using JQL (POST)
    #
    # + headers - Headers to be sent with the request 
    # + payload - A JSON object containing the search request 
    # + return - Returned if the request is successful 
    # 
    # # Deprecated
    @deprecated
    resource isolated function post search(SearchRequestBean payload, map<string|string[]> headers = {}) returns SearchResults|error {
        string resourcePath = string `/search`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get IDs of deleted worklogs
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get worklog/deleted(map<string|string[]> headers = {}, *GetIdsOfWorklogsDeletedSinceQueries queries) returns ChangedWorklogs|error {
        string resourcePath = string `/worklog/deleted`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get advanced settings
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get application\-properties/advanced\-settings(map<string|string[]> headers = {}) returns ApplicationProperty[]|error {
        string resourcePath = string `/application-properties/advanced-settings`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get available workflow capabilities
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get workflows/capabilities(map<string|string[]> headers = {}, *WorkflowCapabilitiesQueries queries) returns WorkflowCapabilities|error {
        string resourcePath = string `/workflows/capabilities`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Cancel task
    #
    # + taskId - The ID of the task
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post task/[string taskId]/cancel(map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/task/${getEncodedUri(taskId)}/cancel`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Add Atlassian team to plan
    #
    # + planId - The ID of the plan
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post plans/plan/[int planId]/team/atlassian(AddAtlassianTeamRequest payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/plans/plan/${getEncodedUri(planId)}/team/atlassian`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get announcement banner configuration
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get announcementBanner(map<string|string[]> headers = {}) returns AnnouncementBannerConfiguration|error {
        string resourcePath = string `/announcementBanner`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update announcement banner configuration
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put announcementBanner(AnnouncementBannerConfigurationUpdate payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/announcementBanner`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Bulk delete issues
    #
    # + headers - Headers to be sent with the request 
    # + payload - The request body containing the issues to be deleted 
    # + return - Returned if the request is successful 
    resource isolated function post bulk/issues/delete(IssueBulkDeletePayload payload, map<string|string[]> headers = {}) returns SubmittedBulkOperation|error {
        string resourcePath = string `/bulk/issues/delete`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get user
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get user(map<string|string[]> headers = {}, *GetUserQueries queries) returns User|error {
        string resourcePath = string `/user`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create user
    #
    # + headers - Headers to be sent with the request 
    # + payload - Details about the user to be created 
    # + return - Returned if the request is successful 
    resource isolated function post user(NewUserDetails payload, map<string|string[]> headers = {}) returns User|error {
        string resourcePath = string `/user`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete user
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete user(map<string|string[]> headers = {}, *RemoveUserQueries queries) returns error? {
        string resourcePath = string `/user`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get permitted projects
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post permissions/project(PermissionsKeysBean payload, map<string|string[]> headers = {}) returns PermittedProjects|error {
        string resourcePath = string `/permissions/project`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get project versions
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get project/[string projectIdOrKey]/versions(map<string|string[]> headers = {}, *GetProjectVersionsQueries queries) returns Version[]|error {
        string resourcePath = string `/project/${getEncodedUri(projectIdOrKey)}/versions`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Move priorities
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put priority/move(ReorderIssuePriorities payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/priority/move`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get status
    #
    # + idOrName - The ID or name of the status
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get status/[string idOrName](map<string|string[]> headers = {}) returns StatusDetails|error {
        string resourcePath = string `/status/${getEncodedUri(idOrName)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get custom field contexts
    #
    # + fieldId - The ID of the custom field
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get 'field/[string fieldId]/context(map<string|string[]> headers = {}, *GetContextsForFieldQueries queries) returns PageBeanCustomFieldContext|error {
        string resourcePath = string `/field/${getEncodedUri(fieldId)}/context`;
        map<Encoding> queryParamEncoding = {"contextId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create custom field context
    #
    # + fieldId - The ID of the custom field
    # + headers - Headers to be sent with the request 
    # + return - Returned if the custom field context is created 
    resource isolated function post 'field/[string fieldId]/context(CreateCustomFieldContext payload, map<string|string[]> headers = {}) returns CreateCustomFieldContext|error {
        string resourcePath = string `/field/${getEncodedUri(fieldId)}/context`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get draft workflow scheme
    #
    # + id - The ID of the active workflow scheme that the draft was created from
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get workflowscheme/[int id]/draft(map<string|string[]> headers = {}) returns WorkflowScheme|error {
        string resourcePath = string `/workflowscheme/${getEncodedUri(id)}/draft`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update draft workflow scheme
    #
    # + id - The ID of the active workflow scheme that the draft was created from
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put workflowscheme/[int id]/draft(WorkflowScheme payload, map<string|string[]> headers = {}) returns WorkflowScheme|error {
        string resourcePath = string `/workflowscheme/${getEncodedUri(id)}/draft`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete draft workflow scheme
    #
    # + id - The ID of the active workflow scheme that the draft was created from
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete workflowscheme/[int id]/draft(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/workflowscheme/${getEncodedUri(id)}/draft`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Remove custom field context from projects
    #
    # + fieldId - The ID of the custom field
    # + contextId - The ID of the context
    # + headers - Headers to be sent with the request 
    # + return - Returned if the custom field context is removed from the projects 
    resource isolated function post 'field/[string fieldId]/context/[int contextId]/project/remove(ProjectIds payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/field/${getEncodedUri(fieldId)}/context/${getEncodedUri(contextId)}/project/remove`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Copy dashboard
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Dashboard details 
    # + return - Returned if the request is successful 
    resource isolated function post dashboard/[string id]/copy(DashboardDetails payload, map<string|string[]> headers = {}, *CopyDashboardQueries queries) returns Dashboard|error {
        string resourcePath = string `/dashboard/${getEncodedUri(id)}/copy`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get share permissions
    #
    # + id - The ID of the filter
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get filter/[int id]/permission(map<string|string[]> headers = {}) returns SharePermission[]|error {
        string resourcePath = string `/filter/${getEncodedUri(id)}/permission`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Add share permission
    #
    # + id - The ID of the filter
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post filter/[int id]/permission(SharePermissionInputBean payload, map<string|string[]> headers = {}) returns SharePermission[]|error {
        string resourcePath = string `/filter/${getEncodedUri(id)}/permission`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Add issue types to context
    #
    # + fieldId - The ID of the custom field
    # + contextId - The ID of the context
    # + headers - Headers to be sent with the request 
    # + return - Returned if operation is successful 
    resource isolated function put 'field/[string fieldId]/context/[int contextId]/issuetype(IssueTypeIds payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/field/${getEncodedUri(fieldId)}/context/${getEncodedUri(contextId)}/issuetype`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get all application roles
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get applicationrole(map<string|string[]> headers = {}) returns ApplicationRole[]|error {
        string resourcePath = string `/applicationrole`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update field configuration
    #
    # + id - The ID of the field configuration
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put fieldconfiguration/[int id](FieldConfigurationDetails payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/fieldconfiguration/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete field configuration
    #
    # + id - The ID of the field configuration
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete fieldconfiguration/[int id](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/fieldconfiguration/${getEncodedUri(id)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get attachment metadata
    #
    # + id - The ID of the attachment
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get attachment/[string id](map<string|string[]> headers = {}) returns AttachmentMetadata|error {
        string resourcePath = string `/attachment/${getEncodedUri(id)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete attachment
    #
    # + id - The ID of the attachment
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete attachment/[string id](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/attachment/${getEncodedUri(id)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update screen
    #
    # + screenId - The ID of the screen
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put screens/[int screenId](UpdateScreenDetails payload, map<string|string[]> headers = {}) returns Screen|error {
        string resourcePath = string `/screens/${getEncodedUri(screenId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete screen
    #
    # + screenId - The ID of the screen
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete screens/[int screenId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/screens/${getEncodedUri(screenId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get attachment thumbnail
    #
    # + id - The ID of the attachment
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful when `redirect` is set to `false` 
    resource isolated function get attachment/thumbnail/[string id](map<string|string[]> headers = {}, *GetAttachmentThumbnailQueries queries) returns anydata[]|error? {
        string resourcePath = string `/attachment/thumbnail/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Set project avatar
    #
    # + projectIdOrKey - The ID or (case-sensitive) key of the project
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put project/[string projectIdOrKey]/avatar(Avatar payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/project/${getEncodedUri(projectIdOrKey)}/avatar`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Publish draft workflow scheme
    #
    # + id - The ID of the workflow scheme that the draft belongs to
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Details of the status mappings 
    # + return - Returned if the request is only for validation and is successful 
    resource isolated function post workflowscheme/[int id]/draft/publish(PublishDraftWorkflowScheme payload, map<string|string[]> headers = {}, *PublishDraftWorkflowSchemeQueries queries) returns error? {
        string resourcePath = string `/workflowscheme/${getEncodedUri(id)}/draft/publish`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get projects using a given workflow
    #
    # + workflowId - The workflow ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get workflow/[string workflowId]/projectUsages(map<string|string[]> headers = {}, *GetProjectUsagesForWorkflowQueries queries) returns WorkflowProjectUsageDTO|error {
        string resourcePath = string `/workflow/${getEncodedUri(workflowId)}/projectUsages`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Duplicate plan
    #
    # + planId - The ID of the plan
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post plans/plan/[int planId]/duplicate(DuplicatePlanRequest payload, map<string|string[]> headers = {}) returns int|error {
        string resourcePath = string `/plans/plan/${getEncodedUri(planId)}/duplicate`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get permission scheme
    #
    # + schemeId - The ID of the permission scheme to return
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get permissionscheme/[int schemeId](map<string|string[]> headers = {}, *GetPermissionSchemeQueries queries) returns PermissionScheme|error {
        string resourcePath = string `/permissionscheme/${getEncodedUri(schemeId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update permission scheme
    #
    # + schemeId - The ID of the permission scheme to update
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the scheme is updated 
    resource isolated function put permissionscheme/[int schemeId](PermissionScheme payload, map<string|string[]> headers = {}, *UpdatePermissionSchemeQueries queries) returns PermissionScheme|error {
        string resourcePath = string `/permissionscheme/${getEncodedUri(schemeId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete permission scheme
    #
    # + schemeId - The ID of the permission scheme being deleted
    # + headers - Headers to be sent with the request 
    # + return - Returned if the permission scheme is deleted 
    resource isolated function delete permissionscheme/[int schemeId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/permissionscheme/${getEncodedUri(schemeId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get project components paginated
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get project/[string projectIdOrKey]/component(map<string|string[]> headers = {}, *GetProjectComponentsPaginatedQueries queries) returns PageBeanComponentWithIssueCount|error {
        string resourcePath = string `/project/${getEncodedUri(projectIdOrKey)}/component`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Change filter owner
    #
    # + id - The ID of the filter to update
    # + headers - Headers to be sent with the request 
    # + payload - The account ID of the new owner of the filter 
    # + return - Returned if the request is successful 
    resource isolated function put filter/[int id]/owner(ChangeFilterOwner payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/filter/${getEncodedUri(id)}/owner`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Send notification for issue
    #
    # + issueIdOrKey - ID or key of the issue that the notification is sent for
    # + headers - Headers to be sent with the request 
    # + payload - The request object for the notification and recipients 
    # + return - Returned if the email is queued for sending 
    resource isolated function post issue/[string issueIdOrKey]/notify(Notification payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/notify`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get issue type property
    #
    # + issueTypeId - The ID of the issue type
    # + propertyKey - The key of the property. Use [Get issue type property keys](#api-rest-api-3-issuetype-issueTypeId-properties-get) to get a list of all issue type property keys
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issuetype/[string issueTypeId]/properties/[string propertyKey](map<string|string[]> headers = {}) returns EntityProperty|error {
        string resourcePath = string `/issuetype/${getEncodedUri(issueTypeId)}/properties/${getEncodedUri(propertyKey)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set issue type property
    #
    # + issueTypeId - The ID of the issue type
    # + propertyKey - The key of the issue type property. The maximum length is 255 characters
    # + headers - Headers to be sent with the request 
    # + payload - The value of the property. The value has to be a valid, non-empty [JSON](https://tools.ietf.org/html/rfc4627) value. The maximum length of the property value is 32768 bytes 
    # + return - Returned if the issue type property is updated 
    resource isolated function put issuetype/[string issueTypeId]/properties/[string propertyKey](json payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/issuetype/${getEncodedUri(issueTypeId)}/properties/${getEncodedUri(propertyKey)}`;
        http:Request request = new;
        request.setPayload(payload, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete issue type property
    #
    # + issueTypeId - The ID of the issue type
    # + propertyKey - The key of the property. Use [Get issue type property keys](#api-rest-api-3-issuetype-issueTypeId-properties-get) to get a list of all issue type property keys
    # + headers - Headers to be sent with the request 
    # + return - Returned if the issue type property is deleted 
    resource isolated function delete issuetype/[string issueTypeId]/properties/[string propertyKey](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/issuetype/${getEncodedUri(issueTypeId)}/properties/${getEncodedUri(propertyKey)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Bulk fetch issues
    #
    # + headers - Headers to be sent with the request 
    # + payload - A JSON object containing the information about which issues and fields to fetch 
    # + return - Returned if the request is successful. A response may contain both successful issues and issue errors 
    resource isolated function post issue/bulkfetch(BulkFetchIssueRequestBean payload, map<string|string[]> headers = {}) returns BulkIssueResults|error {
        string resourcePath = string `/issue/bulkfetch`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get issue security scheme
    #
    # + id - The ID of the issue security scheme. Use the [Get issue security schemes](#api-rest-api-3-issuesecurityschemes-get) operation to get a list of issue security scheme IDs
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issuesecurityschemes/[int id](map<string|string[]> headers = {}) returns SecurityScheme|error {
        string resourcePath = string `/issuesecurityschemes/${getEncodedUri(id)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update issue security scheme
    #
    # + id - The ID of the issue security scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put issuesecurityschemes/[string id](UpdateIssueSecuritySchemeRequestBean payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/issuesecurityschemes/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Bulk unwatch issues
    #
    # + headers - Headers to be sent with the request 
    # + payload - The request body containing the issues to be unwatched 
    # + return - Returned if the request is successful 
    resource isolated function post bulk/issues/unwatch(IssueBulkWatchOrUnwatchPayload payload, map<string|string[]> headers = {}) returns SubmittedBulkOperation|error {
        string resourcePath = string `/bulk/issues/unwatch`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Find groups
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get groups/picker(map<string|string[]> headers = {}, *FindGroupsQueries queries) returns FoundGroups|error {
        string resourcePath = string `/groups/picker`;
        map<Encoding> queryParamEncoding = {"exclude": {style: FORM, explode: true}, "excludeId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get preference
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get mypreferences(map<string|string[]> headers = {}, *GetPreferenceQueries queries) returns string|error {
        string resourcePath = string `/mypreferences`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Set preference
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The value of the preference as a plain text string. The maximum length is 255 characters 
    # + return - Returned if the request is successful 
    resource isolated function put mypreferences(string payload, map<string|string[]> headers = {}, *SetPreferenceQueries queries) returns json|error {
        string resourcePath = string `/mypreferences`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete preference
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete mypreferences(map<string|string[]> headers = {}, *RemovePreferenceQueries queries) returns error? {
        string resourcePath = string `/mypreferences`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Create custom project
    #
    # + headers - Headers to be sent with the request 
    # + payload - The JSON payload containing the project details and capabilities 
    # + return - The project creation task has been queued for execution 
    resource isolated function post project\-template(ProjectCustomTemplateCreateRequestDTO payload, map<string|string[]> headers = {}) returns http:Response|error {
        string resourcePath = string `/project-template`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get IDs of updated worklogs
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get worklog/updated(map<string|string[]> headers = {}, *GetIdsOfWorklogsModifiedSinceQueries queries) returns ChangedWorklogs|error {
        string resourcePath = string `/worklog/updated`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Evaluate Jira expression
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The Jira expression and the evaluation context 
    # + return - Returned if the evaluation results in a value. The result is a JSON primitive value, list, or object 
    # 
    # # Deprecated
    @deprecated
    resource isolated function post expression/eval(JiraExpressionEvalRequestBean payload, map<string|string[]> headers = {}, *EvaluateJiraExpressionQueries queries) returns JiraExpressionResult|error {
        string resourcePath = string `/expression/eval`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get project mappings for custom field context
    #
    # + fieldId - The ID of the custom field, for example `customfield\_10000`
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get 'field/[string fieldId]/context/projectmapping(map<string|string[]> headers = {}, *GetProjectContextMappingQueries queries) returns PageBeanCustomFieldContextProjectMapping|error {
        string resourcePath = string `/field/${getEncodedUri(fieldId)}/context/projectmapping`;
        map<Encoding> queryParamEncoding = {"contextId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get assigned permission scheme
    #
    # + projectKeyOrId - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get project/[string projectKeyOrId]/permissionscheme(map<string|string[]> headers = {}, *GetAssignedPermissionSchemeQueries queries) returns PermissionScheme|error {
        string resourcePath = string `/project/${getEncodedUri(projectKeyOrId)}/permissionscheme`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Assign permission scheme
    #
    # + projectKeyOrId - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put project/[string projectKeyOrId]/permissionscheme(IdBean payload, map<string|string[]> headers = {}, *AssignPermissionSchemeQueries queries) returns PermissionScheme|error {
        string resourcePath = string `/project/${getEncodedUri(projectKeyOrId)}/permissionscheme`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get workflow for issue type in draft workflow scheme
    #
    # + id - The ID of the workflow scheme that the draft belongs to
    # + issueType - The ID of the issue type
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get workflowscheme/[int id]/draft/issuetype/[string issueType](map<string|string[]> headers = {}) returns IssueTypeWorkflowMapping|error {
        string resourcePath = string `/workflowscheme/${getEncodedUri(id)}/draft/issuetype/${getEncodedUri(issueType)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set workflow for issue type in draft workflow scheme
    #
    # + id - The ID of the workflow scheme that the draft belongs to
    # + issueType - The ID of the issue type
    # + headers - Headers to be sent with the request 
    # + payload - The issue type-project mapping 
    # + return - Returned if the request is successful 
    resource isolated function put workflowscheme/[int id]/draft/issuetype/[string issueType](IssueTypeWorkflowMapping payload, map<string|string[]> headers = {}) returns WorkflowScheme|error {
        string resourcePath = string `/workflowscheme/${getEncodedUri(id)}/draft/issuetype/${getEncodedUri(issueType)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete workflow for issue type in draft workflow scheme
    #
    # + id - The ID of the workflow scheme that the draft belongs to
    # + issueType - The ID of the issue type
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete workflowscheme/[int id]/draft/issuetype/[string issueType](map<string|string[]> headers = {}) returns WorkflowScheme|error {
        string resourcePath = string `/workflowscheme/${getEncodedUri(id)}/draft/issuetype/${getEncodedUri(issueType)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get remote issue link by ID
    #
    # + issueIdOrKey - The ID or key of the issue
    # + linkId - The ID of the remote issue link
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issue/[string issueIdOrKey]/remotelink/[string linkId](map<string|string[]> headers = {}) returns RemoteIssueLink|error {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/remotelink/${getEncodedUri(linkId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update remote issue link by ID
    #
    # + issueIdOrKey - The ID or key of the issue
    # + linkId - The ID of the remote issue link
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put issue/[string issueIdOrKey]/remotelink/[string linkId](RemoteIssueLinkRequest payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/remotelink/${getEncodedUri(linkId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete remote issue link by ID
    #
    # + issueIdOrKey - The ID or key of the issue
    # + linkId - The ID of a remote issue link
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete issue/[string issueIdOrKey]/remotelink/[string linkId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/remotelink/${getEncodedUri(linkId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Bulk get workflow schemes
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post workflowscheme/read(WorkflowSchemeReadRequest payload, map<string|string[]> headers = {}, *ReadWorkflowSchemesQueries queries) returns WorkflowSchemeReadResponse[]|error {
        string resourcePath = string `/workflowscheme/read`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get approximate application license count
    #
    # + applicationKey - The ID of the application, represents a specific version of Jira
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get license/approximateLicenseCount/product/["jira-core"|"jira-product-discovery"|"jira-software"|"jira-servicedesk" applicationKey](map<string|string[]> headers = {}) returns LicenseMetric|error {
        string resourcePath = string `/license/approximateLicenseCount/product/${getEncodedUri(applicationKey)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get project
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if successful 
    resource isolated function get project/[string projectIdOrKey](map<string|string[]> headers = {}, *GetProjectQueries queries) returns Project|error {
        string resourcePath = string `/project/${getEncodedUri(projectIdOrKey)}`;
        map<Encoding> queryParamEncoding = {"properties": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update project
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The project details to be updated 
    # + return - Returned if the project is updated 
    resource isolated function put project/[string projectIdOrKey](UpdateProjectDetails payload, map<string|string[]> headers = {}, *UpdateProjectQueries queries) returns Project|error {
        string resourcePath = string `/project/${getEncodedUri(projectIdOrKey)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete project
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the project is deleted 
    resource isolated function delete project/[string projectIdOrKey](map<string|string[]> headers = {}, *DeleteProjectQueries queries) returns error? {
        string resourcePath = string `/project/${getEncodedUri(projectIdOrKey)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get columns
    #
    # + id - The ID of the filter
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get filter/[int id]/columns(map<string|string[]> headers = {}) returns ColumnItem[]|error {
        string resourcePath = string `/filter/${getEncodedUri(id)}/columns`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set columns
    #
    # + id - The ID of the filter
    # + headers - Headers to be sent with the request 
    # + request - The IDs of the fields to set as columns. In the form data, specify each field as `columns=id`, where `id` is the *id* of a field (as seen in the response for [Get fields](#api-rest-api-<ver>-field-get)). For example, `columns=summary` 
    # + return - Returned if the request is successful 
    resource isolated function put filter/[int id]/columns(http:Request request, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/filter/${getEncodedUri(id)}/columns`;
        // TODO: Update the request as needed;
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Reset columns
    #
    # + id - The ID of the filter
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete filter/[int id]/columns(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/filter/${getEncodedUri(id)}/columns`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Find users with permissions
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get user/permission/search(map<string|string[]> headers = {}, *FindUsersWithAllPermissionsQueries queries) returns User[]|error {
        string resourcePath = string `/user/permission/search`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get comment property
    #
    # + commentId - The ID of the comment
    # + propertyKey - The key of the property
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get comment/[string commentId]/properties/[string propertyKey](map<string|string[]> headers = {}) returns EntityProperty|error {
        string resourcePath = string `/comment/${getEncodedUri(commentId)}/properties/${getEncodedUri(propertyKey)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set comment property
    #
    # + commentId - The ID of the comment
    # + propertyKey - The key of the property. The maximum length is 255 characters
    # + headers - Headers to be sent with the request 
    # + payload - The value of the property. The value has to be a valid, non-empty [JSON](https://tools.ietf.org/html/rfc4627) value. The maximum length of the property value is 32768 bytes 
    # + return - Returned if the comment property is updated 
    resource isolated function put comment/[string commentId]/properties/[string propertyKey](json payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/comment/${getEncodedUri(commentId)}/properties/${getEncodedUri(propertyKey)}`;
        http:Request request = new;
        request.setPayload(payload, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete comment property
    #
    # + commentId - The ID of the comment
    # + propertyKey - The key of the property
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete comment/[string commentId]/properties/[string propertyKey](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/comment/${getEncodedUri(commentId)}/properties/${getEncodedUri(propertyKey)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get the default data classification level of a project
    #
    # + projectIdOrKey - The project ID or project key (case-sensitive)
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get project/[string projectIdOrKey]/classification\-level/default(map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/project/${getEncodedUri(projectIdOrKey)}/classification-level/default`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update the default data classification level of a project
    #
    # + projectIdOrKey - The project ID or project key (case-sensitive)
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put project/[string projectIdOrKey]/classification\-level/default(UpdateDefaultProjectClassificationBean payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/project/${getEncodedUri(projectIdOrKey)}/classification-level/default`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Remove the default data classification level from a project
    #
    # + projectIdOrKey - The project ID or project key (case-sensitive)
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete project/[string projectIdOrKey]/classification\-level/default(map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/project/${getEncodedUri(projectIdOrKey)}/classification-level/default`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get gadgets
    #
    # + dashboardId - The ID of the dashboard
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get dashboard/[int dashboardId]/gadget(map<string|string[]> headers = {}, *GetAllGadgetsQueries queries) returns DashboardGadgetResponse|error {
        string resourcePath = string `/dashboard/${getEncodedUri(dashboardId)}/gadget`;
        map<Encoding> queryParamEncoding = {"moduleKey": {style: FORM, explode: true}, "uri": {style: FORM, explode: true}, "gadgetId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add gadget to dashboard
    #
    # + dashboardId - The ID of the dashboard
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post dashboard/[int dashboardId]/gadget(DashboardGadgetSettings payload, map<string|string[]> headers = {}) returns DashboardGadget|error {
        string resourcePath = string `/dashboard/${getEncodedUri(dashboardId)}/gadget`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Search for issues using JQL enhanced search (GET)
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get search/jql(map<string|string[]> headers = {}, *SearchAndReconsileIssuesUsingJqlQueries queries) returns SearchAndReconcileResults|error {
        string resourcePath = string `/search/jql`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: true}, "properties": {style: FORM, explode: true}, "reconcileIssues": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Search for issues using JQL enhanced search (POST)
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post search/jql(SearchAndReconcileRequestBean payload, map<string|string[]> headers = {}) returns SearchAndReconcileResults|error {
        string resourcePath = string `/search/jql`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get project issue security levels
    #
    # + projectKeyOrId - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get project/[string projectKeyOrId]/securitylevel(map<string|string[]> headers = {}) returns ProjectIssueSecurityLevels|error {
        string resourcePath = string `/project/${getEncodedUri(projectKeyOrId)}/securitylevel`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get account IDs for users
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get user/bulk/migration(map<string|string[]> headers = {}, *BulkGetUsersMigrationQueries queries) returns UserMigrationBean[]|error {
        string resourcePath = string `/user/bulk/migration`;
        map<Encoding> queryParamEncoding = {"username": {style: FORM, explode: true}, "key": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get all classification levels
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get classification\-levels(map<string|string[]> headers = {}, *GetAllUserDataClassificationLevelsQueries queries) returns DataClassificationLevelsBean|error {
        string resourcePath = string `/classification-levels`;
        map<Encoding> queryParamEncoding = {"status": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get issue security level members by issue security scheme
    #
    # + issueSecuritySchemeId - The ID of the issue security scheme. Use the [Get issue security schemes](#api-rest-api-3-issuesecurityschemes-get) operation to get a list of issue security scheme IDs
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issuesecurityschemes/[int issueSecuritySchemeId]/members(map<string|string[]> headers = {}, *GetIssueSecurityLevelMembersQueries queries) returns PageBeanIssueSecurityLevelMember|error {
        string resourcePath = string `/issuesecurityschemes/${getEncodedUri(issueSecuritySchemeId)}/members`;
        map<Encoding> queryParamEncoding = {"issueSecurityLevelId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get project versions paginated
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get project/[string projectIdOrKey]/version(map<string|string[]> headers = {}, *GetProjectVersionsPaginatedQueries queries) returns PageBeanVersion|error {
        string resourcePath = string `/project/${getEncodedUri(projectIdOrKey)}/version`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get worklogs
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - A JSON object containing a list of worklog IDs 
    # + return - Returned if the request is successful 
    resource isolated function post worklog/list(WorklogIdsRequestBean payload, map<string|string[]> headers = {}, *GetWorklogsForIdsQueries queries) returns Worklog[]|error {
        string resourcePath = string `/worklog/list`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get issue type scheme items
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issuetypescheme/mapping(map<string|string[]> headers = {}, *GetIssueTypeSchemesMappingQueries queries) returns PageBeanIssueTypeSchemeMapping|error {
        string resourcePath = string `/issuetypescheme/mapping`;
        map<Encoding> queryParamEncoding = {"issueTypeSchemeId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get custom field contexts for projects and issue types
    #
    # + fieldId - The ID of the custom field
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The list of project and issue type mappings 
    # + return - Returned if the request is successful 
    resource isolated function post 'field/[string fieldId]/context/mapping(ProjectIssueTypeMappings payload, map<string|string[]> headers = {}, *GetCustomFieldContextsForProjectsAndIssueTypesQueries queries) returns PageBeanContextForProjectAndIssueType|error {
        string resourcePath = string `/field/${getEncodedUri(fieldId)}/context/mapping`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Parse JQL query
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post jql/parse(JqlQueriesToParse payload, map<string|string[]> headers = {}, *ParseJqlQueriesQueries queries) returns ParsedJqlQueries|error {
        string resourcePath = string `/jql/parse`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Set application property
    #
    # + id - The key of the application property to update
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put application\-properties/[string id](SimpleApplicationPropertyBean payload, map<string|string[]> headers = {}) returns ApplicationProperty|error {
        string resourcePath = string `/application-properties/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Load issue type avatar
    #
    # + id - The ID of the issue type
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post issuetype/[string id]/avatar2(http:Request request, map<string|string[]> headers = {}, *CreateIssueTypeAvatarQueries queries) returns Avatar|error {
        string resourcePath = string `/issuetype/${getEncodedUri(id)}/avatar2`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        // TODO: Update the request as needed;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get locale
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get mypreferences/locale(map<string|string[]> headers = {}) returns Locale|error {
        string resourcePath = string `/mypreferences/locale`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set locale
    #
    # + headers - Headers to be sent with the request 
    # + payload - The locale defined in a LocaleBean 
    # + return - Returned if the request is successful 
    # 
    # # Deprecated
    @deprecated
    resource isolated function put mypreferences/locale(Locale payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/mypreferences/locale`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete locale
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    # 
    # # Deprecated
    @deprecated
    resource isolated function delete mypreferences/locale(map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/mypreferences/locale`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Search for filters
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get filter/search(map<string|string[]> headers = {}, *GetFiltersPaginatedQueries queries) returns PageBeanFilterDetails|error {
        string resourcePath = string `/filter/search`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get issue types in a project that are using a given workflow
    #
    # + workflowId - The workflow ID
    # + projectId - The project ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get workflow/[string workflowId]/project/[int projectId]/issueTypeUsages(map<string|string[]> headers = {}, *GetWorkflowProjectIssueTypeUsagesQueries queries) returns WorkflowProjectIssueTypeUsageDTO|error {
        string resourcePath = string `/workflow/${getEncodedUri(workflowId)}/project/${getEncodedUri(projectId)}/issueTypeUsages`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get events
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get events(map<string|string[]> headers = {}) returns IssueEvent[]|error {
        string resourcePath = string `/events`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get issue security levels
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issuesecurityschemes/level(map<string|string[]> headers = {}, *GetSecurityLevelsQueries queries) returns PageBeanSecurityLevel|error {
        string resourcePath = string `/issuesecurityschemes/level`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}, "schemeId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get the user's default workflow editor
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get workflows/defaultEditor(map<string|string[]> headers = {}) returns DefaultWorkflowEditorResponse|error {
        string resourcePath = string `/workflows/defaultEditor`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get project roles for project
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get project/[string projectIdOrKey]/role(map<string|string[]> headers = {}) returns record {|string...;|}|error {
        string resourcePath = string `/project/${getEncodedUri(projectIdOrKey)}/role`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get redaction status
    #
    # + jobId - Redaction job id
    # + headers - Headers to be sent with the request 
    # + return - Returned if the job status is successfully retrieved 
    resource isolated function get redact/status/[string jobId](map<string|string[]> headers = {}) returns RedactionJobStatusResponse|error {
        string resourcePath = string `/redact/status/${getEncodedUri(jobId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Count issues using JQL
    #
    # + headers - Headers to be sent with the request 
    # + payload - A JSON object containing the search request 
    # + return - Returned if the request is successful 
    resource isolated function post search/approximate\-count(JQLCountRequestBean payload, map<string|string[]> headers = {}) returns JQLCountResultsBean|error {
        string resourcePath = string `/search/approximate-count`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get default workflow
    #
    # + id - The ID of the workflow scheme
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get workflowscheme/[int id]/default(map<string|string[]> headers = {}, *GetDefaultWorkflowQueries queries) returns DefaultWorkflow|error {
        string resourcePath = string `/workflowscheme/${getEncodedUri(id)}/default`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update default workflow
    #
    # + id - The ID of the workflow scheme
    # + headers - Headers to be sent with the request 
    # + payload - The new default workflow 
    # + return - Returned if the request is successful 
    resource isolated function put workflowscheme/[int id]/default(DefaultWorkflow payload, map<string|string[]> headers = {}) returns WorkflowScheme|error {
        string resourcePath = string `/workflowscheme/${getEncodedUri(id)}/default`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete default workflow
    #
    # + id - The ID of the workflow scheme
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete workflowscheme/[int id]/default(map<string|string[]> headers = {}, *DeleteDefaultWorkflowQueries queries) returns WorkflowScheme|error {
        string resourcePath = string `/workflowscheme/${getEncodedUri(id)}/default`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Remove issue types from field configuration scheme
    #
    # + id - The ID of the field configuration scheme
    # + headers - Headers to be sent with the request 
    # + payload - The issue type IDs to remove 
    # + return - Returned if the request is successful 
    resource isolated function post fieldconfigurationscheme/[int id]/mapping/delete(IssueTypeIdsToRemove payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/fieldconfigurationscheme/${getEncodedUri(id)}/mapping/delete`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get all field configuration schemes
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get fieldconfigurationscheme(map<string|string[]> headers = {}, *GetAllFieldConfigurationSchemesQueries queries) returns PageBeanFieldConfigurationScheme|error {
        string resourcePath = string `/fieldconfigurationscheme`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create field configuration scheme
    #
    # + headers - Headers to be sent with the request 
    # + payload - The details of the field configuration scheme 
    # + return - Returned if the request is successful 
    resource isolated function post fieldconfigurationscheme(UpdateFieldConfigurationSchemeDetails payload, map<string|string[]> headers = {}) returns FieldConfigurationScheme|error {
        string resourcePath = string `/fieldconfigurationscheme`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get screens
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get screens(map<string|string[]> headers = {}, *GetScreensQueries queries) returns PageBeanScreen|error {
        string resourcePath = string `/screens`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}, "scope": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create screen
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post screens(ScreenDetails payload, map<string|string[]> headers = {}) returns Screen|error {
        string resourcePath = string `/screens`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete project asynchronously
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post project/[string projectIdOrKey]/delete(map<string|string[]> headers = {}) returns http:Response|error {
        string resourcePath = string `/project/${getEncodedUri(projectIdOrKey)}/delete`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Add issue types to issue type scheme
    #
    # + issueTypeSchemeId - The ID of the issue type scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put issuetypescheme/[int issueTypeSchemeId]/issuetype(IssueTypeIds payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/issuetypescheme/${getEncodedUri(issueTypeSchemeId)}/issuetype`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get user email
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get user/email(map<string|string[]> headers = {}, *GetUserEmailQueries queries) returns UnrestrictedUserEmail|error {
        string resourcePath = string `/user/email`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get default share scope
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get filter/defaultShareScope(map<string|string[]> headers = {}) returns DefaultShareScope|error {
        string resourcePath = string `/filter/defaultShareScope`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set default share scope
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put filter/defaultShareScope(DefaultShareScope payload, map<string|string[]> headers = {}) returns DefaultShareScope|error {
        string resourcePath = string `/filter/defaultShareScope`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Bulk create workflows
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post workflows/create(WorkflowCreateRequest payload, map<string|string[]> headers = {}) returns WorkflowCreateResponse|error {
        string resourcePath = string `/workflows/create`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get recent projects
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get project/recent(map<string|string[]> headers = {}, *GetRecentQueries queries) returns Project[]|error {
        string resourcePath = string `/project/recent`;
        map<Encoding> queryParamEncoding = {"properties": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update screen tab
    #
    # + screenId - The ID of the screen
    # + tabId - The ID of the screen tab
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put screens/[int screenId]/tabs/[int tabId](ScreenableTab payload, map<string|string[]> headers = {}) returns ScreenableTab|error {
        string resourcePath = string `/screens/${getEncodedUri(screenId)}/tabs/${getEncodedUri(tabId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete screen tab
    #
    # + screenId - The ID of the screen
    # + tabId - The ID of the screen tab
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete screens/[int screenId]/tabs/[int tabId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/screens/${getEncodedUri(screenId)}/tabs/${getEncodedUri(tabId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get task
    #
    # + taskId - The ID of the task
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get task/[string taskId](map<string|string[]> headers = {}) returns TaskProgressBeanObject|error {
        string resourcePath = string `/task/${getEncodedUri(taskId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Find users and groups
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get groupuserpicker(map<string|string[]> headers = {}, *FindUsersAndGroupsQueries queries) returns FoundUsersAndGroups|error {
        string resourcePath = string `/groupuserpicker`;
        map<Encoding> queryParamEncoding = {"projectId": {style: FORM, explode: true}, "issueTypeId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Remove issue type from issue type scheme
    #
    # + issueTypeSchemeId - The ID of the issue type scheme
    # + issueTypeId - The ID of the issue type
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete issuetypescheme/[int issueTypeSchemeId]/issuetype/[int issueTypeId](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/issuetypescheme/${getEncodedUri(issueTypeSchemeId)}/issuetype/${getEncodedUri(issueTypeId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get priorities by priority scheme
    #
    # + schemeId - The priority scheme ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get priorityscheme/[string schemeId]/priorities(map<string|string[]> headers = {}, *GetPrioritiesByPrioritySchemeQueries queries) returns PageBeanPriorityWithSequence|error {
        string resourcePath = string `/priorityscheme/${getEncodedUri(schemeId)}/priorities`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Set default priority
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put priority/default(SetDefaultPriorityRequest payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/priority/default`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Extend webhook life
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put webhook/refresh(ContainerForWebhookIDs payload, map<string|string[]> headers = {}) returns WebhooksExpirationDate|error {
        string resourcePath = string `/webhook/refresh`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get project property keys
    #
    # + projectIdOrKey - The project ID or project key (case sensitive)
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get project/[string projectIdOrKey]/properties(map<string|string[]> headers = {}) returns PropertyKeys|error {
        string resourcePath = string `/project/${getEncodedUri(projectIdOrKey)}/properties`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Add issue security level members
    #
    # + schemeId - The ID of the issue security scheme
    # + levelId - The ID of the issue security level
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put issuesecurityschemes/[string schemeId]/level/[string levelId]/member(SecuritySchemeMembersRequest payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/issuesecurityschemes/${getEncodedUri(schemeId)}/level/${getEncodedUri(levelId)}/member`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Change order of issue types
    #
    # + issueTypeSchemeId - The ID of the issue type scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put issuetypescheme/[int issueTypeSchemeId]/issuetype/move(OrderOfIssueTypes payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/issuetypescheme/${getEncodedUri(issueTypeSchemeId)}/issuetype/move`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get projects using issue security schemes
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issuesecurityschemes/project(map<string|string[]> headers = {}, *SearchProjectsUsingSecuritySchemesQueries queries) returns PageBeanIssueSecuritySchemeToProjectMapping|error {
        string resourcePath = string `/issuesecurityschemes/project`;
        map<Encoding> queryParamEncoding = {"issueSecuritySchemeId": {style: FORM, explode: true}, "projectId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Associate security scheme to project
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put issuesecurityschemes/project(AssociateSecuritySchemeWithProjectDetails payload, map<string|string[]> headers = {}) returns http:Response|error {
        string resourcePath = string `/issuesecurityschemes/project`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get precomputations (apps)
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get jql/'function/computation(map<string|string[]> headers = {}, *GetPrecomputationsQueries queries) returns PageBean2JqlFunctionPrecomputationBean|error {
        string resourcePath = string `/jql/function/computation`;
        map<Encoding> queryParamEncoding = {"functionKey": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update precomputations (apps)
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - 200 response 
    resource isolated function post jql/'function/computation(JqlFunctionPrecomputationUpdateRequestBean payload, map<string|string[]> headers = {}, *UpdatePrecomputationsQueries queries) returns JqlFunctionPrecomputationUpdateResponse|json|error {
        string resourcePath = string `/jql/function/computation`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Add field to default screen
    #
    # + fieldId - The ID of the field
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post screens/addToDefault/[string fieldId](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/screens/addToDefault/${getEncodedUri(fieldId)}`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get my permissions
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get mypermissions(map<string|string[]> headers = {}, *GetMyPermissionsQueries queries) returns Permissions|error {
        string resourcePath = string `/mypermissions`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Search resolutions
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get resolution/search(map<string|string[]> headers = {}, *SearchResolutionsQueries queries) returns PageBeanResolutionJsonBean|error {
        string resourcePath = string `/resolution/search`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get issue type usages by status and project
    #
    # + statusId - The statusId to fetch issue type usages for
    # + projectId - The projectId to fetch issue type usages for
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get statuses/[string statusId]/project/[string projectId]/issueTypeUsages(map<string|string[]> headers = {}, *GetProjectIssueTypeUsagesForStatusQueries queries) returns StatusProjectIssueTypeUsageDTO|error {
        string resourcePath = string `/statuses/${getEncodedUri(statusId)}/project/${getEncodedUri(projectId)}/issueTypeUsages`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get issue security level
    #
    # + id - The ID of the issue security level
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get securitylevel/[string id](map<string|string[]> headers = {}) returns SecurityLevel|error {
        string resourcePath = string `/securitylevel/${getEncodedUri(id)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get contexts for a field
    #
    # + fieldId - The ID of the field to return contexts for
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    # 
    # # Deprecated
    @deprecated
    resource isolated function get 'field/[string fieldId]/contexts(map<string|string[]> headers = {}, *GetContextsForFieldDeprecatedQueries queries) returns PageBeanContext|error {
        string resourcePath = string `/field/${getEncodedUri(fieldId)}/contexts`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get default actors for project role
    #
    # + id - The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get role/[int id]/actors(map<string|string[]> headers = {}) returns ProjectRole|error {
        string resourcePath = string `/role/${getEncodedUri(id)}/actors`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Add default actors to project role
    #
    # + id - The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post role/[int id]/actors(ActorInputBean payload, map<string|string[]> headers = {}) returns ProjectRole|error {
        string resourcePath = string `/role/${getEncodedUri(id)}/actors`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete default actors from project role
    #
    # + id - The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete role/[int id]/actors(map<string|string[]> headers = {}, *DeleteProjectRoleActorsFromRoleQueries queries) returns ProjectRole|error {
        string resourcePath = string `/role/${getEncodedUri(id)}/actors`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get workflow for issue type in workflow scheme
    #
    # + id - The ID of the workflow scheme
    # + issueType - The ID of the issue type
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get workflowscheme/[int id]/issuetype/[string issueType](map<string|string[]> headers = {}, *GetWorkflowSchemeIssueTypeQueries queries) returns IssueTypeWorkflowMapping|error {
        string resourcePath = string `/workflowscheme/${getEncodedUri(id)}/issuetype/${getEncodedUri(issueType)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Set workflow for issue type in workflow scheme
    #
    # + id - The ID of the workflow scheme
    # + issueType - The ID of the issue type
    # + headers - Headers to be sent with the request 
    # + payload - The issue type-project mapping 
    # + return - Returned if the request is successful 
    resource isolated function put workflowscheme/[int id]/issuetype/[string issueType](IssueTypeWorkflowMapping payload, map<string|string[]> headers = {}) returns WorkflowScheme|error {
        string resourcePath = string `/workflowscheme/${getEncodedUri(id)}/issuetype/${getEncodedUri(issueType)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete workflow for issue type in workflow scheme
    #
    # + id - The ID of the workflow scheme
    # + issueType - The ID of the issue type
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete workflowscheme/[int id]/issuetype/[string issueType](map<string|string[]> headers = {}, *DeleteWorkflowSchemeIssueTypeQueries queries) returns WorkflowScheme|error {
        string resourcePath = string `/workflowscheme/${getEncodedUri(id)}/issuetype/${getEncodedUri(issueType)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get issue watchers
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issue/[string issueIdOrKey]/watchers(map<string|string[]> headers = {}) returns Watchers|error {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/watchers`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Add watcher
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + payload - The account ID of the user. Note that username cannot be used due to privacy changes 
    # + return - Returned if the request is successful 
    resource isolated function post issue/[string issueIdOrKey]/watchers(string payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/watchers`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete watcher
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete issue/[string issueIdOrKey]/watchers(map<string|string[]> headers = {}, *RemoveWatcherQueries queries) returns error? {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/watchers`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Bulk get workflows
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post workflows(WorkflowReadRequest payload, map<string|string[]> headers = {}, *ReadWorkflowsQueries queries) returns WorkflowReadResponse|error {
        string resourcePath = string `/workflows`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Bulk set issues properties by list
    #
    # + headers - Headers to be sent with the request 
    # + payload - Issue properties to be set or updated with values 
    # + return - Returned if the operation is successful 
    resource isolated function post issue/properties(IssueEntityProperties payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/issue/properties`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Update issue security level
    #
    # + schemeId - The ID of the issue security scheme level belongs to
    # + levelId - The ID of the issue security level to update
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put issuesecurityschemes/[string schemeId]/level/[string levelId](UpdateIssueSecurityLevelDetails payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/issuesecurityschemes/${getEncodedUri(schemeId)}/level/${getEncodedUri(levelId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Remove issue security level
    #
    # + schemeId - The ID of the issue security scheme
    # + levelId - The ID of the issue security level to remove
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete issuesecurityschemes/[string schemeId]/level/[string levelId](map<string|string[]> headers = {}, *RemoveLevelQueries queries) returns http:Response|error {
        string resourcePath = string `/issuesecurityschemes/${getEncodedUri(schemeId)}/level/${getEncodedUri(levelId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Find components for projects
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get component(map<string|string[]> headers = {}, *FindComponentsForProjectsQueries queries) returns PageBean2ComponentJsonBean|error {
        string resourcePath = string `/component`;
        map<Encoding> queryParamEncoding = {"projectIdsOrKeys": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create component
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post component(ProjectComponent payload, map<string|string[]> headers = {}) returns ProjectComponent|error {
        string resourcePath = string `/component`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Update custom field context
    #
    # + fieldId - The ID of the custom field
    # + contextId - The ID of the context
    # + headers - Headers to be sent with the request 
    # + return - Returned if the context is updated 
    resource isolated function put 'field/[string fieldId]/context/[int contextId](CustomFieldContextUpdateDetails payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/field/${getEncodedUri(fieldId)}/context/${getEncodedUri(contextId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete custom field context
    #
    # + fieldId - The ID of the custom field
    # + contextId - The ID of the context
    # + headers - Headers to be sent with the request 
    # + return - Returned if the context is deleted 
    resource isolated function delete 'field/[string fieldId]/context/[int contextId](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/field/${getEncodedUri(fieldId)}/context/${getEncodedUri(contextId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get app properties
    #
    # + addonKey - The key of the app, as defined in its descriptor
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get atlassian\-connect/'1/addons/[string addonKey]/properties(map<string|string[]> headers = {}) returns PropertyKeys|error {
        string resourcePath = string `/atlassian-connect/1/addons/${getEncodedUri(addonKey)}/properties`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get all field configurations
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get fieldconfiguration(map<string|string[]> headers = {}, *GetAllFieldConfigurationsQueries queries) returns PageBeanFieldConfigurationDetails|error {
        string resourcePath = string `/fieldconfiguration`;
        map<Encoding> queryParamEncoding = {"id": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create field configuration
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post fieldconfiguration(FieldConfigurationDetails payload, map<string|string[]> headers = {}) returns FieldConfiguration|error {
        string resourcePath = string `/fieldconfiguration`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get available transitions
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get bulk/issues/transition(map<string|string[]> headers = {}, *GetAvailableTransitionsQueries queries) returns BulkTransitionGetAvailableTransitions|error {
        string resourcePath = string `/bulk/issues/transition`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Bulk transition issue statuses
    #
    # + headers - Headers to be sent with the request 
    # + payload - The request body containing the issues to be transitioned 
    # + return - Returned if the request is successful 
    resource isolated function post bulk/issues/transition(IssueBulkTransitionPayload payload, map<string|string[]> headers = {}) returns SubmittedBulkOperation|error {
        string resourcePath = string `/bulk/issues/transition`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get all time tracking providers
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get configuration/timetracking/list(map<string|string[]> headers = {}) returns TimeTrackingProvider[]|error {
        string resourcePath = string `/configuration/timetracking/list`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update issue type screen scheme
    #
    # + issueTypeScreenSchemeId - The ID of the issue type screen scheme
    # + headers - Headers to be sent with the request 
    # + payload - The issue type screen scheme update details 
    # + return - Returned if the request is successful 
    resource isolated function put issuetypescreenscheme/[string issueTypeScreenSchemeId](IssueTypeScreenSchemeUpdateDetails payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/issuetypescreenscheme/${getEncodedUri(issueTypeScreenSchemeId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete issue type screen scheme
    #
    # + issueTypeScreenSchemeId - The ID of the issue type screen scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the issue type screen scheme is deleted 
    resource isolated function delete issuetypescreenscheme/[string issueTypeScreenSchemeId](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/issuetypescreenscheme/${getEncodedUri(issueTypeScreenSchemeId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Find user keys by query
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get user/search/query/'key(map<string|string[]> headers = {}, *FindUserKeysByQueryQueries queries) returns PageBeanUserKey|error {
        string resourcePath = string `/user/search/query/key`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get avatar image by type
    #
    # + 'type - The icon type of the avatar
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get universal_avatar/view/'type/["issuetype"|"project"|"priority" 'type](map<string|string[]> headers = {}, *GetAvatarImageByTypeQueries queries) returns StreamingResponseBody|error {
        string resourcePath = string `/universal_avatar/view/type/${getEncodedUri('type)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update UI modification
    #
    # + uiModificationId - The ID of the UI modification
    # + headers - Headers to be sent with the request 
    # + payload - Details of the UI modification 
    # + return - Returned if the UI modification is updated 
    resource isolated function put uiModifications/[string uiModificationId](UpdateUiModificationDetails payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/uiModifications/${getEncodedUri(uiModificationId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete UI modification
    #
    # + uiModificationId - The ID of the UI modification
    # + headers - Headers to be sent with the request 
    # + return - Returned if the UI modification is deleted 
    resource isolated function delete uiModifications/[string uiModificationId](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/uiModifications/${getEncodedUri(uiModificationId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get notification scheme
    #
    # + id - The ID of the notification scheme. Use [Get notification schemes paginated](#api-rest-api-3-notificationscheme-get) to get a list of notification scheme IDs
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get notificationscheme/[int id](map<string|string[]> headers = {}, *GetNotificationSchemeQueries queries) returns NotificationScheme|error {
        string resourcePath = string `/notificationscheme/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update notification scheme
    #
    # + id - The ID of the notification scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put notificationscheme/[string id](UpdateNotificationSchemeDetails payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/notificationscheme/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Set default issue security levels
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put issuesecurityschemes/level/default(SetDefaultLevelsRequest payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/issuesecurityschemes/level/default`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Archive plan
    #
    # + planId - The ID of the plan
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put plans/plan/[int planId]/archive(map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/plans/plan/${getEncodedUri(planId)}/archive`;
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get accessible project type by key
    #
    # + projectTypeKey - The key of the project type
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get project/'type/["software"|"service_desk"|"business"|"product_discovery" projectTypeKey]/accessible(map<string|string[]> headers = {}) returns ProjectType|error {
        string resourcePath = string `/project/type/${getEncodedUri(projectTypeKey)}/accessible`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get dashboard item property
    #
    # + dashboardId - The ID of the dashboard
    # + itemId - The ID of the dashboard item
    # + propertyKey - The key of the dashboard item property
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get dashboard/[string dashboardId]/items/[string itemId]/properties/[string propertyKey](map<string|string[]> headers = {}) returns EntityProperty|error {
        string resourcePath = string `/dashboard/${getEncodedUri(dashboardId)}/items/${getEncodedUri(itemId)}/properties/${getEncodedUri(propertyKey)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set dashboard item property
    #
    # + dashboardId - The ID of the dashboard
    # + itemId - The ID of the dashboard item
    # + propertyKey - The key of the dashboard item property. The maximum length is 255 characters. For dashboard items with a spec URI and no complete module key, if the provided propertyKey is equal to "config", the request body's JSON must be an object with all keys and values as strings
    # + headers - Headers to be sent with the request 
    # + payload - The value of the property. The value has to be a valid, non-empty [JSON](https://tools.ietf.org/html/rfc4627) value. The maximum length of the property value is 32768 bytes 
    # + return - Returned if the dashboard item property is updated 
    resource isolated function put dashboard/[string dashboardId]/items/[string itemId]/properties/[string propertyKey](json payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/dashboard/${getEncodedUri(dashboardId)}/items/${getEncodedUri(itemId)}/properties/${getEncodedUri(propertyKey)}`;
        http:Request request = new;
        request.setPayload(payload, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete dashboard item property
    #
    # + dashboardId - The ID of the dashboard
    # + itemId - The ID of the dashboard item
    # + propertyKey - The key of the dashboard item property
    # + headers - Headers to be sent with the request 
    # + return - Returned if the dashboard item property is deleted 
    resource isolated function delete dashboard/[string dashboardId]/items/[string itemId]/properties/[string propertyKey](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/dashboard/${getEncodedUri(dashboardId)}/items/${getEncodedUri(itemId)}/properties/${getEncodedUri(propertyKey)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get global settings
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get configuration(map<string|string[]> headers = {}) returns Configuration|error {
        string resourcePath = string `/configuration`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get version's unresolved issues count
    #
    # + id - The ID of the version
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get version/[string id]/unresolvedIssueCount(map<string|string[]> headers = {}) returns VersionUnresolvedIssuesCount|error {
        string resourcePath = string `/version/${getEncodedUri(id)}/unresolvedIssueCount`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete inactive workflow
    #
    # + entityId - The entity ID of the workflow
    # + headers - Headers to be sent with the request 
    # + return - Returned if the workflow is deleted 
    resource isolated function delete workflow/[string entityId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/workflow/${getEncodedUri(entityId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Bulk get groups
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get group/bulk(map<string|string[]> headers = {}, *BulkGetGroupsQueries queries) returns PageBeanGroupDetails|error {
        string resourcePath = string `/group/bulk`;
        map<Encoding> queryParamEncoding = {"groupId": {style: FORM, explode: true}, "groupName": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get related work
    #
    # + id - The ID of the version
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get version/[string id]/relatedwork(map<string|string[]> headers = {}) returns VersionRelatedWork[]|error {
        string resourcePath = string `/version/${getEncodedUri(id)}/relatedwork`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update related work
    #
    # + id - The ID of the version to update the related work on. For the related work id, pass it to the input JSON
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful together with updated related work 
    resource isolated function put version/[string id]/relatedwork(VersionRelatedWork payload, map<string|string[]> headers = {}) returns VersionRelatedWork|error {
        string resourcePath = string `/version/${getEncodedUri(id)}/relatedwork`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Create related work
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post version/[string id]/relatedwork(VersionRelatedWork payload, map<string|string[]> headers = {}) returns VersionRelatedWork|error {
        string resourcePath = string `/version/${getEncodedUri(id)}/relatedwork`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get workflow scheme project associations
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get workflowscheme/project(map<string|string[]> headers = {}, *GetWorkflowSchemeProjectAssociationsQueries queries) returns ContainerOfWorkflowSchemeAssociations|error {
        string resourcePath = string `/workflowscheme/project`;
        map<Encoding> queryParamEncoding = {"projectId": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Assign workflow scheme to project
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put workflowscheme/project(WorkflowSchemeProjectAssociation payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/workflowscheme/project`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get project features
    #
    # + projectIdOrKey - The ID or (case-sensitive) key of the project
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get project/[string projectIdOrKey]/features(map<string|string[]> headers = {}) returns ContainerForProjectFeatures|error {
        string resourcePath = string `/project/${getEncodedUri(projectIdOrKey)}/features`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Unarchive issue(s) by issue keys/ID
    #
    # + headers - Headers to be sent with the request 
    # + payload - Contains a list of issue keys or IDs to be unarchived 
    # + return - Returned if there is at least one valid issue to unarchive in the request. It will return the count of unarchived issues, which also includes the count of the subtasks unarchived, and it will show the detailed errors for those issues which are not unarchived 
    resource isolated function put issue/unarchive(IssueArchivalSyncRequest payload, map<string|string[]> headers = {}) returns IssueArchivalSyncResponse|error {
        string resourcePath = string `/issue/unarchive`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get bulk editable fields
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get bulk/issues/fields(map<string|string[]> headers = {}, *GetBulkEditableFieldsQueries queries) returns BulkEditGetFields|error {
        string resourcePath = string `/bulk/issues/fields`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Bulk edit issues
    #
    # + headers - Headers to be sent with the request 
    # + payload - The request body containing the issues to be edited and the new field values 
    # + return - Returned if the request is successful 
    resource isolated function post bulk/issues/fields(IssueBulkEditPayload payload, map<string|string[]> headers = {}) returns SubmittedBulkOperation|error {
        string resourcePath = string `/bulk/issues/fields`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Bulk update entity properties
    #
    # + entityType - The type indicating the object that contains the entity properties
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put atlassian\-connect/'1/migration/properties/["IssueProperty"|"CommentProperty"|"DashboardItemProperty"|"IssueTypeProperty"|"ProjectProperty"|"UserProperty"|"WorklogProperty"|"BoardProperty"|"SprintProperty" entityType](MigrationResourceUpdateEntityPropertiesValuePutHeaders headers, EntityPropertyDetails[] payload) returns error? {
        string resourcePath = string `/atlassian-connect/1/migration/properties/${getEncodedUri(entityType)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Get all users
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get users/search(map<string|string[]> headers = {}, *GetAllUsersQueries queries) returns User[]|error {
        string resourcePath = string `/users/search`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get issue type screen scheme projects
    #
    # + issueTypeScreenSchemeId - The ID of the issue type screen scheme
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issuetypescreenscheme/[int issueTypeScreenSchemeId]/project(map<string|string[]> headers = {}, *GetProjectsForIssueTypeScreenSchemeQueries queries) returns PageBeanProjectDetails|error {
        string resourcePath = string `/issuetypescreenscheme/${getEncodedUri(issueTypeScreenSchemeId)}/project`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get issue types for workflows in workflow scheme
    #
    # + id - The ID of the workflow scheme
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get workflowscheme/[int id]/workflow(map<string|string[]> headers = {}, *GetWorkflowQueries queries) returns IssueTypesWorkflowMapping|error {
        string resourcePath = string `/workflowscheme/${getEncodedUri(id)}/workflow`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Set issue types for workflow in workflow scheme
    #
    # + id - The ID of the workflow scheme
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put workflowscheme/[int id]/workflow(IssueTypesWorkflowMapping payload, map<string|string[]> headers = {}, *UpdateWorkflowMappingQueries queries) returns WorkflowScheme|error {
        string resourcePath = string `/workflowscheme/${getEncodedUri(id)}/workflow`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete issue types for workflow in workflow scheme
    #
    # + id - The ID of the workflow scheme
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete workflowscheme/[int id]/workflow(map<string|string[]> headers = {}, *DeleteWorkflowMappingQueries queries) returns error? {
        string resourcePath = string `/workflowscheme/${getEncodedUri(id)}/workflow`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get all projects
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    # 
    # # Deprecated
    @deprecated
    resource isolated function get project(map<string|string[]> headers = {}, *GetAllProjectsQueries queries) returns Project[]|error {
        string resourcePath = string `/project`;
        map<Encoding> queryParamEncoding = {"properties": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create project
    #
    # + headers - Headers to be sent with the request 
    # + payload - The JSON representation of the project being created 
    # + return - Returned if the project is created 
    resource isolated function post project(CreateProjectDetails payload, map<string|string[]> headers = {}) returns ProjectIdentifiers|error {
        string resourcePath = string `/project`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Update priority scheme
    #
    # + schemeId - The ID of the priority scheme
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is accepted 
    resource isolated function put priorityscheme/[int schemeId](UpdatePrioritySchemeRequestBean payload, map<string|string[]> headers = {}) returns UpdatePrioritySchemeResponseBean|error {
        string resourcePath = string `/priorityscheme/${getEncodedUri(schemeId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete priority scheme
    #
    # + schemeId - The priority scheme ID
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete priorityscheme/[int schemeId](map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/priorityscheme/${getEncodedUri(schemeId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get all project roles
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get role(map<string|string[]> headers = {}) returns ProjectRole[]|error {
        string resourcePath = string `/role`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create project role
    #
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post role(CreateUpdateRoleRequestBean payload, map<string|string[]> headers = {}) returns ProjectRole|error {
        string resourcePath = string `/role`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete avatar
    #
    # + 'type - The avatar type
    # + owningObjectId - The ID of the item the avatar is associated with
    # + id - The ID of the avatar
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete universal_avatar/'type/["project"|"issuetype"|"priority" 'type]/owner/[string owningObjectId]/avatar/[int id](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/universal_avatar/type/${getEncodedUri('type)}/owner/${getEncodedUri(owningObjectId)}/avatar/${getEncodedUri(id)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get all issue field options
    #
    # + fieldKey - The field key is specified in the following format: **$(app-key)\_\_$(field-key)**. For example, *example-add-on\_\_example-issue-field*. To determine the `fieldKey` value, do one of the following:
    # *  open the app's plugin descriptor, then **app-key** is the key at the top and **field-key** is the key in the `jiraIssueFields` module. **app-key** can also be found in the app listing in the Atlassian Universal Plugin Manager.
    # *  run [Get fields](#api-rest-api-3-field-get) and in the field details the value is returned in `key`. For example, `"key": "teams-add-on__team-issue-field"`
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get 'field/[string fieldKey]/option(map<string|string[]> headers = {}, *GetAllIssueFieldOptionsQueries queries) returns PageBeanIssueFieldOption|error {
        string resourcePath = string `/field/${getEncodedUri(fieldKey)}/option`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create issue field option
    #
    # + fieldKey - The field key is specified in the following format: **$(app-key)\_\_$(field-key)**. For example, *example-add-on\_\_example-issue-field*. To determine the `fieldKey` value, do one of the following:
    # *  open the app's plugin descriptor, then **app-key** is the key at the top and **field-key** is the key in the `jiraIssueFields` module. **app-key** can also be found in the app listing in the Atlassian Universal Plugin Manager.
    # *  run [Get fields](#api-rest-api-3-field-get) and in the field details the value is returned in `key`. For example, `"key": "teams-add-on__team-issue-field"`
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function post 'field/[string fieldKey]/option(IssueFieldOptionCreateBean payload, map<string|string[]> headers = {}) returns IssueFieldOption|error {
        string resourcePath = string `/field/${getEncodedUri(fieldKey)}/option`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get issue property
    #
    # + issueIdOrKey - The key or ID of the issue
    # + propertyKey - The key of the property
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issue/[string issueIdOrKey]/properties/[string propertyKey](map<string|string[]> headers = {}) returns EntityProperty|error {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/properties/${getEncodedUri(propertyKey)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set issue property
    #
    # + issueIdOrKey - The ID or key of the issue
    # + propertyKey - The key of the issue property. The maximum length is 255 characters
    # + headers - Headers to be sent with the request 
    # + payload - The value of the property. The value has to be a valid, non-empty [JSON](https://tools.ietf.org/html/rfc4627) value. The maximum length of the property value is 32768 bytes 
    # + return - Returned if the issue property is updated 
    resource isolated function put issue/[string issueIdOrKey]/properties/[string propertyKey](json payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/properties/${getEncodedUri(propertyKey)}`;
        http:Request request = new;
        request.setPayload(payload, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete issue property
    #
    # + issueIdOrKey - The key or ID of the issue
    # + propertyKey - The key of the property
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function delete issue/[string issueIdOrKey]/properties/[string propertyKey](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/properties/${getEncodedUri(propertyKey)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get edit issue metadata
    #
    # + issueIdOrKey - The ID or key of the issue
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get issue/[string issueIdOrKey]/editmeta(map<string|string[]> headers = {}, *GetEditIssueMetaQueries queries) returns IssueUpdateMetadata|error {
        string resourcePath = string `/issue/${getEncodedUri(issueIdOrKey)}/editmeta`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get field configuration items
    #
    # + id - The ID of the field configuration
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function get fieldconfiguration/[int id]/fields(map<string|string[]> headers = {}, *GetFieldConfigurationItemsQueries queries) returns PageBeanFieldConfigurationItem|error {
        string resourcePath = string `/fieldconfiguration/${getEncodedUri(id)}/fields`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update field configuration items
    #
    # + id - The ID of the field configuration
    # + headers - Headers to be sent with the request 
    # + return - Returned if the request is successful 
    resource isolated function put fieldconfiguration/[int id]/fields(FieldConfigurationItemsDetails payload, map<string|string[]> headers = {}) returns json|error {
        string resourcePath = string `/fieldconfiguration/${getEncodedUri(id)}/fields`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }
}
